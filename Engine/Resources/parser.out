Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CONTINUE

Grammar

Rule 0     S' -> expressions
Rule 1     expression -> MACRO = expression
Rule 2     expression -> MACRO
Rule 3     atom -> VARIABLE = expression
Rule 4     atom -> VARIABLE
Rule 5     else_branch -> ELSE scope
Rule 6     elif_branch -> ELSEIF ( expression ) scope elif_branch
Rule 7     elif_branch -> ELSEIF ( expression ) scope else_branch
Rule 8     elif_branch -> ELSEIF ( expression ) scope
Rule 9     if_condition -> IF ( expression ) scope elif_branch
Rule 10    if_condition -> IF ( expression ) scope else_branch
Rule 11    if_condition -> IF ( expression ) scope
Rule 12    function_call -> FUNCTION parameters scope
Rule 13    function_call -> FUNCTION parameters tag_list
Rule 14    function_call -> FUNCTION parameters
Rule 15    function_call -> FUNCTION
Rule 16    tag -> TAG expression
Rule 17    tag_list -> tag # scope tag_list
Rule 18    tag_list -> tag # scope
Rule 19    scope -> { expressions }
Rule 20    expressions -> statement expressions
Rule 21    expressions -> statement
Rule 22    parameters -> ( param_element )
Rule 23    parameters -> ( )
Rule 24    param_element_pos -> WORD = expression , param_element_pos
Rule 25    param_element_pos -> WORD = expression ,
Rule 26    param_element_pos -> WORD = expression
Rule 27    param_element -> expression , param_element
Rule 28    param_element -> expression , param_element_pos
Rule 29    param_element -> expression ,
Rule 30    param_element -> expression
Rule 31    statement -> BREAK
Rule 32    statement -> expression
Rule 33    statement -> if_condition
Rule 34    atom -> function_call
Rule 35    comp -> NOT comp
Rule 36    comp -> arith LT arith
Rule 37    comp -> arith LE arith
Rule 38    comp -> arith GT arith
Rule 39    comp -> arith GE arith
Rule 40    comp -> arith EE arith
Rule 41    comp -> arith NE arith
Rule 42    comp -> comp AND comp
Rule 43    comp -> comp OR comp
Rule 44    comp -> arith
Rule 45    arith -> atom + atom
Rule 46    arith -> atom - atom
Rule 47    arith -> atom * atom
Rule 48    arith -> atom / atom
Rule 49    arith -> atom
Rule 50    atom -> - atom
Rule 51    comma_expressions -> expression , comma_expressions
Rule 52    comma_expressions -> expression ,
Rule 53    comma_expressions -> expression
Rule 54    arith -> MIN ( comma_expressions )
Rule 55    arith -> MAX ( comma_expressions )
Rule 56    atom -> ( expression )
Rule 57    statement -> RETURN expression
Rule 58    statement -> RETURN
Rule 59    table_contents -> STRING : expression , table_contents
Rule 60    table_contents -> NUMBER : expression , table_contents
Rule 61    table_contents -> STRING : expression ,
Rule 62    table_contents -> NUMBER : expression ,
Rule 63    table_contents -> STRING : expression
Rule 64    table_contents -> NUMBER : expression
Rule 65    table -> % [ comma_expressions ]
Rule 66    table -> % { table_contents }
Rule 67    atom -> NUMBER
Rule 68    atom -> BOOLEAN
Rule 69    atom -> STRING
Rule 70    atom -> table
Rule 71    atom -> WORD
Rule 72    atom -> scope
Rule 73    expression -> comp

Terminals, with rules where they appear

#                    : 17 18
%                    : 65 66
(                    : 6 7 8 9 10 11 22 23 54 55 56
)                    : 6 7 8 9 10 11 22 23 54 55 56
*                    : 47
+                    : 45
,                    : 24 25 27 28 29 51 52 59 60 61 62
-                    : 46 50
/                    : 48
:                    : 59 60 61 62 63 64
=                    : 1 3 24 25 26
AND                  : 42
BOOLEAN              : 68
BREAK                : 31
CONTINUE             : 
EE                   : 40
ELSE                 : 5
ELSEIF               : 6 7 8
FUNCTION             : 12 13 14 15
GE                   : 39
GT                   : 38
IF                   : 9 10 11
LE                   : 37
LT                   : 36
MACRO                : 1 2
MAX                  : 55
MIN                  : 54
NE                   : 41
NOT                  : 35
NUMBER               : 60 62 64 67
OR                   : 43
RETURN               : 57 58
STRING               : 59 61 63 69
TAG                  : 16
VARIABLE             : 3 4
WORD                 : 24 25 26 71
[                    : 65
]                    : 65
error                : 
{                    : 19 66
}                    : 19 66

Nonterminals, with rules where they appear

arith                : 36 36 37 37 38 38 39 39 40 40 41 41 44
atom                 : 45 45 46 46 47 47 48 48 49 50
comma_expressions    : 51 54 55 65
comp                 : 35 42 42 43 43 73
elif_branch          : 6 9
else_branch          : 7 10
expression           : 1 3 6 7 8 9 10 11 16 24 25 26 27 28 29 30 32 51 52 53 56 57 59 60 61 62 63 64
expressions          : 19 20 0
function_call        : 34
if_condition         : 33
param_element        : 22 27
param_element_pos    : 24 28
parameters           : 12 13 14
scope                : 5 6 7 8 9 10 11 12 17 18 72
statement            : 20 21
table                : 70
table_contents       : 59 60 66
tag                  : 17 18
tag_list             : 13 17

Parsing method: LALR

state 0

    (0) S' -> . expressions
    (20) expressions -> . statement expressions
    (21) expressions -> . statement
    (31) statement -> . BREAK
    (32) statement -> . expression
    (33) statement -> . if_condition
    (57) statement -> . RETURN expression
    (58) statement -> . RETURN
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (9) if_condition -> . IF ( expression ) scope elif_branch
    (10) if_condition -> . IF ( expression ) scope else_branch
    (11) if_condition -> . IF ( expression ) scope
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    BREAK           shift and go to state 3
    RETURN          shift and go to state 6
    MACRO           shift and go to state 7
    IF              shift and go to state 9
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    expressions                    shift and go to state 1
    statement                      shift and go to state 2
    expression                     shift and go to state 4
    if_condition                   shift and go to state 5
    comp                           shift and go to state 8
    scope                          shift and go to state 11
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23

state 1

    (0) S' -> expressions .



state 2

    (20) expressions -> statement . expressions
    (21) expressions -> statement .
    (20) expressions -> . statement expressions
    (21) expressions -> . statement
    (31) statement -> . BREAK
    (32) statement -> . expression
    (33) statement -> . if_condition
    (57) statement -> . RETURN expression
    (58) statement -> . RETURN
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (9) if_condition -> . IF ( expression ) scope elif_branch
    (10) if_condition -> . IF ( expression ) scope else_branch
    (11) if_condition -> . IF ( expression ) scope
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    $end            reduce using rule 21 (expressions -> statement .)
    }               reduce using rule 21 (expressions -> statement .)
    BREAK           shift and go to state 3
    RETURN          shift and go to state 6
    MACRO           shift and go to state 7
    IF              shift and go to state 9
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    statement                      shift and go to state 2
    expressions                    shift and go to state 28
    expression                     shift and go to state 4
    if_condition                   shift and go to state 5
    comp                           shift and go to state 8
    scope                          shift and go to state 11
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23

state 3

    (31) statement -> BREAK .

    BREAK           reduce using rule 31 (statement -> BREAK .)
    RETURN          reduce using rule 31 (statement -> BREAK .)
    MACRO           reduce using rule 31 (statement -> BREAK .)
    IF              reduce using rule 31 (statement -> BREAK .)
    NOT             reduce using rule 31 (statement -> BREAK .)
    MIN             reduce using rule 31 (statement -> BREAK .)
    MAX             reduce using rule 31 (statement -> BREAK .)
    VARIABLE        reduce using rule 31 (statement -> BREAK .)
    -               reduce using rule 31 (statement -> BREAK .)
    (               reduce using rule 31 (statement -> BREAK .)
    NUMBER          reduce using rule 31 (statement -> BREAK .)
    BOOLEAN         reduce using rule 31 (statement -> BREAK .)
    STRING          reduce using rule 31 (statement -> BREAK .)
    WORD            reduce using rule 31 (statement -> BREAK .)
    FUNCTION        reduce using rule 31 (statement -> BREAK .)
    %               reduce using rule 31 (statement -> BREAK .)
    {               reduce using rule 31 (statement -> BREAK .)
    $end            reduce using rule 31 (statement -> BREAK .)
    }               reduce using rule 31 (statement -> BREAK .)


state 4

    (32) statement -> expression .

    BREAK           reduce using rule 32 (statement -> expression .)
    RETURN          reduce using rule 32 (statement -> expression .)
    MACRO           reduce using rule 32 (statement -> expression .)
    IF              reduce using rule 32 (statement -> expression .)
    NOT             reduce using rule 32 (statement -> expression .)
    MIN             reduce using rule 32 (statement -> expression .)
    MAX             reduce using rule 32 (statement -> expression .)
    VARIABLE        reduce using rule 32 (statement -> expression .)
    -               reduce using rule 32 (statement -> expression .)
    (               reduce using rule 32 (statement -> expression .)
    NUMBER          reduce using rule 32 (statement -> expression .)
    BOOLEAN         reduce using rule 32 (statement -> expression .)
    STRING          reduce using rule 32 (statement -> expression .)
    WORD            reduce using rule 32 (statement -> expression .)
    FUNCTION        reduce using rule 32 (statement -> expression .)
    %               reduce using rule 32 (statement -> expression .)
    {               reduce using rule 32 (statement -> expression .)
    $end            reduce using rule 32 (statement -> expression .)
    }               reduce using rule 32 (statement -> expression .)


state 5

    (33) statement -> if_condition .

    BREAK           reduce using rule 33 (statement -> if_condition .)
    RETURN          reduce using rule 33 (statement -> if_condition .)
    MACRO           reduce using rule 33 (statement -> if_condition .)
    IF              reduce using rule 33 (statement -> if_condition .)
    NOT             reduce using rule 33 (statement -> if_condition .)
    MIN             reduce using rule 33 (statement -> if_condition .)
    MAX             reduce using rule 33 (statement -> if_condition .)
    VARIABLE        reduce using rule 33 (statement -> if_condition .)
    -               reduce using rule 33 (statement -> if_condition .)
    (               reduce using rule 33 (statement -> if_condition .)
    NUMBER          reduce using rule 33 (statement -> if_condition .)
    BOOLEAN         reduce using rule 33 (statement -> if_condition .)
    STRING          reduce using rule 33 (statement -> if_condition .)
    WORD            reduce using rule 33 (statement -> if_condition .)
    FUNCTION        reduce using rule 33 (statement -> if_condition .)
    %               reduce using rule 33 (statement -> if_condition .)
    {               reduce using rule 33 (statement -> if_condition .)
    $end            reduce using rule 33 (statement -> if_condition .)
    }               reduce using rule 33 (statement -> if_condition .)


state 6

    (57) statement -> RETURN . expression
    (58) statement -> RETURN .
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

  ! shift/reduce conflict for MACRO resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MIN resolved as shift
  ! shift/reduce conflict for MAX resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for WORD resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for { resolved as shift
    BREAK           reduce using rule 58 (statement -> RETURN .)
    RETURN          reduce using rule 58 (statement -> RETURN .)
    IF              reduce using rule 58 (statement -> RETURN .)
    $end            reduce using rule 58 (statement -> RETURN .)
    }               reduce using rule 58 (statement -> RETURN .)
    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

  ! MACRO           [ reduce using rule 58 (statement -> RETURN .) ]
  ! NOT             [ reduce using rule 58 (statement -> RETURN .) ]
  ! MIN             [ reduce using rule 58 (statement -> RETURN .) ]
  ! MAX             [ reduce using rule 58 (statement -> RETURN .) ]
  ! VARIABLE        [ reduce using rule 58 (statement -> RETURN .) ]
  ! -               [ reduce using rule 58 (statement -> RETURN .) ]
  ! (               [ reduce using rule 58 (statement -> RETURN .) ]
  ! NUMBER          [ reduce using rule 58 (statement -> RETURN .) ]
  ! BOOLEAN         [ reduce using rule 58 (statement -> RETURN .) ]
  ! STRING          [ reduce using rule 58 (statement -> RETURN .) ]
  ! WORD            [ reduce using rule 58 (statement -> RETURN .) ]
  ! FUNCTION        [ reduce using rule 58 (statement -> RETURN .) ]
  ! %               [ reduce using rule 58 (statement -> RETURN .) ]
  ! {               [ reduce using rule 58 (statement -> RETURN .) ]

    expression                     shift and go to state 29
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 7

    (1) expression -> MACRO . = expression
    (2) expression -> MACRO .

    =               shift and go to state 30
    BREAK           reduce using rule 2 (expression -> MACRO .)
    RETURN          reduce using rule 2 (expression -> MACRO .)
    MACRO           reduce using rule 2 (expression -> MACRO .)
    IF              reduce using rule 2 (expression -> MACRO .)
    NOT             reduce using rule 2 (expression -> MACRO .)
    MIN             reduce using rule 2 (expression -> MACRO .)
    MAX             reduce using rule 2 (expression -> MACRO .)
    VARIABLE        reduce using rule 2 (expression -> MACRO .)
    -               reduce using rule 2 (expression -> MACRO .)
    (               reduce using rule 2 (expression -> MACRO .)
    NUMBER          reduce using rule 2 (expression -> MACRO .)
    BOOLEAN         reduce using rule 2 (expression -> MACRO .)
    STRING          reduce using rule 2 (expression -> MACRO .)
    WORD            reduce using rule 2 (expression -> MACRO .)
    FUNCTION        reduce using rule 2 (expression -> MACRO .)
    %               reduce using rule 2 (expression -> MACRO .)
    {               reduce using rule 2 (expression -> MACRO .)
    $end            reduce using rule 2 (expression -> MACRO .)
    }               reduce using rule 2 (expression -> MACRO .)
    )               reduce using rule 2 (expression -> MACRO .)
    AND             reduce using rule 2 (expression -> MACRO .)
    OR              reduce using rule 2 (expression -> MACRO .)
    ,               reduce using rule 2 (expression -> MACRO .)
    +               reduce using rule 2 (expression -> MACRO .)
    *               reduce using rule 2 (expression -> MACRO .)
    /               reduce using rule 2 (expression -> MACRO .)
    LT              reduce using rule 2 (expression -> MACRO .)
    LE              reduce using rule 2 (expression -> MACRO .)
    GT              reduce using rule 2 (expression -> MACRO .)
    GE              reduce using rule 2 (expression -> MACRO .)
    EE              reduce using rule 2 (expression -> MACRO .)
    NE              reduce using rule 2 (expression -> MACRO .)
    ]               reduce using rule 2 (expression -> MACRO .)
    #               reduce using rule 2 (expression -> MACRO .)


state 8

    (73) expression -> comp .
    (42) comp -> comp . AND comp
    (43) comp -> comp . OR comp

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    BREAK           reduce using rule 73 (expression -> comp .)
    RETURN          reduce using rule 73 (expression -> comp .)
    MACRO           reduce using rule 73 (expression -> comp .)
    IF              reduce using rule 73 (expression -> comp .)
    NOT             reduce using rule 73 (expression -> comp .)
    MIN             reduce using rule 73 (expression -> comp .)
    MAX             reduce using rule 73 (expression -> comp .)
    VARIABLE        reduce using rule 73 (expression -> comp .)
    -               reduce using rule 73 (expression -> comp .)
    (               reduce using rule 73 (expression -> comp .)
    NUMBER          reduce using rule 73 (expression -> comp .)
    BOOLEAN         reduce using rule 73 (expression -> comp .)
    STRING          reduce using rule 73 (expression -> comp .)
    WORD            reduce using rule 73 (expression -> comp .)
    FUNCTION        reduce using rule 73 (expression -> comp .)
    %               reduce using rule 73 (expression -> comp .)
    {               reduce using rule 73 (expression -> comp .)
    $end            reduce using rule 73 (expression -> comp .)
    }               reduce using rule 73 (expression -> comp .)
    )               reduce using rule 73 (expression -> comp .)
    ,               reduce using rule 73 (expression -> comp .)
    +               reduce using rule 73 (expression -> comp .)
    *               reduce using rule 73 (expression -> comp .)
    /               reduce using rule 73 (expression -> comp .)
    LT              reduce using rule 73 (expression -> comp .)
    LE              reduce using rule 73 (expression -> comp .)
    GT              reduce using rule 73 (expression -> comp .)
    GE              reduce using rule 73 (expression -> comp .)
    EE              reduce using rule 73 (expression -> comp .)
    NE              reduce using rule 73 (expression -> comp .)
    ]               reduce using rule 73 (expression -> comp .)
    #               reduce using rule 73 (expression -> comp .)
    AND             shift and go to state 31
    OR              shift and go to state 32

  ! AND             [ reduce using rule 73 (expression -> comp .) ]
  ! OR              [ reduce using rule 73 (expression -> comp .) ]


state 9

    (9) if_condition -> IF . ( expression ) scope elif_branch
    (10) if_condition -> IF . ( expression ) scope else_branch
    (11) if_condition -> IF . ( expression ) scope

    (               shift and go to state 33


state 10

    (56) atom -> ( . expression )
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    expression                     shift and go to state 34
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 11

    (72) atom -> scope .

    +               reduce using rule 72 (atom -> scope .)
    -               reduce using rule 72 (atom -> scope .)
    *               reduce using rule 72 (atom -> scope .)
    /               reduce using rule 72 (atom -> scope .)
    LT              reduce using rule 72 (atom -> scope .)
    LE              reduce using rule 72 (atom -> scope .)
    GT              reduce using rule 72 (atom -> scope .)
    GE              reduce using rule 72 (atom -> scope .)
    EE              reduce using rule 72 (atom -> scope .)
    NE              reduce using rule 72 (atom -> scope .)
    AND             reduce using rule 72 (atom -> scope .)
    OR              reduce using rule 72 (atom -> scope .)
    BREAK           reduce using rule 72 (atom -> scope .)
    RETURN          reduce using rule 72 (atom -> scope .)
    MACRO           reduce using rule 72 (atom -> scope .)
    IF              reduce using rule 72 (atom -> scope .)
    NOT             reduce using rule 72 (atom -> scope .)
    MIN             reduce using rule 72 (atom -> scope .)
    MAX             reduce using rule 72 (atom -> scope .)
    VARIABLE        reduce using rule 72 (atom -> scope .)
    (               reduce using rule 72 (atom -> scope .)
    NUMBER          reduce using rule 72 (atom -> scope .)
    BOOLEAN         reduce using rule 72 (atom -> scope .)
    STRING          reduce using rule 72 (atom -> scope .)
    WORD            reduce using rule 72 (atom -> scope .)
    FUNCTION        reduce using rule 72 (atom -> scope .)
    %               reduce using rule 72 (atom -> scope .)
    {               reduce using rule 72 (atom -> scope .)
    $end            reduce using rule 72 (atom -> scope .)
    }               reduce using rule 72 (atom -> scope .)
    )               reduce using rule 72 (atom -> scope .)
    ,               reduce using rule 72 (atom -> scope .)
    ]               reduce using rule 72 (atom -> scope .)
    #               reduce using rule 72 (atom -> scope .)


state 12

    (35) comp -> NOT . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    comp                           shift and go to state 35
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 13

    (36) comp -> arith . LT arith
    (37) comp -> arith . LE arith
    (38) comp -> arith . GT arith
    (39) comp -> arith . GE arith
    (40) comp -> arith . EE arith
    (41) comp -> arith . NE arith
    (44) comp -> arith .

  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    LT              shift and go to state 36
    LE              shift and go to state 37
    GT              shift and go to state 38
    GE              shift and go to state 39
    EE              shift and go to state 40
    NE              shift and go to state 41
    AND             reduce using rule 44 (comp -> arith .)
    OR              reduce using rule 44 (comp -> arith .)
    BREAK           reduce using rule 44 (comp -> arith .)
    RETURN          reduce using rule 44 (comp -> arith .)
    MACRO           reduce using rule 44 (comp -> arith .)
    IF              reduce using rule 44 (comp -> arith .)
    NOT             reduce using rule 44 (comp -> arith .)
    MIN             reduce using rule 44 (comp -> arith .)
    MAX             reduce using rule 44 (comp -> arith .)
    VARIABLE        reduce using rule 44 (comp -> arith .)
    -               reduce using rule 44 (comp -> arith .)
    (               reduce using rule 44 (comp -> arith .)
    NUMBER          reduce using rule 44 (comp -> arith .)
    BOOLEAN         reduce using rule 44 (comp -> arith .)
    STRING          reduce using rule 44 (comp -> arith .)
    WORD            reduce using rule 44 (comp -> arith .)
    FUNCTION        reduce using rule 44 (comp -> arith .)
    %               reduce using rule 44 (comp -> arith .)
    {               reduce using rule 44 (comp -> arith .)
    $end            reduce using rule 44 (comp -> arith .)
    }               reduce using rule 44 (comp -> arith .)
    )               reduce using rule 44 (comp -> arith .)
    ,               reduce using rule 44 (comp -> arith .)
    +               reduce using rule 44 (comp -> arith .)
    *               reduce using rule 44 (comp -> arith .)
    /               reduce using rule 44 (comp -> arith .)
    ]               reduce using rule 44 (comp -> arith .)
    #               reduce using rule 44 (comp -> arith .)

  ! LT              [ reduce using rule 44 (comp -> arith .) ]
  ! LE              [ reduce using rule 44 (comp -> arith .) ]
  ! GT              [ reduce using rule 44 (comp -> arith .) ]
  ! GE              [ reduce using rule 44 (comp -> arith .) ]
  ! EE              [ reduce using rule 44 (comp -> arith .) ]
  ! NE              [ reduce using rule 44 (comp -> arith .) ]


state 14

    (45) arith -> atom . + atom
    (46) arith -> atom . - atom
    (47) arith -> atom . * atom
    (48) arith -> atom . / atom
    (49) arith -> atom .

  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    +               shift and go to state 42
    -               shift and go to state 43
    *               shift and go to state 44
    /               shift and go to state 45
    LT              reduce using rule 49 (arith -> atom .)
    LE              reduce using rule 49 (arith -> atom .)
    GT              reduce using rule 49 (arith -> atom .)
    GE              reduce using rule 49 (arith -> atom .)
    EE              reduce using rule 49 (arith -> atom .)
    NE              reduce using rule 49 (arith -> atom .)
    AND             reduce using rule 49 (arith -> atom .)
    OR              reduce using rule 49 (arith -> atom .)
    BREAK           reduce using rule 49 (arith -> atom .)
    RETURN          reduce using rule 49 (arith -> atom .)
    MACRO           reduce using rule 49 (arith -> atom .)
    IF              reduce using rule 49 (arith -> atom .)
    NOT             reduce using rule 49 (arith -> atom .)
    MIN             reduce using rule 49 (arith -> atom .)
    MAX             reduce using rule 49 (arith -> atom .)
    VARIABLE        reduce using rule 49 (arith -> atom .)
    (               reduce using rule 49 (arith -> atom .)
    NUMBER          reduce using rule 49 (arith -> atom .)
    BOOLEAN         reduce using rule 49 (arith -> atom .)
    STRING          reduce using rule 49 (arith -> atom .)
    WORD            reduce using rule 49 (arith -> atom .)
    FUNCTION        reduce using rule 49 (arith -> atom .)
    %               reduce using rule 49 (arith -> atom .)
    {               reduce using rule 49 (arith -> atom .)
    $end            reduce using rule 49 (arith -> atom .)
    }               reduce using rule 49 (arith -> atom .)
    )               reduce using rule 49 (arith -> atom .)
    ,               reduce using rule 49 (arith -> atom .)
    ]               reduce using rule 49 (arith -> atom .)
    #               reduce using rule 49 (arith -> atom .)

  ! -               [ reduce using rule 49 (arith -> atom .) ]
  ! +               [ reduce using rule 49 (arith -> atom .) ]
  ! *               [ reduce using rule 49 (arith -> atom .) ]
  ! /               [ reduce using rule 49 (arith -> atom .) ]


state 15

    (50) atom -> - . atom
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    atom                           shift and go to state 46
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 16

    (54) arith -> MIN . ( comma_expressions )

    (               shift and go to state 47


state 17

    (55) arith -> MAX . ( comma_expressions )

    (               shift and go to state 48


state 18

    (3) atom -> VARIABLE . = expression
    (4) atom -> VARIABLE .

    =               shift and go to state 49
    +               reduce using rule 4 (atom -> VARIABLE .)
    -               reduce using rule 4 (atom -> VARIABLE .)
    *               reduce using rule 4 (atom -> VARIABLE .)
    /               reduce using rule 4 (atom -> VARIABLE .)
    LT              reduce using rule 4 (atom -> VARIABLE .)
    LE              reduce using rule 4 (atom -> VARIABLE .)
    GT              reduce using rule 4 (atom -> VARIABLE .)
    GE              reduce using rule 4 (atom -> VARIABLE .)
    EE              reduce using rule 4 (atom -> VARIABLE .)
    NE              reduce using rule 4 (atom -> VARIABLE .)
    AND             reduce using rule 4 (atom -> VARIABLE .)
    OR              reduce using rule 4 (atom -> VARIABLE .)
    BREAK           reduce using rule 4 (atom -> VARIABLE .)
    RETURN          reduce using rule 4 (atom -> VARIABLE .)
    MACRO           reduce using rule 4 (atom -> VARIABLE .)
    IF              reduce using rule 4 (atom -> VARIABLE .)
    NOT             reduce using rule 4 (atom -> VARIABLE .)
    MIN             reduce using rule 4 (atom -> VARIABLE .)
    MAX             reduce using rule 4 (atom -> VARIABLE .)
    VARIABLE        reduce using rule 4 (atom -> VARIABLE .)
    (               reduce using rule 4 (atom -> VARIABLE .)
    NUMBER          reduce using rule 4 (atom -> VARIABLE .)
    BOOLEAN         reduce using rule 4 (atom -> VARIABLE .)
    STRING          reduce using rule 4 (atom -> VARIABLE .)
    WORD            reduce using rule 4 (atom -> VARIABLE .)
    FUNCTION        reduce using rule 4 (atom -> VARIABLE .)
    %               reduce using rule 4 (atom -> VARIABLE .)
    {               reduce using rule 4 (atom -> VARIABLE .)
    $end            reduce using rule 4 (atom -> VARIABLE .)
    }               reduce using rule 4 (atom -> VARIABLE .)
    )               reduce using rule 4 (atom -> VARIABLE .)
    ,               reduce using rule 4 (atom -> VARIABLE .)
    ]               reduce using rule 4 (atom -> VARIABLE .)
    #               reduce using rule 4 (atom -> VARIABLE .)


state 19

    (34) atom -> function_call .

    +               reduce using rule 34 (atom -> function_call .)
    -               reduce using rule 34 (atom -> function_call .)
    *               reduce using rule 34 (atom -> function_call .)
    /               reduce using rule 34 (atom -> function_call .)
    LT              reduce using rule 34 (atom -> function_call .)
    LE              reduce using rule 34 (atom -> function_call .)
    GT              reduce using rule 34 (atom -> function_call .)
    GE              reduce using rule 34 (atom -> function_call .)
    EE              reduce using rule 34 (atom -> function_call .)
    NE              reduce using rule 34 (atom -> function_call .)
    AND             reduce using rule 34 (atom -> function_call .)
    OR              reduce using rule 34 (atom -> function_call .)
    BREAK           reduce using rule 34 (atom -> function_call .)
    RETURN          reduce using rule 34 (atom -> function_call .)
    MACRO           reduce using rule 34 (atom -> function_call .)
    IF              reduce using rule 34 (atom -> function_call .)
    NOT             reduce using rule 34 (atom -> function_call .)
    MIN             reduce using rule 34 (atom -> function_call .)
    MAX             reduce using rule 34 (atom -> function_call .)
    VARIABLE        reduce using rule 34 (atom -> function_call .)
    (               reduce using rule 34 (atom -> function_call .)
    NUMBER          reduce using rule 34 (atom -> function_call .)
    BOOLEAN         reduce using rule 34 (atom -> function_call .)
    STRING          reduce using rule 34 (atom -> function_call .)
    WORD            reduce using rule 34 (atom -> function_call .)
    FUNCTION        reduce using rule 34 (atom -> function_call .)
    %               reduce using rule 34 (atom -> function_call .)
    {               reduce using rule 34 (atom -> function_call .)
    $end            reduce using rule 34 (atom -> function_call .)
    }               reduce using rule 34 (atom -> function_call .)
    )               reduce using rule 34 (atom -> function_call .)
    ,               reduce using rule 34 (atom -> function_call .)
    ]               reduce using rule 34 (atom -> function_call .)
    #               reduce using rule 34 (atom -> function_call .)


state 20

    (67) atom -> NUMBER .

    +               reduce using rule 67 (atom -> NUMBER .)
    -               reduce using rule 67 (atom -> NUMBER .)
    *               reduce using rule 67 (atom -> NUMBER .)
    /               reduce using rule 67 (atom -> NUMBER .)
    LT              reduce using rule 67 (atom -> NUMBER .)
    LE              reduce using rule 67 (atom -> NUMBER .)
    GT              reduce using rule 67 (atom -> NUMBER .)
    GE              reduce using rule 67 (atom -> NUMBER .)
    EE              reduce using rule 67 (atom -> NUMBER .)
    NE              reduce using rule 67 (atom -> NUMBER .)
    AND             reduce using rule 67 (atom -> NUMBER .)
    OR              reduce using rule 67 (atom -> NUMBER .)
    BREAK           reduce using rule 67 (atom -> NUMBER .)
    RETURN          reduce using rule 67 (atom -> NUMBER .)
    MACRO           reduce using rule 67 (atom -> NUMBER .)
    IF              reduce using rule 67 (atom -> NUMBER .)
    NOT             reduce using rule 67 (atom -> NUMBER .)
    MIN             reduce using rule 67 (atom -> NUMBER .)
    MAX             reduce using rule 67 (atom -> NUMBER .)
    VARIABLE        reduce using rule 67 (atom -> NUMBER .)
    (               reduce using rule 67 (atom -> NUMBER .)
    NUMBER          reduce using rule 67 (atom -> NUMBER .)
    BOOLEAN         reduce using rule 67 (atom -> NUMBER .)
    STRING          reduce using rule 67 (atom -> NUMBER .)
    WORD            reduce using rule 67 (atom -> NUMBER .)
    FUNCTION        reduce using rule 67 (atom -> NUMBER .)
    %               reduce using rule 67 (atom -> NUMBER .)
    {               reduce using rule 67 (atom -> NUMBER .)
    $end            reduce using rule 67 (atom -> NUMBER .)
    }               reduce using rule 67 (atom -> NUMBER .)
    )               reduce using rule 67 (atom -> NUMBER .)
    ,               reduce using rule 67 (atom -> NUMBER .)
    ]               reduce using rule 67 (atom -> NUMBER .)
    #               reduce using rule 67 (atom -> NUMBER .)


state 21

    (68) atom -> BOOLEAN .

    +               reduce using rule 68 (atom -> BOOLEAN .)
    -               reduce using rule 68 (atom -> BOOLEAN .)
    *               reduce using rule 68 (atom -> BOOLEAN .)
    /               reduce using rule 68 (atom -> BOOLEAN .)
    LT              reduce using rule 68 (atom -> BOOLEAN .)
    LE              reduce using rule 68 (atom -> BOOLEAN .)
    GT              reduce using rule 68 (atom -> BOOLEAN .)
    GE              reduce using rule 68 (atom -> BOOLEAN .)
    EE              reduce using rule 68 (atom -> BOOLEAN .)
    NE              reduce using rule 68 (atom -> BOOLEAN .)
    AND             reduce using rule 68 (atom -> BOOLEAN .)
    OR              reduce using rule 68 (atom -> BOOLEAN .)
    BREAK           reduce using rule 68 (atom -> BOOLEAN .)
    RETURN          reduce using rule 68 (atom -> BOOLEAN .)
    MACRO           reduce using rule 68 (atom -> BOOLEAN .)
    IF              reduce using rule 68 (atom -> BOOLEAN .)
    NOT             reduce using rule 68 (atom -> BOOLEAN .)
    MIN             reduce using rule 68 (atom -> BOOLEAN .)
    MAX             reduce using rule 68 (atom -> BOOLEAN .)
    VARIABLE        reduce using rule 68 (atom -> BOOLEAN .)
    (               reduce using rule 68 (atom -> BOOLEAN .)
    NUMBER          reduce using rule 68 (atom -> BOOLEAN .)
    BOOLEAN         reduce using rule 68 (atom -> BOOLEAN .)
    STRING          reduce using rule 68 (atom -> BOOLEAN .)
    WORD            reduce using rule 68 (atom -> BOOLEAN .)
    FUNCTION        reduce using rule 68 (atom -> BOOLEAN .)
    %               reduce using rule 68 (atom -> BOOLEAN .)
    {               reduce using rule 68 (atom -> BOOLEAN .)
    $end            reduce using rule 68 (atom -> BOOLEAN .)
    }               reduce using rule 68 (atom -> BOOLEAN .)
    )               reduce using rule 68 (atom -> BOOLEAN .)
    ,               reduce using rule 68 (atom -> BOOLEAN .)
    ]               reduce using rule 68 (atom -> BOOLEAN .)
    #               reduce using rule 68 (atom -> BOOLEAN .)


state 22

    (69) atom -> STRING .

    +               reduce using rule 69 (atom -> STRING .)
    -               reduce using rule 69 (atom -> STRING .)
    *               reduce using rule 69 (atom -> STRING .)
    /               reduce using rule 69 (atom -> STRING .)
    LT              reduce using rule 69 (atom -> STRING .)
    LE              reduce using rule 69 (atom -> STRING .)
    GT              reduce using rule 69 (atom -> STRING .)
    GE              reduce using rule 69 (atom -> STRING .)
    EE              reduce using rule 69 (atom -> STRING .)
    NE              reduce using rule 69 (atom -> STRING .)
    AND             reduce using rule 69 (atom -> STRING .)
    OR              reduce using rule 69 (atom -> STRING .)
    BREAK           reduce using rule 69 (atom -> STRING .)
    RETURN          reduce using rule 69 (atom -> STRING .)
    MACRO           reduce using rule 69 (atom -> STRING .)
    IF              reduce using rule 69 (atom -> STRING .)
    NOT             reduce using rule 69 (atom -> STRING .)
    MIN             reduce using rule 69 (atom -> STRING .)
    MAX             reduce using rule 69 (atom -> STRING .)
    VARIABLE        reduce using rule 69 (atom -> STRING .)
    (               reduce using rule 69 (atom -> STRING .)
    NUMBER          reduce using rule 69 (atom -> STRING .)
    BOOLEAN         reduce using rule 69 (atom -> STRING .)
    STRING          reduce using rule 69 (atom -> STRING .)
    WORD            reduce using rule 69 (atom -> STRING .)
    FUNCTION        reduce using rule 69 (atom -> STRING .)
    %               reduce using rule 69 (atom -> STRING .)
    {               reduce using rule 69 (atom -> STRING .)
    $end            reduce using rule 69 (atom -> STRING .)
    }               reduce using rule 69 (atom -> STRING .)
    )               reduce using rule 69 (atom -> STRING .)
    ,               reduce using rule 69 (atom -> STRING .)
    ]               reduce using rule 69 (atom -> STRING .)
    #               reduce using rule 69 (atom -> STRING .)


state 23

    (70) atom -> table .

    +               reduce using rule 70 (atom -> table .)
    -               reduce using rule 70 (atom -> table .)
    *               reduce using rule 70 (atom -> table .)
    /               reduce using rule 70 (atom -> table .)
    LT              reduce using rule 70 (atom -> table .)
    LE              reduce using rule 70 (atom -> table .)
    GT              reduce using rule 70 (atom -> table .)
    GE              reduce using rule 70 (atom -> table .)
    EE              reduce using rule 70 (atom -> table .)
    NE              reduce using rule 70 (atom -> table .)
    AND             reduce using rule 70 (atom -> table .)
    OR              reduce using rule 70 (atom -> table .)
    BREAK           reduce using rule 70 (atom -> table .)
    RETURN          reduce using rule 70 (atom -> table .)
    MACRO           reduce using rule 70 (atom -> table .)
    IF              reduce using rule 70 (atom -> table .)
    NOT             reduce using rule 70 (atom -> table .)
    MIN             reduce using rule 70 (atom -> table .)
    MAX             reduce using rule 70 (atom -> table .)
    VARIABLE        reduce using rule 70 (atom -> table .)
    (               reduce using rule 70 (atom -> table .)
    NUMBER          reduce using rule 70 (atom -> table .)
    BOOLEAN         reduce using rule 70 (atom -> table .)
    STRING          reduce using rule 70 (atom -> table .)
    WORD            reduce using rule 70 (atom -> table .)
    FUNCTION        reduce using rule 70 (atom -> table .)
    %               reduce using rule 70 (atom -> table .)
    {               reduce using rule 70 (atom -> table .)
    $end            reduce using rule 70 (atom -> table .)
    }               reduce using rule 70 (atom -> table .)
    )               reduce using rule 70 (atom -> table .)
    ,               reduce using rule 70 (atom -> table .)
    ]               reduce using rule 70 (atom -> table .)
    #               reduce using rule 70 (atom -> table .)


state 24

    (71) atom -> WORD .

    +               reduce using rule 71 (atom -> WORD .)
    -               reduce using rule 71 (atom -> WORD .)
    *               reduce using rule 71 (atom -> WORD .)
    /               reduce using rule 71 (atom -> WORD .)
    LT              reduce using rule 71 (atom -> WORD .)
    LE              reduce using rule 71 (atom -> WORD .)
    GT              reduce using rule 71 (atom -> WORD .)
    GE              reduce using rule 71 (atom -> WORD .)
    EE              reduce using rule 71 (atom -> WORD .)
    NE              reduce using rule 71 (atom -> WORD .)
    AND             reduce using rule 71 (atom -> WORD .)
    OR              reduce using rule 71 (atom -> WORD .)
    BREAK           reduce using rule 71 (atom -> WORD .)
    RETURN          reduce using rule 71 (atom -> WORD .)
    MACRO           reduce using rule 71 (atom -> WORD .)
    IF              reduce using rule 71 (atom -> WORD .)
    NOT             reduce using rule 71 (atom -> WORD .)
    MIN             reduce using rule 71 (atom -> WORD .)
    MAX             reduce using rule 71 (atom -> WORD .)
    VARIABLE        reduce using rule 71 (atom -> WORD .)
    (               reduce using rule 71 (atom -> WORD .)
    NUMBER          reduce using rule 71 (atom -> WORD .)
    BOOLEAN         reduce using rule 71 (atom -> WORD .)
    STRING          reduce using rule 71 (atom -> WORD .)
    WORD            reduce using rule 71 (atom -> WORD .)
    FUNCTION        reduce using rule 71 (atom -> WORD .)
    %               reduce using rule 71 (atom -> WORD .)
    {               reduce using rule 71 (atom -> WORD .)
    $end            reduce using rule 71 (atom -> WORD .)
    }               reduce using rule 71 (atom -> WORD .)
    )               reduce using rule 71 (atom -> WORD .)
    ,               reduce using rule 71 (atom -> WORD .)
    ]               reduce using rule 71 (atom -> WORD .)
    #               reduce using rule 71 (atom -> WORD .)


state 25

    (12) function_call -> FUNCTION . parameters scope
    (13) function_call -> FUNCTION . parameters tag_list
    (14) function_call -> FUNCTION . parameters
    (15) function_call -> FUNCTION .
    (22) parameters -> . ( param_element )
    (23) parameters -> . ( )

  ! shift/reduce conflict for ( resolved as shift
    +               reduce using rule 15 (function_call -> FUNCTION .)
    -               reduce using rule 15 (function_call -> FUNCTION .)
    *               reduce using rule 15 (function_call -> FUNCTION .)
    /               reduce using rule 15 (function_call -> FUNCTION .)
    LT              reduce using rule 15 (function_call -> FUNCTION .)
    LE              reduce using rule 15 (function_call -> FUNCTION .)
    GT              reduce using rule 15 (function_call -> FUNCTION .)
    GE              reduce using rule 15 (function_call -> FUNCTION .)
    EE              reduce using rule 15 (function_call -> FUNCTION .)
    NE              reduce using rule 15 (function_call -> FUNCTION .)
    AND             reduce using rule 15 (function_call -> FUNCTION .)
    OR              reduce using rule 15 (function_call -> FUNCTION .)
    BREAK           reduce using rule 15 (function_call -> FUNCTION .)
    RETURN          reduce using rule 15 (function_call -> FUNCTION .)
    MACRO           reduce using rule 15 (function_call -> FUNCTION .)
    IF              reduce using rule 15 (function_call -> FUNCTION .)
    NOT             reduce using rule 15 (function_call -> FUNCTION .)
    MIN             reduce using rule 15 (function_call -> FUNCTION .)
    MAX             reduce using rule 15 (function_call -> FUNCTION .)
    VARIABLE        reduce using rule 15 (function_call -> FUNCTION .)
    NUMBER          reduce using rule 15 (function_call -> FUNCTION .)
    BOOLEAN         reduce using rule 15 (function_call -> FUNCTION .)
    STRING          reduce using rule 15 (function_call -> FUNCTION .)
    WORD            reduce using rule 15 (function_call -> FUNCTION .)
    FUNCTION        reduce using rule 15 (function_call -> FUNCTION .)
    %               reduce using rule 15 (function_call -> FUNCTION .)
    {               reduce using rule 15 (function_call -> FUNCTION .)
    $end            reduce using rule 15 (function_call -> FUNCTION .)
    }               reduce using rule 15 (function_call -> FUNCTION .)
    )               reduce using rule 15 (function_call -> FUNCTION .)
    ,               reduce using rule 15 (function_call -> FUNCTION .)
    ]               reduce using rule 15 (function_call -> FUNCTION .)
    #               reduce using rule 15 (function_call -> FUNCTION .)
    (               shift and go to state 51

  ! (               [ reduce using rule 15 (function_call -> FUNCTION .) ]

    parameters                     shift and go to state 50

state 26

    (65) table -> % . [ comma_expressions ]
    (66) table -> % . { table_contents }

    [               shift and go to state 52
    {               shift and go to state 53


state 27

    (19) scope -> { . expressions }
    (20) expressions -> . statement expressions
    (21) expressions -> . statement
    (31) statement -> . BREAK
    (32) statement -> . expression
    (33) statement -> . if_condition
    (57) statement -> . RETURN expression
    (58) statement -> . RETURN
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (9) if_condition -> . IF ( expression ) scope elif_branch
    (10) if_condition -> . IF ( expression ) scope else_branch
    (11) if_condition -> . IF ( expression ) scope
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    BREAK           shift and go to state 3
    RETURN          shift and go to state 6
    MACRO           shift and go to state 7
    IF              shift and go to state 9
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    expressions                    shift and go to state 54
    statement                      shift and go to state 2
    expression                     shift and go to state 4
    if_condition                   shift and go to state 5
    comp                           shift and go to state 8
    scope                          shift and go to state 11
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23

state 28

    (20) expressions -> statement expressions .

    $end            reduce using rule 20 (expressions -> statement expressions .)
    }               reduce using rule 20 (expressions -> statement expressions .)


state 29

    (57) statement -> RETURN expression .

    BREAK           reduce using rule 57 (statement -> RETURN expression .)
    RETURN          reduce using rule 57 (statement -> RETURN expression .)
    MACRO           reduce using rule 57 (statement -> RETURN expression .)
    IF              reduce using rule 57 (statement -> RETURN expression .)
    NOT             reduce using rule 57 (statement -> RETURN expression .)
    MIN             reduce using rule 57 (statement -> RETURN expression .)
    MAX             reduce using rule 57 (statement -> RETURN expression .)
    VARIABLE        reduce using rule 57 (statement -> RETURN expression .)
    -               reduce using rule 57 (statement -> RETURN expression .)
    (               reduce using rule 57 (statement -> RETURN expression .)
    NUMBER          reduce using rule 57 (statement -> RETURN expression .)
    BOOLEAN         reduce using rule 57 (statement -> RETURN expression .)
    STRING          reduce using rule 57 (statement -> RETURN expression .)
    WORD            reduce using rule 57 (statement -> RETURN expression .)
    FUNCTION        reduce using rule 57 (statement -> RETURN expression .)
    %               reduce using rule 57 (statement -> RETURN expression .)
    {               reduce using rule 57 (statement -> RETURN expression .)
    $end            reduce using rule 57 (statement -> RETURN expression .)
    }               reduce using rule 57 (statement -> RETURN expression .)


state 30

    (1) expression -> MACRO = . expression
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    expression                     shift and go to state 55
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 31

    (42) comp -> comp AND . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    comp                           shift and go to state 56
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 32

    (43) comp -> comp OR . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    comp                           shift and go to state 57
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 33

    (9) if_condition -> IF ( . expression ) scope elif_branch
    (10) if_condition -> IF ( . expression ) scope else_branch
    (11) if_condition -> IF ( . expression ) scope
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    expression                     shift and go to state 58
    scope                          shift and go to state 11
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23

state 34

    (56) atom -> ( expression . )

    )               shift and go to state 59


state 35

    (35) comp -> NOT comp .
    (42) comp -> comp . AND comp
    (43) comp -> comp . OR comp

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    BREAK           reduce using rule 35 (comp -> NOT comp .)
    RETURN          reduce using rule 35 (comp -> NOT comp .)
    MACRO           reduce using rule 35 (comp -> NOT comp .)
    IF              reduce using rule 35 (comp -> NOT comp .)
    NOT             reduce using rule 35 (comp -> NOT comp .)
    MIN             reduce using rule 35 (comp -> NOT comp .)
    MAX             reduce using rule 35 (comp -> NOT comp .)
    VARIABLE        reduce using rule 35 (comp -> NOT comp .)
    -               reduce using rule 35 (comp -> NOT comp .)
    (               reduce using rule 35 (comp -> NOT comp .)
    NUMBER          reduce using rule 35 (comp -> NOT comp .)
    BOOLEAN         reduce using rule 35 (comp -> NOT comp .)
    STRING          reduce using rule 35 (comp -> NOT comp .)
    WORD            reduce using rule 35 (comp -> NOT comp .)
    FUNCTION        reduce using rule 35 (comp -> NOT comp .)
    %               reduce using rule 35 (comp -> NOT comp .)
    {               reduce using rule 35 (comp -> NOT comp .)
    $end            reduce using rule 35 (comp -> NOT comp .)
    }               reduce using rule 35 (comp -> NOT comp .)
    )               reduce using rule 35 (comp -> NOT comp .)
    ,               reduce using rule 35 (comp -> NOT comp .)
    +               reduce using rule 35 (comp -> NOT comp .)
    *               reduce using rule 35 (comp -> NOT comp .)
    /               reduce using rule 35 (comp -> NOT comp .)
    LT              reduce using rule 35 (comp -> NOT comp .)
    LE              reduce using rule 35 (comp -> NOT comp .)
    GT              reduce using rule 35 (comp -> NOT comp .)
    GE              reduce using rule 35 (comp -> NOT comp .)
    EE              reduce using rule 35 (comp -> NOT comp .)
    NE              reduce using rule 35 (comp -> NOT comp .)
    ]               reduce using rule 35 (comp -> NOT comp .)
    #               reduce using rule 35 (comp -> NOT comp .)
    AND             shift and go to state 31
    OR              shift and go to state 32

  ! AND             [ reduce using rule 35 (comp -> NOT comp .) ]
  ! OR              [ reduce using rule 35 (comp -> NOT comp .) ]


state 36

    (36) comp -> arith LT . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    arith                          shift and go to state 60
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 37

    (37) comp -> arith LE . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    arith                          shift and go to state 61
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 38

    (38) comp -> arith GT . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    arith                          shift and go to state 62
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 39

    (39) comp -> arith GE . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    arith                          shift and go to state 63
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 40

    (40) comp -> arith EE . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    arith                          shift and go to state 64
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 41

    (41) comp -> arith NE . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    arith                          shift and go to state 65
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 42

    (45) arith -> atom + . atom
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    atom                           shift and go to state 66
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 43

    (46) arith -> atom - . atom
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    atom                           shift and go to state 67
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 44

    (47) arith -> atom * . atom
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    atom                           shift and go to state 68
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 45

    (48) arith -> atom / . atom
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    atom                           shift and go to state 69
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 46

    (50) atom -> - atom .

    +               reduce using rule 50 (atom -> - atom .)
    -               reduce using rule 50 (atom -> - atom .)
    *               reduce using rule 50 (atom -> - atom .)
    /               reduce using rule 50 (atom -> - atom .)
    LT              reduce using rule 50 (atom -> - atom .)
    LE              reduce using rule 50 (atom -> - atom .)
    GT              reduce using rule 50 (atom -> - atom .)
    GE              reduce using rule 50 (atom -> - atom .)
    EE              reduce using rule 50 (atom -> - atom .)
    NE              reduce using rule 50 (atom -> - atom .)
    AND             reduce using rule 50 (atom -> - atom .)
    OR              reduce using rule 50 (atom -> - atom .)
    BREAK           reduce using rule 50 (atom -> - atom .)
    RETURN          reduce using rule 50 (atom -> - atom .)
    MACRO           reduce using rule 50 (atom -> - atom .)
    IF              reduce using rule 50 (atom -> - atom .)
    NOT             reduce using rule 50 (atom -> - atom .)
    MIN             reduce using rule 50 (atom -> - atom .)
    MAX             reduce using rule 50 (atom -> - atom .)
    VARIABLE        reduce using rule 50 (atom -> - atom .)
    (               reduce using rule 50 (atom -> - atom .)
    NUMBER          reduce using rule 50 (atom -> - atom .)
    BOOLEAN         reduce using rule 50 (atom -> - atom .)
    STRING          reduce using rule 50 (atom -> - atom .)
    WORD            reduce using rule 50 (atom -> - atom .)
    FUNCTION        reduce using rule 50 (atom -> - atom .)
    %               reduce using rule 50 (atom -> - atom .)
    {               reduce using rule 50 (atom -> - atom .)
    $end            reduce using rule 50 (atom -> - atom .)
    }               reduce using rule 50 (atom -> - atom .)
    )               reduce using rule 50 (atom -> - atom .)
    ,               reduce using rule 50 (atom -> - atom .)
    ]               reduce using rule 50 (atom -> - atom .)
    #               reduce using rule 50 (atom -> - atom .)


state 47

    (54) arith -> MIN ( . comma_expressions )
    (51) comma_expressions -> . expression , comma_expressions
    (52) comma_expressions -> . expression ,
    (53) comma_expressions -> . expression
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    comma_expressions              shift and go to state 70
    expression                     shift and go to state 71
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 48

    (55) arith -> MAX ( . comma_expressions )
    (51) comma_expressions -> . expression , comma_expressions
    (52) comma_expressions -> . expression ,
    (53) comma_expressions -> . expression
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    comma_expressions              shift and go to state 72
    expression                     shift and go to state 71
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 49

    (3) atom -> VARIABLE = . expression
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    expression                     shift and go to state 73
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 50

    (12) function_call -> FUNCTION parameters . scope
    (13) function_call -> FUNCTION parameters . tag_list
    (14) function_call -> FUNCTION parameters .
    (19) scope -> . { expressions }
    (17) tag_list -> . tag # scope tag_list
    (18) tag_list -> . tag # scope
    (16) tag -> . TAG expression

  ! shift/reduce conflict for { resolved as shift
    +               reduce using rule 14 (function_call -> FUNCTION parameters .)
    -               reduce using rule 14 (function_call -> FUNCTION parameters .)
    *               reduce using rule 14 (function_call -> FUNCTION parameters .)
    /               reduce using rule 14 (function_call -> FUNCTION parameters .)
    LT              reduce using rule 14 (function_call -> FUNCTION parameters .)
    LE              reduce using rule 14 (function_call -> FUNCTION parameters .)
    GT              reduce using rule 14 (function_call -> FUNCTION parameters .)
    GE              reduce using rule 14 (function_call -> FUNCTION parameters .)
    EE              reduce using rule 14 (function_call -> FUNCTION parameters .)
    NE              reduce using rule 14 (function_call -> FUNCTION parameters .)
    AND             reduce using rule 14 (function_call -> FUNCTION parameters .)
    OR              reduce using rule 14 (function_call -> FUNCTION parameters .)
    BREAK           reduce using rule 14 (function_call -> FUNCTION parameters .)
    RETURN          reduce using rule 14 (function_call -> FUNCTION parameters .)
    MACRO           reduce using rule 14 (function_call -> FUNCTION parameters .)
    IF              reduce using rule 14 (function_call -> FUNCTION parameters .)
    NOT             reduce using rule 14 (function_call -> FUNCTION parameters .)
    MIN             reduce using rule 14 (function_call -> FUNCTION parameters .)
    MAX             reduce using rule 14 (function_call -> FUNCTION parameters .)
    VARIABLE        reduce using rule 14 (function_call -> FUNCTION parameters .)
    (               reduce using rule 14 (function_call -> FUNCTION parameters .)
    NUMBER          reduce using rule 14 (function_call -> FUNCTION parameters .)
    BOOLEAN         reduce using rule 14 (function_call -> FUNCTION parameters .)
    STRING          reduce using rule 14 (function_call -> FUNCTION parameters .)
    WORD            reduce using rule 14 (function_call -> FUNCTION parameters .)
    FUNCTION        reduce using rule 14 (function_call -> FUNCTION parameters .)
    %               reduce using rule 14 (function_call -> FUNCTION parameters .)
    $end            reduce using rule 14 (function_call -> FUNCTION parameters .)
    }               reduce using rule 14 (function_call -> FUNCTION parameters .)
    )               reduce using rule 14 (function_call -> FUNCTION parameters .)
    ,               reduce using rule 14 (function_call -> FUNCTION parameters .)
    ]               reduce using rule 14 (function_call -> FUNCTION parameters .)
    #               reduce using rule 14 (function_call -> FUNCTION parameters .)
    {               shift and go to state 27
    TAG             shift and go to state 77

  ! {               [ reduce using rule 14 (function_call -> FUNCTION parameters .) ]

    scope                          shift and go to state 74
    tag_list                       shift and go to state 75
    tag                            shift and go to state 76

state 51

    (22) parameters -> ( . param_element )
    (23) parameters -> ( . )
    (27) param_element -> . expression , param_element
    (28) param_element -> . expression , param_element_pos
    (29) param_element -> . expression ,
    (30) param_element -> . expression
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    )               shift and go to state 79
    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    param_element                  shift and go to state 78
    expression                     shift and go to state 80
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 52

    (65) table -> % [ . comma_expressions ]
    (51) comma_expressions -> . expression , comma_expressions
    (52) comma_expressions -> . expression ,
    (53) comma_expressions -> . expression
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    comma_expressions              shift and go to state 81
    expression                     shift and go to state 71
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 53

    (66) table -> % { . table_contents }
    (59) table_contents -> . STRING : expression , table_contents
    (60) table_contents -> . NUMBER : expression , table_contents
    (61) table_contents -> . STRING : expression ,
    (62) table_contents -> . NUMBER : expression ,
    (63) table_contents -> . STRING : expression
    (64) table_contents -> . NUMBER : expression

    STRING          shift and go to state 83
    NUMBER          shift and go to state 84

    table_contents                 shift and go to state 82

state 54

    (19) scope -> { expressions . }

    }               shift and go to state 85


state 55

    (1) expression -> MACRO = expression .

    BREAK           reduce using rule 1 (expression -> MACRO = expression .)
    RETURN          reduce using rule 1 (expression -> MACRO = expression .)
    MACRO           reduce using rule 1 (expression -> MACRO = expression .)
    IF              reduce using rule 1 (expression -> MACRO = expression .)
    NOT             reduce using rule 1 (expression -> MACRO = expression .)
    MIN             reduce using rule 1 (expression -> MACRO = expression .)
    MAX             reduce using rule 1 (expression -> MACRO = expression .)
    VARIABLE        reduce using rule 1 (expression -> MACRO = expression .)
    -               reduce using rule 1 (expression -> MACRO = expression .)
    (               reduce using rule 1 (expression -> MACRO = expression .)
    NUMBER          reduce using rule 1 (expression -> MACRO = expression .)
    BOOLEAN         reduce using rule 1 (expression -> MACRO = expression .)
    STRING          reduce using rule 1 (expression -> MACRO = expression .)
    WORD            reduce using rule 1 (expression -> MACRO = expression .)
    FUNCTION        reduce using rule 1 (expression -> MACRO = expression .)
    %               reduce using rule 1 (expression -> MACRO = expression .)
    {               reduce using rule 1 (expression -> MACRO = expression .)
    $end            reduce using rule 1 (expression -> MACRO = expression .)
    }               reduce using rule 1 (expression -> MACRO = expression .)
    )               reduce using rule 1 (expression -> MACRO = expression .)
    AND             reduce using rule 1 (expression -> MACRO = expression .)
    OR              reduce using rule 1 (expression -> MACRO = expression .)
    ,               reduce using rule 1 (expression -> MACRO = expression .)
    +               reduce using rule 1 (expression -> MACRO = expression .)
    *               reduce using rule 1 (expression -> MACRO = expression .)
    /               reduce using rule 1 (expression -> MACRO = expression .)
    LT              reduce using rule 1 (expression -> MACRO = expression .)
    LE              reduce using rule 1 (expression -> MACRO = expression .)
    GT              reduce using rule 1 (expression -> MACRO = expression .)
    GE              reduce using rule 1 (expression -> MACRO = expression .)
    EE              reduce using rule 1 (expression -> MACRO = expression .)
    NE              reduce using rule 1 (expression -> MACRO = expression .)
    ]               reduce using rule 1 (expression -> MACRO = expression .)
    #               reduce using rule 1 (expression -> MACRO = expression .)


state 56

    (42) comp -> comp AND comp .
    (42) comp -> comp . AND comp
    (43) comp -> comp . OR comp

    AND             reduce using rule 42 (comp -> comp AND comp .)
    OR              reduce using rule 42 (comp -> comp AND comp .)
    BREAK           reduce using rule 42 (comp -> comp AND comp .)
    RETURN          reduce using rule 42 (comp -> comp AND comp .)
    MACRO           reduce using rule 42 (comp -> comp AND comp .)
    IF              reduce using rule 42 (comp -> comp AND comp .)
    NOT             reduce using rule 42 (comp -> comp AND comp .)
    MIN             reduce using rule 42 (comp -> comp AND comp .)
    MAX             reduce using rule 42 (comp -> comp AND comp .)
    VARIABLE        reduce using rule 42 (comp -> comp AND comp .)
    -               reduce using rule 42 (comp -> comp AND comp .)
    (               reduce using rule 42 (comp -> comp AND comp .)
    NUMBER          reduce using rule 42 (comp -> comp AND comp .)
    BOOLEAN         reduce using rule 42 (comp -> comp AND comp .)
    STRING          reduce using rule 42 (comp -> comp AND comp .)
    WORD            reduce using rule 42 (comp -> comp AND comp .)
    FUNCTION        reduce using rule 42 (comp -> comp AND comp .)
    %               reduce using rule 42 (comp -> comp AND comp .)
    {               reduce using rule 42 (comp -> comp AND comp .)
    $end            reduce using rule 42 (comp -> comp AND comp .)
    }               reduce using rule 42 (comp -> comp AND comp .)
    )               reduce using rule 42 (comp -> comp AND comp .)
    ,               reduce using rule 42 (comp -> comp AND comp .)
    +               reduce using rule 42 (comp -> comp AND comp .)
    *               reduce using rule 42 (comp -> comp AND comp .)
    /               reduce using rule 42 (comp -> comp AND comp .)
    LT              reduce using rule 42 (comp -> comp AND comp .)
    LE              reduce using rule 42 (comp -> comp AND comp .)
    GT              reduce using rule 42 (comp -> comp AND comp .)
    GE              reduce using rule 42 (comp -> comp AND comp .)
    EE              reduce using rule 42 (comp -> comp AND comp .)
    NE              reduce using rule 42 (comp -> comp AND comp .)
    ]               reduce using rule 42 (comp -> comp AND comp .)
    #               reduce using rule 42 (comp -> comp AND comp .)

  ! AND             [ shift and go to state 31 ]
  ! OR              [ shift and go to state 32 ]


state 57

    (43) comp -> comp OR comp .
    (42) comp -> comp . AND comp
    (43) comp -> comp . OR comp

    AND             reduce using rule 43 (comp -> comp OR comp .)
    OR              reduce using rule 43 (comp -> comp OR comp .)
    BREAK           reduce using rule 43 (comp -> comp OR comp .)
    RETURN          reduce using rule 43 (comp -> comp OR comp .)
    MACRO           reduce using rule 43 (comp -> comp OR comp .)
    IF              reduce using rule 43 (comp -> comp OR comp .)
    NOT             reduce using rule 43 (comp -> comp OR comp .)
    MIN             reduce using rule 43 (comp -> comp OR comp .)
    MAX             reduce using rule 43 (comp -> comp OR comp .)
    VARIABLE        reduce using rule 43 (comp -> comp OR comp .)
    -               reduce using rule 43 (comp -> comp OR comp .)
    (               reduce using rule 43 (comp -> comp OR comp .)
    NUMBER          reduce using rule 43 (comp -> comp OR comp .)
    BOOLEAN         reduce using rule 43 (comp -> comp OR comp .)
    STRING          reduce using rule 43 (comp -> comp OR comp .)
    WORD            reduce using rule 43 (comp -> comp OR comp .)
    FUNCTION        reduce using rule 43 (comp -> comp OR comp .)
    %               reduce using rule 43 (comp -> comp OR comp .)
    {               reduce using rule 43 (comp -> comp OR comp .)
    $end            reduce using rule 43 (comp -> comp OR comp .)
    }               reduce using rule 43 (comp -> comp OR comp .)
    )               reduce using rule 43 (comp -> comp OR comp .)
    ,               reduce using rule 43 (comp -> comp OR comp .)
    +               reduce using rule 43 (comp -> comp OR comp .)
    *               reduce using rule 43 (comp -> comp OR comp .)
    /               reduce using rule 43 (comp -> comp OR comp .)
    LT              reduce using rule 43 (comp -> comp OR comp .)
    LE              reduce using rule 43 (comp -> comp OR comp .)
    GT              reduce using rule 43 (comp -> comp OR comp .)
    GE              reduce using rule 43 (comp -> comp OR comp .)
    EE              reduce using rule 43 (comp -> comp OR comp .)
    NE              reduce using rule 43 (comp -> comp OR comp .)
    ]               reduce using rule 43 (comp -> comp OR comp .)
    #               reduce using rule 43 (comp -> comp OR comp .)

  ! AND             [ shift and go to state 31 ]
  ! OR              [ shift and go to state 32 ]


state 58

    (9) if_condition -> IF ( expression . ) scope elif_branch
    (10) if_condition -> IF ( expression . ) scope else_branch
    (11) if_condition -> IF ( expression . ) scope

    )               shift and go to state 86


state 59

    (56) atom -> ( expression ) .

    +               reduce using rule 56 (atom -> ( expression ) .)
    -               reduce using rule 56 (atom -> ( expression ) .)
    *               reduce using rule 56 (atom -> ( expression ) .)
    /               reduce using rule 56 (atom -> ( expression ) .)
    LT              reduce using rule 56 (atom -> ( expression ) .)
    LE              reduce using rule 56 (atom -> ( expression ) .)
    GT              reduce using rule 56 (atom -> ( expression ) .)
    GE              reduce using rule 56 (atom -> ( expression ) .)
    EE              reduce using rule 56 (atom -> ( expression ) .)
    NE              reduce using rule 56 (atom -> ( expression ) .)
    AND             reduce using rule 56 (atom -> ( expression ) .)
    OR              reduce using rule 56 (atom -> ( expression ) .)
    BREAK           reduce using rule 56 (atom -> ( expression ) .)
    RETURN          reduce using rule 56 (atom -> ( expression ) .)
    MACRO           reduce using rule 56 (atom -> ( expression ) .)
    IF              reduce using rule 56 (atom -> ( expression ) .)
    NOT             reduce using rule 56 (atom -> ( expression ) .)
    MIN             reduce using rule 56 (atom -> ( expression ) .)
    MAX             reduce using rule 56 (atom -> ( expression ) .)
    VARIABLE        reduce using rule 56 (atom -> ( expression ) .)
    (               reduce using rule 56 (atom -> ( expression ) .)
    NUMBER          reduce using rule 56 (atom -> ( expression ) .)
    BOOLEAN         reduce using rule 56 (atom -> ( expression ) .)
    STRING          reduce using rule 56 (atom -> ( expression ) .)
    WORD            reduce using rule 56 (atom -> ( expression ) .)
    FUNCTION        reduce using rule 56 (atom -> ( expression ) .)
    %               reduce using rule 56 (atom -> ( expression ) .)
    {               reduce using rule 56 (atom -> ( expression ) .)
    $end            reduce using rule 56 (atom -> ( expression ) .)
    }               reduce using rule 56 (atom -> ( expression ) .)
    )               reduce using rule 56 (atom -> ( expression ) .)
    ,               reduce using rule 56 (atom -> ( expression ) .)
    ]               reduce using rule 56 (atom -> ( expression ) .)
    #               reduce using rule 56 (atom -> ( expression ) .)


state 60

    (36) comp -> arith LT arith .

    AND             reduce using rule 36 (comp -> arith LT arith .)
    OR              reduce using rule 36 (comp -> arith LT arith .)
    BREAK           reduce using rule 36 (comp -> arith LT arith .)
    RETURN          reduce using rule 36 (comp -> arith LT arith .)
    MACRO           reduce using rule 36 (comp -> arith LT arith .)
    IF              reduce using rule 36 (comp -> arith LT arith .)
    NOT             reduce using rule 36 (comp -> arith LT arith .)
    MIN             reduce using rule 36 (comp -> arith LT arith .)
    MAX             reduce using rule 36 (comp -> arith LT arith .)
    VARIABLE        reduce using rule 36 (comp -> arith LT arith .)
    -               reduce using rule 36 (comp -> arith LT arith .)
    (               reduce using rule 36 (comp -> arith LT arith .)
    NUMBER          reduce using rule 36 (comp -> arith LT arith .)
    BOOLEAN         reduce using rule 36 (comp -> arith LT arith .)
    STRING          reduce using rule 36 (comp -> arith LT arith .)
    WORD            reduce using rule 36 (comp -> arith LT arith .)
    FUNCTION        reduce using rule 36 (comp -> arith LT arith .)
    %               reduce using rule 36 (comp -> arith LT arith .)
    {               reduce using rule 36 (comp -> arith LT arith .)
    $end            reduce using rule 36 (comp -> arith LT arith .)
    }               reduce using rule 36 (comp -> arith LT arith .)
    )               reduce using rule 36 (comp -> arith LT arith .)
    ,               reduce using rule 36 (comp -> arith LT arith .)
    +               reduce using rule 36 (comp -> arith LT arith .)
    *               reduce using rule 36 (comp -> arith LT arith .)
    /               reduce using rule 36 (comp -> arith LT arith .)
    LT              reduce using rule 36 (comp -> arith LT arith .)
    LE              reduce using rule 36 (comp -> arith LT arith .)
    GT              reduce using rule 36 (comp -> arith LT arith .)
    GE              reduce using rule 36 (comp -> arith LT arith .)
    EE              reduce using rule 36 (comp -> arith LT arith .)
    NE              reduce using rule 36 (comp -> arith LT arith .)
    ]               reduce using rule 36 (comp -> arith LT arith .)
    #               reduce using rule 36 (comp -> arith LT arith .)


state 61

    (37) comp -> arith LE arith .

    AND             reduce using rule 37 (comp -> arith LE arith .)
    OR              reduce using rule 37 (comp -> arith LE arith .)
    BREAK           reduce using rule 37 (comp -> arith LE arith .)
    RETURN          reduce using rule 37 (comp -> arith LE arith .)
    MACRO           reduce using rule 37 (comp -> arith LE arith .)
    IF              reduce using rule 37 (comp -> arith LE arith .)
    NOT             reduce using rule 37 (comp -> arith LE arith .)
    MIN             reduce using rule 37 (comp -> arith LE arith .)
    MAX             reduce using rule 37 (comp -> arith LE arith .)
    VARIABLE        reduce using rule 37 (comp -> arith LE arith .)
    -               reduce using rule 37 (comp -> arith LE arith .)
    (               reduce using rule 37 (comp -> arith LE arith .)
    NUMBER          reduce using rule 37 (comp -> arith LE arith .)
    BOOLEAN         reduce using rule 37 (comp -> arith LE arith .)
    STRING          reduce using rule 37 (comp -> arith LE arith .)
    WORD            reduce using rule 37 (comp -> arith LE arith .)
    FUNCTION        reduce using rule 37 (comp -> arith LE arith .)
    %               reduce using rule 37 (comp -> arith LE arith .)
    {               reduce using rule 37 (comp -> arith LE arith .)
    $end            reduce using rule 37 (comp -> arith LE arith .)
    }               reduce using rule 37 (comp -> arith LE arith .)
    )               reduce using rule 37 (comp -> arith LE arith .)
    ,               reduce using rule 37 (comp -> arith LE arith .)
    +               reduce using rule 37 (comp -> arith LE arith .)
    *               reduce using rule 37 (comp -> arith LE arith .)
    /               reduce using rule 37 (comp -> arith LE arith .)
    LT              reduce using rule 37 (comp -> arith LE arith .)
    LE              reduce using rule 37 (comp -> arith LE arith .)
    GT              reduce using rule 37 (comp -> arith LE arith .)
    GE              reduce using rule 37 (comp -> arith LE arith .)
    EE              reduce using rule 37 (comp -> arith LE arith .)
    NE              reduce using rule 37 (comp -> arith LE arith .)
    ]               reduce using rule 37 (comp -> arith LE arith .)
    #               reduce using rule 37 (comp -> arith LE arith .)


state 62

    (38) comp -> arith GT arith .

    AND             reduce using rule 38 (comp -> arith GT arith .)
    OR              reduce using rule 38 (comp -> arith GT arith .)
    BREAK           reduce using rule 38 (comp -> arith GT arith .)
    RETURN          reduce using rule 38 (comp -> arith GT arith .)
    MACRO           reduce using rule 38 (comp -> arith GT arith .)
    IF              reduce using rule 38 (comp -> arith GT arith .)
    NOT             reduce using rule 38 (comp -> arith GT arith .)
    MIN             reduce using rule 38 (comp -> arith GT arith .)
    MAX             reduce using rule 38 (comp -> arith GT arith .)
    VARIABLE        reduce using rule 38 (comp -> arith GT arith .)
    -               reduce using rule 38 (comp -> arith GT arith .)
    (               reduce using rule 38 (comp -> arith GT arith .)
    NUMBER          reduce using rule 38 (comp -> arith GT arith .)
    BOOLEAN         reduce using rule 38 (comp -> arith GT arith .)
    STRING          reduce using rule 38 (comp -> arith GT arith .)
    WORD            reduce using rule 38 (comp -> arith GT arith .)
    FUNCTION        reduce using rule 38 (comp -> arith GT arith .)
    %               reduce using rule 38 (comp -> arith GT arith .)
    {               reduce using rule 38 (comp -> arith GT arith .)
    $end            reduce using rule 38 (comp -> arith GT arith .)
    }               reduce using rule 38 (comp -> arith GT arith .)
    )               reduce using rule 38 (comp -> arith GT arith .)
    ,               reduce using rule 38 (comp -> arith GT arith .)
    +               reduce using rule 38 (comp -> arith GT arith .)
    *               reduce using rule 38 (comp -> arith GT arith .)
    /               reduce using rule 38 (comp -> arith GT arith .)
    LT              reduce using rule 38 (comp -> arith GT arith .)
    LE              reduce using rule 38 (comp -> arith GT arith .)
    GT              reduce using rule 38 (comp -> arith GT arith .)
    GE              reduce using rule 38 (comp -> arith GT arith .)
    EE              reduce using rule 38 (comp -> arith GT arith .)
    NE              reduce using rule 38 (comp -> arith GT arith .)
    ]               reduce using rule 38 (comp -> arith GT arith .)
    #               reduce using rule 38 (comp -> arith GT arith .)


state 63

    (39) comp -> arith GE arith .

    AND             reduce using rule 39 (comp -> arith GE arith .)
    OR              reduce using rule 39 (comp -> arith GE arith .)
    BREAK           reduce using rule 39 (comp -> arith GE arith .)
    RETURN          reduce using rule 39 (comp -> arith GE arith .)
    MACRO           reduce using rule 39 (comp -> arith GE arith .)
    IF              reduce using rule 39 (comp -> arith GE arith .)
    NOT             reduce using rule 39 (comp -> arith GE arith .)
    MIN             reduce using rule 39 (comp -> arith GE arith .)
    MAX             reduce using rule 39 (comp -> arith GE arith .)
    VARIABLE        reduce using rule 39 (comp -> arith GE arith .)
    -               reduce using rule 39 (comp -> arith GE arith .)
    (               reduce using rule 39 (comp -> arith GE arith .)
    NUMBER          reduce using rule 39 (comp -> arith GE arith .)
    BOOLEAN         reduce using rule 39 (comp -> arith GE arith .)
    STRING          reduce using rule 39 (comp -> arith GE arith .)
    WORD            reduce using rule 39 (comp -> arith GE arith .)
    FUNCTION        reduce using rule 39 (comp -> arith GE arith .)
    %               reduce using rule 39 (comp -> arith GE arith .)
    {               reduce using rule 39 (comp -> arith GE arith .)
    $end            reduce using rule 39 (comp -> arith GE arith .)
    }               reduce using rule 39 (comp -> arith GE arith .)
    )               reduce using rule 39 (comp -> arith GE arith .)
    ,               reduce using rule 39 (comp -> arith GE arith .)
    +               reduce using rule 39 (comp -> arith GE arith .)
    *               reduce using rule 39 (comp -> arith GE arith .)
    /               reduce using rule 39 (comp -> arith GE arith .)
    LT              reduce using rule 39 (comp -> arith GE arith .)
    LE              reduce using rule 39 (comp -> arith GE arith .)
    GT              reduce using rule 39 (comp -> arith GE arith .)
    GE              reduce using rule 39 (comp -> arith GE arith .)
    EE              reduce using rule 39 (comp -> arith GE arith .)
    NE              reduce using rule 39 (comp -> arith GE arith .)
    ]               reduce using rule 39 (comp -> arith GE arith .)
    #               reduce using rule 39 (comp -> arith GE arith .)


state 64

    (40) comp -> arith EE arith .

    AND             reduce using rule 40 (comp -> arith EE arith .)
    OR              reduce using rule 40 (comp -> arith EE arith .)
    BREAK           reduce using rule 40 (comp -> arith EE arith .)
    RETURN          reduce using rule 40 (comp -> arith EE arith .)
    MACRO           reduce using rule 40 (comp -> arith EE arith .)
    IF              reduce using rule 40 (comp -> arith EE arith .)
    NOT             reduce using rule 40 (comp -> arith EE arith .)
    MIN             reduce using rule 40 (comp -> arith EE arith .)
    MAX             reduce using rule 40 (comp -> arith EE arith .)
    VARIABLE        reduce using rule 40 (comp -> arith EE arith .)
    -               reduce using rule 40 (comp -> arith EE arith .)
    (               reduce using rule 40 (comp -> arith EE arith .)
    NUMBER          reduce using rule 40 (comp -> arith EE arith .)
    BOOLEAN         reduce using rule 40 (comp -> arith EE arith .)
    STRING          reduce using rule 40 (comp -> arith EE arith .)
    WORD            reduce using rule 40 (comp -> arith EE arith .)
    FUNCTION        reduce using rule 40 (comp -> arith EE arith .)
    %               reduce using rule 40 (comp -> arith EE arith .)
    {               reduce using rule 40 (comp -> arith EE arith .)
    $end            reduce using rule 40 (comp -> arith EE arith .)
    }               reduce using rule 40 (comp -> arith EE arith .)
    )               reduce using rule 40 (comp -> arith EE arith .)
    ,               reduce using rule 40 (comp -> arith EE arith .)
    +               reduce using rule 40 (comp -> arith EE arith .)
    *               reduce using rule 40 (comp -> arith EE arith .)
    /               reduce using rule 40 (comp -> arith EE arith .)
    LT              reduce using rule 40 (comp -> arith EE arith .)
    LE              reduce using rule 40 (comp -> arith EE arith .)
    GT              reduce using rule 40 (comp -> arith EE arith .)
    GE              reduce using rule 40 (comp -> arith EE arith .)
    EE              reduce using rule 40 (comp -> arith EE arith .)
    NE              reduce using rule 40 (comp -> arith EE arith .)
    ]               reduce using rule 40 (comp -> arith EE arith .)
    #               reduce using rule 40 (comp -> arith EE arith .)


state 65

    (41) comp -> arith NE arith .

    AND             reduce using rule 41 (comp -> arith NE arith .)
    OR              reduce using rule 41 (comp -> arith NE arith .)
    BREAK           reduce using rule 41 (comp -> arith NE arith .)
    RETURN          reduce using rule 41 (comp -> arith NE arith .)
    MACRO           reduce using rule 41 (comp -> arith NE arith .)
    IF              reduce using rule 41 (comp -> arith NE arith .)
    NOT             reduce using rule 41 (comp -> arith NE arith .)
    MIN             reduce using rule 41 (comp -> arith NE arith .)
    MAX             reduce using rule 41 (comp -> arith NE arith .)
    VARIABLE        reduce using rule 41 (comp -> arith NE arith .)
    -               reduce using rule 41 (comp -> arith NE arith .)
    (               reduce using rule 41 (comp -> arith NE arith .)
    NUMBER          reduce using rule 41 (comp -> arith NE arith .)
    BOOLEAN         reduce using rule 41 (comp -> arith NE arith .)
    STRING          reduce using rule 41 (comp -> arith NE arith .)
    WORD            reduce using rule 41 (comp -> arith NE arith .)
    FUNCTION        reduce using rule 41 (comp -> arith NE arith .)
    %               reduce using rule 41 (comp -> arith NE arith .)
    {               reduce using rule 41 (comp -> arith NE arith .)
    $end            reduce using rule 41 (comp -> arith NE arith .)
    }               reduce using rule 41 (comp -> arith NE arith .)
    )               reduce using rule 41 (comp -> arith NE arith .)
    ,               reduce using rule 41 (comp -> arith NE arith .)
    +               reduce using rule 41 (comp -> arith NE arith .)
    *               reduce using rule 41 (comp -> arith NE arith .)
    /               reduce using rule 41 (comp -> arith NE arith .)
    LT              reduce using rule 41 (comp -> arith NE arith .)
    LE              reduce using rule 41 (comp -> arith NE arith .)
    GT              reduce using rule 41 (comp -> arith NE arith .)
    GE              reduce using rule 41 (comp -> arith NE arith .)
    EE              reduce using rule 41 (comp -> arith NE arith .)
    NE              reduce using rule 41 (comp -> arith NE arith .)
    ]               reduce using rule 41 (comp -> arith NE arith .)
    #               reduce using rule 41 (comp -> arith NE arith .)


state 66

    (45) arith -> atom + atom .

    LT              reduce using rule 45 (arith -> atom + atom .)
    LE              reduce using rule 45 (arith -> atom + atom .)
    GT              reduce using rule 45 (arith -> atom + atom .)
    GE              reduce using rule 45 (arith -> atom + atom .)
    EE              reduce using rule 45 (arith -> atom + atom .)
    NE              reduce using rule 45 (arith -> atom + atom .)
    AND             reduce using rule 45 (arith -> atom + atom .)
    OR              reduce using rule 45 (arith -> atom + atom .)
    BREAK           reduce using rule 45 (arith -> atom + atom .)
    RETURN          reduce using rule 45 (arith -> atom + atom .)
    MACRO           reduce using rule 45 (arith -> atom + atom .)
    IF              reduce using rule 45 (arith -> atom + atom .)
    NOT             reduce using rule 45 (arith -> atom + atom .)
    MIN             reduce using rule 45 (arith -> atom + atom .)
    MAX             reduce using rule 45 (arith -> atom + atom .)
    VARIABLE        reduce using rule 45 (arith -> atom + atom .)
    -               reduce using rule 45 (arith -> atom + atom .)
    (               reduce using rule 45 (arith -> atom + atom .)
    NUMBER          reduce using rule 45 (arith -> atom + atom .)
    BOOLEAN         reduce using rule 45 (arith -> atom + atom .)
    STRING          reduce using rule 45 (arith -> atom + atom .)
    WORD            reduce using rule 45 (arith -> atom + atom .)
    FUNCTION        reduce using rule 45 (arith -> atom + atom .)
    %               reduce using rule 45 (arith -> atom + atom .)
    {               reduce using rule 45 (arith -> atom + atom .)
    $end            reduce using rule 45 (arith -> atom + atom .)
    }               reduce using rule 45 (arith -> atom + atom .)
    )               reduce using rule 45 (arith -> atom + atom .)
    ,               reduce using rule 45 (arith -> atom + atom .)
    +               reduce using rule 45 (arith -> atom + atom .)
    *               reduce using rule 45 (arith -> atom + atom .)
    /               reduce using rule 45 (arith -> atom + atom .)
    ]               reduce using rule 45 (arith -> atom + atom .)
    #               reduce using rule 45 (arith -> atom + atom .)


state 67

    (46) arith -> atom - atom .

    LT              reduce using rule 46 (arith -> atom - atom .)
    LE              reduce using rule 46 (arith -> atom - atom .)
    GT              reduce using rule 46 (arith -> atom - atom .)
    GE              reduce using rule 46 (arith -> atom - atom .)
    EE              reduce using rule 46 (arith -> atom - atom .)
    NE              reduce using rule 46 (arith -> atom - atom .)
    AND             reduce using rule 46 (arith -> atom - atom .)
    OR              reduce using rule 46 (arith -> atom - atom .)
    BREAK           reduce using rule 46 (arith -> atom - atom .)
    RETURN          reduce using rule 46 (arith -> atom - atom .)
    MACRO           reduce using rule 46 (arith -> atom - atom .)
    IF              reduce using rule 46 (arith -> atom - atom .)
    NOT             reduce using rule 46 (arith -> atom - atom .)
    MIN             reduce using rule 46 (arith -> atom - atom .)
    MAX             reduce using rule 46 (arith -> atom - atom .)
    VARIABLE        reduce using rule 46 (arith -> atom - atom .)
    -               reduce using rule 46 (arith -> atom - atom .)
    (               reduce using rule 46 (arith -> atom - atom .)
    NUMBER          reduce using rule 46 (arith -> atom - atom .)
    BOOLEAN         reduce using rule 46 (arith -> atom - atom .)
    STRING          reduce using rule 46 (arith -> atom - atom .)
    WORD            reduce using rule 46 (arith -> atom - atom .)
    FUNCTION        reduce using rule 46 (arith -> atom - atom .)
    %               reduce using rule 46 (arith -> atom - atom .)
    {               reduce using rule 46 (arith -> atom - atom .)
    $end            reduce using rule 46 (arith -> atom - atom .)
    }               reduce using rule 46 (arith -> atom - atom .)
    )               reduce using rule 46 (arith -> atom - atom .)
    ,               reduce using rule 46 (arith -> atom - atom .)
    +               reduce using rule 46 (arith -> atom - atom .)
    *               reduce using rule 46 (arith -> atom - atom .)
    /               reduce using rule 46 (arith -> atom - atom .)
    ]               reduce using rule 46 (arith -> atom - atom .)
    #               reduce using rule 46 (arith -> atom - atom .)


state 68

    (47) arith -> atom * atom .

    LT              reduce using rule 47 (arith -> atom * atom .)
    LE              reduce using rule 47 (arith -> atom * atom .)
    GT              reduce using rule 47 (arith -> atom * atom .)
    GE              reduce using rule 47 (arith -> atom * atom .)
    EE              reduce using rule 47 (arith -> atom * atom .)
    NE              reduce using rule 47 (arith -> atom * atom .)
    AND             reduce using rule 47 (arith -> atom * atom .)
    OR              reduce using rule 47 (arith -> atom * atom .)
    BREAK           reduce using rule 47 (arith -> atom * atom .)
    RETURN          reduce using rule 47 (arith -> atom * atom .)
    MACRO           reduce using rule 47 (arith -> atom * atom .)
    IF              reduce using rule 47 (arith -> atom * atom .)
    NOT             reduce using rule 47 (arith -> atom * atom .)
    MIN             reduce using rule 47 (arith -> atom * atom .)
    MAX             reduce using rule 47 (arith -> atom * atom .)
    VARIABLE        reduce using rule 47 (arith -> atom * atom .)
    -               reduce using rule 47 (arith -> atom * atom .)
    (               reduce using rule 47 (arith -> atom * atom .)
    NUMBER          reduce using rule 47 (arith -> atom * atom .)
    BOOLEAN         reduce using rule 47 (arith -> atom * atom .)
    STRING          reduce using rule 47 (arith -> atom * atom .)
    WORD            reduce using rule 47 (arith -> atom * atom .)
    FUNCTION        reduce using rule 47 (arith -> atom * atom .)
    %               reduce using rule 47 (arith -> atom * atom .)
    {               reduce using rule 47 (arith -> atom * atom .)
    $end            reduce using rule 47 (arith -> atom * atom .)
    }               reduce using rule 47 (arith -> atom * atom .)
    )               reduce using rule 47 (arith -> atom * atom .)
    ,               reduce using rule 47 (arith -> atom * atom .)
    +               reduce using rule 47 (arith -> atom * atom .)
    *               reduce using rule 47 (arith -> atom * atom .)
    /               reduce using rule 47 (arith -> atom * atom .)
    ]               reduce using rule 47 (arith -> atom * atom .)
    #               reduce using rule 47 (arith -> atom * atom .)


state 69

    (48) arith -> atom / atom .

    LT              reduce using rule 48 (arith -> atom / atom .)
    LE              reduce using rule 48 (arith -> atom / atom .)
    GT              reduce using rule 48 (arith -> atom / atom .)
    GE              reduce using rule 48 (arith -> atom / atom .)
    EE              reduce using rule 48 (arith -> atom / atom .)
    NE              reduce using rule 48 (arith -> atom / atom .)
    AND             reduce using rule 48 (arith -> atom / atom .)
    OR              reduce using rule 48 (arith -> atom / atom .)
    BREAK           reduce using rule 48 (arith -> atom / atom .)
    RETURN          reduce using rule 48 (arith -> atom / atom .)
    MACRO           reduce using rule 48 (arith -> atom / atom .)
    IF              reduce using rule 48 (arith -> atom / atom .)
    NOT             reduce using rule 48 (arith -> atom / atom .)
    MIN             reduce using rule 48 (arith -> atom / atom .)
    MAX             reduce using rule 48 (arith -> atom / atom .)
    VARIABLE        reduce using rule 48 (arith -> atom / atom .)
    -               reduce using rule 48 (arith -> atom / atom .)
    (               reduce using rule 48 (arith -> atom / atom .)
    NUMBER          reduce using rule 48 (arith -> atom / atom .)
    BOOLEAN         reduce using rule 48 (arith -> atom / atom .)
    STRING          reduce using rule 48 (arith -> atom / atom .)
    WORD            reduce using rule 48 (arith -> atom / atom .)
    FUNCTION        reduce using rule 48 (arith -> atom / atom .)
    %               reduce using rule 48 (arith -> atom / atom .)
    {               reduce using rule 48 (arith -> atom / atom .)
    $end            reduce using rule 48 (arith -> atom / atom .)
    }               reduce using rule 48 (arith -> atom / atom .)
    )               reduce using rule 48 (arith -> atom / atom .)
    ,               reduce using rule 48 (arith -> atom / atom .)
    +               reduce using rule 48 (arith -> atom / atom .)
    *               reduce using rule 48 (arith -> atom / atom .)
    /               reduce using rule 48 (arith -> atom / atom .)
    ]               reduce using rule 48 (arith -> atom / atom .)
    #               reduce using rule 48 (arith -> atom / atom .)


state 70

    (54) arith -> MIN ( comma_expressions . )

    )               shift and go to state 87


state 71

    (51) comma_expressions -> expression . , comma_expressions
    (52) comma_expressions -> expression . ,
    (53) comma_expressions -> expression .

    ,               shift and go to state 88
    )               reduce using rule 53 (comma_expressions -> expression .)
    ]               reduce using rule 53 (comma_expressions -> expression .)


state 72

    (55) arith -> MAX ( comma_expressions . )

    )               shift and go to state 89


state 73

    (3) atom -> VARIABLE = expression .

    +               reduce using rule 3 (atom -> VARIABLE = expression .)
    -               reduce using rule 3 (atom -> VARIABLE = expression .)
    *               reduce using rule 3 (atom -> VARIABLE = expression .)
    /               reduce using rule 3 (atom -> VARIABLE = expression .)
    LT              reduce using rule 3 (atom -> VARIABLE = expression .)
    LE              reduce using rule 3 (atom -> VARIABLE = expression .)
    GT              reduce using rule 3 (atom -> VARIABLE = expression .)
    GE              reduce using rule 3 (atom -> VARIABLE = expression .)
    EE              reduce using rule 3 (atom -> VARIABLE = expression .)
    NE              reduce using rule 3 (atom -> VARIABLE = expression .)
    AND             reduce using rule 3 (atom -> VARIABLE = expression .)
    OR              reduce using rule 3 (atom -> VARIABLE = expression .)
    BREAK           reduce using rule 3 (atom -> VARIABLE = expression .)
    RETURN          reduce using rule 3 (atom -> VARIABLE = expression .)
    MACRO           reduce using rule 3 (atom -> VARIABLE = expression .)
    IF              reduce using rule 3 (atom -> VARIABLE = expression .)
    NOT             reduce using rule 3 (atom -> VARIABLE = expression .)
    MIN             reduce using rule 3 (atom -> VARIABLE = expression .)
    MAX             reduce using rule 3 (atom -> VARIABLE = expression .)
    VARIABLE        reduce using rule 3 (atom -> VARIABLE = expression .)
    (               reduce using rule 3 (atom -> VARIABLE = expression .)
    NUMBER          reduce using rule 3 (atom -> VARIABLE = expression .)
    BOOLEAN         reduce using rule 3 (atom -> VARIABLE = expression .)
    STRING          reduce using rule 3 (atom -> VARIABLE = expression .)
    WORD            reduce using rule 3 (atom -> VARIABLE = expression .)
    FUNCTION        reduce using rule 3 (atom -> VARIABLE = expression .)
    %               reduce using rule 3 (atom -> VARIABLE = expression .)
    {               reduce using rule 3 (atom -> VARIABLE = expression .)
    $end            reduce using rule 3 (atom -> VARIABLE = expression .)
    }               reduce using rule 3 (atom -> VARIABLE = expression .)
    )               reduce using rule 3 (atom -> VARIABLE = expression .)
    ,               reduce using rule 3 (atom -> VARIABLE = expression .)
    ]               reduce using rule 3 (atom -> VARIABLE = expression .)
    #               reduce using rule 3 (atom -> VARIABLE = expression .)


state 74

    (12) function_call -> FUNCTION parameters scope .

    +               reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    -               reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    *               reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    /               reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    LT              reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    LE              reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    GT              reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    GE              reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    EE              reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    NE              reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    AND             reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    OR              reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    BREAK           reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    RETURN          reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    MACRO           reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    IF              reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    NOT             reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    MIN             reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    MAX             reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    VARIABLE        reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    (               reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    NUMBER          reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    BOOLEAN         reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    STRING          reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    WORD            reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    FUNCTION        reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    %               reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    {               reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    $end            reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    }               reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    )               reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    ,               reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    ]               reduce using rule 12 (function_call -> FUNCTION parameters scope .)
    #               reduce using rule 12 (function_call -> FUNCTION parameters scope .)


state 75

    (13) function_call -> FUNCTION parameters tag_list .

    +               reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    -               reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    *               reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    /               reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    LT              reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    LE              reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    GT              reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    GE              reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    EE              reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    NE              reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    AND             reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    OR              reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    BREAK           reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    RETURN          reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    MACRO           reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    IF              reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    NOT             reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    MIN             reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    MAX             reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    VARIABLE        reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    (               reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    NUMBER          reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    BOOLEAN         reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    STRING          reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    WORD            reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    FUNCTION        reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    %               reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    {               reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    $end            reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    }               reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    )               reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    ,               reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    ]               reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)
    #               reduce using rule 13 (function_call -> FUNCTION parameters tag_list .)


state 76

    (17) tag_list -> tag . # scope tag_list
    (18) tag_list -> tag . # scope

    #               shift and go to state 90


state 77

    (16) tag -> TAG . expression
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    expression                     shift and go to state 91
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 78

    (22) parameters -> ( param_element . )

    )               shift and go to state 92


state 79

    (23) parameters -> ( ) .

    {               reduce using rule 23 (parameters -> ( ) .)
    TAG             reduce using rule 23 (parameters -> ( ) .)
    +               reduce using rule 23 (parameters -> ( ) .)
    -               reduce using rule 23 (parameters -> ( ) .)
    *               reduce using rule 23 (parameters -> ( ) .)
    /               reduce using rule 23 (parameters -> ( ) .)
    LT              reduce using rule 23 (parameters -> ( ) .)
    LE              reduce using rule 23 (parameters -> ( ) .)
    GT              reduce using rule 23 (parameters -> ( ) .)
    GE              reduce using rule 23 (parameters -> ( ) .)
    EE              reduce using rule 23 (parameters -> ( ) .)
    NE              reduce using rule 23 (parameters -> ( ) .)
    AND             reduce using rule 23 (parameters -> ( ) .)
    OR              reduce using rule 23 (parameters -> ( ) .)
    BREAK           reduce using rule 23 (parameters -> ( ) .)
    RETURN          reduce using rule 23 (parameters -> ( ) .)
    MACRO           reduce using rule 23 (parameters -> ( ) .)
    IF              reduce using rule 23 (parameters -> ( ) .)
    NOT             reduce using rule 23 (parameters -> ( ) .)
    MIN             reduce using rule 23 (parameters -> ( ) .)
    MAX             reduce using rule 23 (parameters -> ( ) .)
    VARIABLE        reduce using rule 23 (parameters -> ( ) .)
    (               reduce using rule 23 (parameters -> ( ) .)
    NUMBER          reduce using rule 23 (parameters -> ( ) .)
    BOOLEAN         reduce using rule 23 (parameters -> ( ) .)
    STRING          reduce using rule 23 (parameters -> ( ) .)
    WORD            reduce using rule 23 (parameters -> ( ) .)
    FUNCTION        reduce using rule 23 (parameters -> ( ) .)
    %               reduce using rule 23 (parameters -> ( ) .)
    $end            reduce using rule 23 (parameters -> ( ) .)
    }               reduce using rule 23 (parameters -> ( ) .)
    )               reduce using rule 23 (parameters -> ( ) .)
    ,               reduce using rule 23 (parameters -> ( ) .)
    ]               reduce using rule 23 (parameters -> ( ) .)
    #               reduce using rule 23 (parameters -> ( ) .)


state 80

    (27) param_element -> expression . , param_element
    (28) param_element -> expression . , param_element_pos
    (29) param_element -> expression . ,
    (30) param_element -> expression .

    ,               shift and go to state 93
    )               reduce using rule 30 (param_element -> expression .)


state 81

    (65) table -> % [ comma_expressions . ]

    ]               shift and go to state 94


state 82

    (66) table -> % { table_contents . }

    }               shift and go to state 95


state 83

    (59) table_contents -> STRING . : expression , table_contents
    (61) table_contents -> STRING . : expression ,
    (63) table_contents -> STRING . : expression

    :               shift and go to state 96


state 84

    (60) table_contents -> NUMBER . : expression , table_contents
    (62) table_contents -> NUMBER . : expression ,
    (64) table_contents -> NUMBER . : expression

    :               shift and go to state 97


state 85

    (19) scope -> { expressions } .

    +               reduce using rule 19 (scope -> { expressions } .)
    -               reduce using rule 19 (scope -> { expressions } .)
    *               reduce using rule 19 (scope -> { expressions } .)
    /               reduce using rule 19 (scope -> { expressions } .)
    LT              reduce using rule 19 (scope -> { expressions } .)
    LE              reduce using rule 19 (scope -> { expressions } .)
    GT              reduce using rule 19 (scope -> { expressions } .)
    GE              reduce using rule 19 (scope -> { expressions } .)
    EE              reduce using rule 19 (scope -> { expressions } .)
    NE              reduce using rule 19 (scope -> { expressions } .)
    AND             reduce using rule 19 (scope -> { expressions } .)
    OR              reduce using rule 19 (scope -> { expressions } .)
    BREAK           reduce using rule 19 (scope -> { expressions } .)
    RETURN          reduce using rule 19 (scope -> { expressions } .)
    MACRO           reduce using rule 19 (scope -> { expressions } .)
    IF              reduce using rule 19 (scope -> { expressions } .)
    NOT             reduce using rule 19 (scope -> { expressions } .)
    MIN             reduce using rule 19 (scope -> { expressions } .)
    MAX             reduce using rule 19 (scope -> { expressions } .)
    VARIABLE        reduce using rule 19 (scope -> { expressions } .)
    (               reduce using rule 19 (scope -> { expressions } .)
    NUMBER          reduce using rule 19 (scope -> { expressions } .)
    BOOLEAN         reduce using rule 19 (scope -> { expressions } .)
    STRING          reduce using rule 19 (scope -> { expressions } .)
    WORD            reduce using rule 19 (scope -> { expressions } .)
    FUNCTION        reduce using rule 19 (scope -> { expressions } .)
    %               reduce using rule 19 (scope -> { expressions } .)
    {               reduce using rule 19 (scope -> { expressions } .)
    $end            reduce using rule 19 (scope -> { expressions } .)
    }               reduce using rule 19 (scope -> { expressions } .)
    )               reduce using rule 19 (scope -> { expressions } .)
    ,               reduce using rule 19 (scope -> { expressions } .)
    ]               reduce using rule 19 (scope -> { expressions } .)
    #               reduce using rule 19 (scope -> { expressions } .)
    ELSEIF          reduce using rule 19 (scope -> { expressions } .)
    ELSE            reduce using rule 19 (scope -> { expressions } .)
    TAG             reduce using rule 19 (scope -> { expressions } .)


state 86

    (9) if_condition -> IF ( expression ) . scope elif_branch
    (10) if_condition -> IF ( expression ) . scope else_branch
    (11) if_condition -> IF ( expression ) . scope
    (19) scope -> . { expressions }

    {               shift and go to state 27

    scope                          shift and go to state 98

state 87

    (54) arith -> MIN ( comma_expressions ) .

    LT              reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    LE              reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    GT              reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    GE              reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    EE              reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    NE              reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    AND             reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    OR              reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    BREAK           reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    RETURN          reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    MACRO           reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    IF              reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    NOT             reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    MIN             reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    MAX             reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    VARIABLE        reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    -               reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    (               reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    NUMBER          reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    BOOLEAN         reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    STRING          reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    WORD            reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    FUNCTION        reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    %               reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    {               reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    $end            reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    }               reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    )               reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    ,               reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    +               reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    *               reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    /               reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    ]               reduce using rule 54 (arith -> MIN ( comma_expressions ) .)
    #               reduce using rule 54 (arith -> MIN ( comma_expressions ) .)


state 88

    (51) comma_expressions -> expression , . comma_expressions
    (52) comma_expressions -> expression , .
    (51) comma_expressions -> . expression , comma_expressions
    (52) comma_expressions -> . expression ,
    (53) comma_expressions -> . expression
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    )               reduce using rule 52 (comma_expressions -> expression , .)
    ]               reduce using rule 52 (comma_expressions -> expression , .)
    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    expression                     shift and go to state 71
    comma_expressions              shift and go to state 99
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 89

    (55) arith -> MAX ( comma_expressions ) .

    LT              reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    LE              reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    GT              reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    GE              reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    EE              reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    NE              reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    AND             reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    OR              reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    BREAK           reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    RETURN          reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    MACRO           reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    IF              reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    NOT             reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    MIN             reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    MAX             reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    VARIABLE        reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    -               reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    (               reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    NUMBER          reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    BOOLEAN         reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    STRING          reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    WORD            reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    FUNCTION        reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    %               reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    {               reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    $end            reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    }               reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    )               reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    ,               reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    +               reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    *               reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    /               reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    ]               reduce using rule 55 (arith -> MAX ( comma_expressions ) .)
    #               reduce using rule 55 (arith -> MAX ( comma_expressions ) .)


state 90

    (17) tag_list -> tag # . scope tag_list
    (18) tag_list -> tag # . scope
    (19) scope -> . { expressions }

    {               shift and go to state 27

    scope                          shift and go to state 100

state 91

    (16) tag -> TAG expression .

    #               reduce using rule 16 (tag -> TAG expression .)


state 92

    (22) parameters -> ( param_element ) .

    {               reduce using rule 22 (parameters -> ( param_element ) .)
    TAG             reduce using rule 22 (parameters -> ( param_element ) .)
    +               reduce using rule 22 (parameters -> ( param_element ) .)
    -               reduce using rule 22 (parameters -> ( param_element ) .)
    *               reduce using rule 22 (parameters -> ( param_element ) .)
    /               reduce using rule 22 (parameters -> ( param_element ) .)
    LT              reduce using rule 22 (parameters -> ( param_element ) .)
    LE              reduce using rule 22 (parameters -> ( param_element ) .)
    GT              reduce using rule 22 (parameters -> ( param_element ) .)
    GE              reduce using rule 22 (parameters -> ( param_element ) .)
    EE              reduce using rule 22 (parameters -> ( param_element ) .)
    NE              reduce using rule 22 (parameters -> ( param_element ) .)
    AND             reduce using rule 22 (parameters -> ( param_element ) .)
    OR              reduce using rule 22 (parameters -> ( param_element ) .)
    BREAK           reduce using rule 22 (parameters -> ( param_element ) .)
    RETURN          reduce using rule 22 (parameters -> ( param_element ) .)
    MACRO           reduce using rule 22 (parameters -> ( param_element ) .)
    IF              reduce using rule 22 (parameters -> ( param_element ) .)
    NOT             reduce using rule 22 (parameters -> ( param_element ) .)
    MIN             reduce using rule 22 (parameters -> ( param_element ) .)
    MAX             reduce using rule 22 (parameters -> ( param_element ) .)
    VARIABLE        reduce using rule 22 (parameters -> ( param_element ) .)
    (               reduce using rule 22 (parameters -> ( param_element ) .)
    NUMBER          reduce using rule 22 (parameters -> ( param_element ) .)
    BOOLEAN         reduce using rule 22 (parameters -> ( param_element ) .)
    STRING          reduce using rule 22 (parameters -> ( param_element ) .)
    WORD            reduce using rule 22 (parameters -> ( param_element ) .)
    FUNCTION        reduce using rule 22 (parameters -> ( param_element ) .)
    %               reduce using rule 22 (parameters -> ( param_element ) .)
    $end            reduce using rule 22 (parameters -> ( param_element ) .)
    }               reduce using rule 22 (parameters -> ( param_element ) .)
    )               reduce using rule 22 (parameters -> ( param_element ) .)
    ,               reduce using rule 22 (parameters -> ( param_element ) .)
    ]               reduce using rule 22 (parameters -> ( param_element ) .)
    #               reduce using rule 22 (parameters -> ( param_element ) .)


state 93

    (27) param_element -> expression , . param_element
    (28) param_element -> expression , . param_element_pos
    (29) param_element -> expression , .
    (27) param_element -> . expression , param_element
    (28) param_element -> . expression , param_element_pos
    (29) param_element -> . expression ,
    (30) param_element -> . expression
    (24) param_element_pos -> . WORD = expression , param_element_pos
    (25) param_element_pos -> . WORD = expression ,
    (26) param_element_pos -> . WORD = expression
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    )               reduce using rule 29 (param_element -> expression , .)
    WORD            shift and go to state 103
    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    expression                     shift and go to state 80
    param_element                  shift and go to state 101
    param_element_pos              shift and go to state 102
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 94

    (65) table -> % [ comma_expressions ] .

    +               reduce using rule 65 (table -> % [ comma_expressions ] .)
    -               reduce using rule 65 (table -> % [ comma_expressions ] .)
    *               reduce using rule 65 (table -> % [ comma_expressions ] .)
    /               reduce using rule 65 (table -> % [ comma_expressions ] .)
    LT              reduce using rule 65 (table -> % [ comma_expressions ] .)
    LE              reduce using rule 65 (table -> % [ comma_expressions ] .)
    GT              reduce using rule 65 (table -> % [ comma_expressions ] .)
    GE              reduce using rule 65 (table -> % [ comma_expressions ] .)
    EE              reduce using rule 65 (table -> % [ comma_expressions ] .)
    NE              reduce using rule 65 (table -> % [ comma_expressions ] .)
    AND             reduce using rule 65 (table -> % [ comma_expressions ] .)
    OR              reduce using rule 65 (table -> % [ comma_expressions ] .)
    BREAK           reduce using rule 65 (table -> % [ comma_expressions ] .)
    RETURN          reduce using rule 65 (table -> % [ comma_expressions ] .)
    MACRO           reduce using rule 65 (table -> % [ comma_expressions ] .)
    IF              reduce using rule 65 (table -> % [ comma_expressions ] .)
    NOT             reduce using rule 65 (table -> % [ comma_expressions ] .)
    MIN             reduce using rule 65 (table -> % [ comma_expressions ] .)
    MAX             reduce using rule 65 (table -> % [ comma_expressions ] .)
    VARIABLE        reduce using rule 65 (table -> % [ comma_expressions ] .)
    (               reduce using rule 65 (table -> % [ comma_expressions ] .)
    NUMBER          reduce using rule 65 (table -> % [ comma_expressions ] .)
    BOOLEAN         reduce using rule 65 (table -> % [ comma_expressions ] .)
    STRING          reduce using rule 65 (table -> % [ comma_expressions ] .)
    WORD            reduce using rule 65 (table -> % [ comma_expressions ] .)
    FUNCTION        reduce using rule 65 (table -> % [ comma_expressions ] .)
    %               reduce using rule 65 (table -> % [ comma_expressions ] .)
    {               reduce using rule 65 (table -> % [ comma_expressions ] .)
    $end            reduce using rule 65 (table -> % [ comma_expressions ] .)
    }               reduce using rule 65 (table -> % [ comma_expressions ] .)
    )               reduce using rule 65 (table -> % [ comma_expressions ] .)
    ,               reduce using rule 65 (table -> % [ comma_expressions ] .)
    ]               reduce using rule 65 (table -> % [ comma_expressions ] .)
    #               reduce using rule 65 (table -> % [ comma_expressions ] .)


state 95

    (66) table -> % { table_contents } .

    +               reduce using rule 66 (table -> % { table_contents } .)
    -               reduce using rule 66 (table -> % { table_contents } .)
    *               reduce using rule 66 (table -> % { table_contents } .)
    /               reduce using rule 66 (table -> % { table_contents } .)
    LT              reduce using rule 66 (table -> % { table_contents } .)
    LE              reduce using rule 66 (table -> % { table_contents } .)
    GT              reduce using rule 66 (table -> % { table_contents } .)
    GE              reduce using rule 66 (table -> % { table_contents } .)
    EE              reduce using rule 66 (table -> % { table_contents } .)
    NE              reduce using rule 66 (table -> % { table_contents } .)
    AND             reduce using rule 66 (table -> % { table_contents } .)
    OR              reduce using rule 66 (table -> % { table_contents } .)
    BREAK           reduce using rule 66 (table -> % { table_contents } .)
    RETURN          reduce using rule 66 (table -> % { table_contents } .)
    MACRO           reduce using rule 66 (table -> % { table_contents } .)
    IF              reduce using rule 66 (table -> % { table_contents } .)
    NOT             reduce using rule 66 (table -> % { table_contents } .)
    MIN             reduce using rule 66 (table -> % { table_contents } .)
    MAX             reduce using rule 66 (table -> % { table_contents } .)
    VARIABLE        reduce using rule 66 (table -> % { table_contents } .)
    (               reduce using rule 66 (table -> % { table_contents } .)
    NUMBER          reduce using rule 66 (table -> % { table_contents } .)
    BOOLEAN         reduce using rule 66 (table -> % { table_contents } .)
    STRING          reduce using rule 66 (table -> % { table_contents } .)
    WORD            reduce using rule 66 (table -> % { table_contents } .)
    FUNCTION        reduce using rule 66 (table -> % { table_contents } .)
    %               reduce using rule 66 (table -> % { table_contents } .)
    {               reduce using rule 66 (table -> % { table_contents } .)
    $end            reduce using rule 66 (table -> % { table_contents } .)
    }               reduce using rule 66 (table -> % { table_contents } .)
    )               reduce using rule 66 (table -> % { table_contents } .)
    ,               reduce using rule 66 (table -> % { table_contents } .)
    ]               reduce using rule 66 (table -> % { table_contents } .)
    #               reduce using rule 66 (table -> % { table_contents } .)


state 96

    (59) table_contents -> STRING : . expression , table_contents
    (61) table_contents -> STRING : . expression ,
    (63) table_contents -> STRING : . expression
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    expression                     shift and go to state 104
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 97

    (60) table_contents -> NUMBER : . expression , table_contents
    (62) table_contents -> NUMBER : . expression ,
    (64) table_contents -> NUMBER : . expression
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    expression                     shift and go to state 105
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 98

    (9) if_condition -> IF ( expression ) scope . elif_branch
    (10) if_condition -> IF ( expression ) scope . else_branch
    (11) if_condition -> IF ( expression ) scope .
    (6) elif_branch -> . ELSEIF ( expression ) scope elif_branch
    (7) elif_branch -> . ELSEIF ( expression ) scope else_branch
    (8) elif_branch -> . ELSEIF ( expression ) scope
    (5) else_branch -> . ELSE scope

    BREAK           reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    RETURN          reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    MACRO           reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    IF              reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    NOT             reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    MIN             reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    MAX             reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    VARIABLE        reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    -               reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    (               reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    NUMBER          reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    BOOLEAN         reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    STRING          reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    WORD            reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    FUNCTION        reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    %               reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    {               reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    $end            reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    }               reduce using rule 11 (if_condition -> IF ( expression ) scope .)
    ELSEIF          shift and go to state 108
    ELSE            shift and go to state 109

    elif_branch                    shift and go to state 106
    else_branch                    shift and go to state 107

state 99

    (51) comma_expressions -> expression , comma_expressions .

    )               reduce using rule 51 (comma_expressions -> expression , comma_expressions .)
    ]               reduce using rule 51 (comma_expressions -> expression , comma_expressions .)


state 100

    (17) tag_list -> tag # scope . tag_list
    (18) tag_list -> tag # scope .
    (17) tag_list -> . tag # scope tag_list
    (18) tag_list -> . tag # scope
    (16) tag -> . TAG expression

    +               reduce using rule 18 (tag_list -> tag # scope .)
    -               reduce using rule 18 (tag_list -> tag # scope .)
    *               reduce using rule 18 (tag_list -> tag # scope .)
    /               reduce using rule 18 (tag_list -> tag # scope .)
    LT              reduce using rule 18 (tag_list -> tag # scope .)
    LE              reduce using rule 18 (tag_list -> tag # scope .)
    GT              reduce using rule 18 (tag_list -> tag # scope .)
    GE              reduce using rule 18 (tag_list -> tag # scope .)
    EE              reduce using rule 18 (tag_list -> tag # scope .)
    NE              reduce using rule 18 (tag_list -> tag # scope .)
    AND             reduce using rule 18 (tag_list -> tag # scope .)
    OR              reduce using rule 18 (tag_list -> tag # scope .)
    BREAK           reduce using rule 18 (tag_list -> tag # scope .)
    RETURN          reduce using rule 18 (tag_list -> tag # scope .)
    MACRO           reduce using rule 18 (tag_list -> tag # scope .)
    IF              reduce using rule 18 (tag_list -> tag # scope .)
    NOT             reduce using rule 18 (tag_list -> tag # scope .)
    MIN             reduce using rule 18 (tag_list -> tag # scope .)
    MAX             reduce using rule 18 (tag_list -> tag # scope .)
    VARIABLE        reduce using rule 18 (tag_list -> tag # scope .)
    (               reduce using rule 18 (tag_list -> tag # scope .)
    NUMBER          reduce using rule 18 (tag_list -> tag # scope .)
    BOOLEAN         reduce using rule 18 (tag_list -> tag # scope .)
    STRING          reduce using rule 18 (tag_list -> tag # scope .)
    WORD            reduce using rule 18 (tag_list -> tag # scope .)
    FUNCTION        reduce using rule 18 (tag_list -> tag # scope .)
    %               reduce using rule 18 (tag_list -> tag # scope .)
    {               reduce using rule 18 (tag_list -> tag # scope .)
    $end            reduce using rule 18 (tag_list -> tag # scope .)
    }               reduce using rule 18 (tag_list -> tag # scope .)
    )               reduce using rule 18 (tag_list -> tag # scope .)
    ,               reduce using rule 18 (tag_list -> tag # scope .)
    ]               reduce using rule 18 (tag_list -> tag # scope .)
    #               reduce using rule 18 (tag_list -> tag # scope .)
    TAG             shift and go to state 77

    tag                            shift and go to state 76
    tag_list                       shift and go to state 110

state 101

    (27) param_element -> expression , param_element .

    )               reduce using rule 27 (param_element -> expression , param_element .)


state 102

    (28) param_element -> expression , param_element_pos .

    )               reduce using rule 28 (param_element -> expression , param_element_pos .)


state 103

    (24) param_element_pos -> WORD . = expression , param_element_pos
    (25) param_element_pos -> WORD . = expression ,
    (26) param_element_pos -> WORD . = expression
    (71) atom -> WORD .

    =               shift and go to state 111
    +               reduce using rule 71 (atom -> WORD .)
    -               reduce using rule 71 (atom -> WORD .)
    *               reduce using rule 71 (atom -> WORD .)
    /               reduce using rule 71 (atom -> WORD .)
    LT              reduce using rule 71 (atom -> WORD .)
    LE              reduce using rule 71 (atom -> WORD .)
    GT              reduce using rule 71 (atom -> WORD .)
    GE              reduce using rule 71 (atom -> WORD .)
    EE              reduce using rule 71 (atom -> WORD .)
    NE              reduce using rule 71 (atom -> WORD .)
    AND             reduce using rule 71 (atom -> WORD .)
    OR              reduce using rule 71 (atom -> WORD .)
    ,               reduce using rule 71 (atom -> WORD .)
    )               reduce using rule 71 (atom -> WORD .)


state 104

    (59) table_contents -> STRING : expression . , table_contents
    (61) table_contents -> STRING : expression . ,
    (63) table_contents -> STRING : expression .

    ,               shift and go to state 112
    }               reduce using rule 63 (table_contents -> STRING : expression .)


state 105

    (60) table_contents -> NUMBER : expression . , table_contents
    (62) table_contents -> NUMBER : expression . ,
    (64) table_contents -> NUMBER : expression .

    ,               shift and go to state 113
    }               reduce using rule 64 (table_contents -> NUMBER : expression .)


state 106

    (9) if_condition -> IF ( expression ) scope elif_branch .

    BREAK           reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    RETURN          reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    MACRO           reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    IF              reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    NOT             reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    MIN             reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    MAX             reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    VARIABLE        reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    -               reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    (               reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    NUMBER          reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    BOOLEAN         reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    STRING          reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    WORD            reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    FUNCTION        reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    %               reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    {               reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    $end            reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)
    }               reduce using rule 9 (if_condition -> IF ( expression ) scope elif_branch .)


state 107

    (10) if_condition -> IF ( expression ) scope else_branch .

    BREAK           reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    RETURN          reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    MACRO           reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    IF              reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    NOT             reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    MIN             reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    MAX             reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    VARIABLE        reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    -               reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    (               reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    NUMBER          reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    BOOLEAN         reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    STRING          reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    WORD            reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    FUNCTION        reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    %               reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    {               reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    $end            reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)
    }               reduce using rule 10 (if_condition -> IF ( expression ) scope else_branch .)


state 108

    (6) elif_branch -> ELSEIF . ( expression ) scope elif_branch
    (7) elif_branch -> ELSEIF . ( expression ) scope else_branch
    (8) elif_branch -> ELSEIF . ( expression ) scope

    (               shift and go to state 114


state 109

    (5) else_branch -> ELSE . scope
    (19) scope -> . { expressions }

    {               shift and go to state 27

    scope                          shift and go to state 115

state 110

    (17) tag_list -> tag # scope tag_list .

    +               reduce using rule 17 (tag_list -> tag # scope tag_list .)
    -               reduce using rule 17 (tag_list -> tag # scope tag_list .)
    *               reduce using rule 17 (tag_list -> tag # scope tag_list .)
    /               reduce using rule 17 (tag_list -> tag # scope tag_list .)
    LT              reduce using rule 17 (tag_list -> tag # scope tag_list .)
    LE              reduce using rule 17 (tag_list -> tag # scope tag_list .)
    GT              reduce using rule 17 (tag_list -> tag # scope tag_list .)
    GE              reduce using rule 17 (tag_list -> tag # scope tag_list .)
    EE              reduce using rule 17 (tag_list -> tag # scope tag_list .)
    NE              reduce using rule 17 (tag_list -> tag # scope tag_list .)
    AND             reduce using rule 17 (tag_list -> tag # scope tag_list .)
    OR              reduce using rule 17 (tag_list -> tag # scope tag_list .)
    BREAK           reduce using rule 17 (tag_list -> tag # scope tag_list .)
    RETURN          reduce using rule 17 (tag_list -> tag # scope tag_list .)
    MACRO           reduce using rule 17 (tag_list -> tag # scope tag_list .)
    IF              reduce using rule 17 (tag_list -> tag # scope tag_list .)
    NOT             reduce using rule 17 (tag_list -> tag # scope tag_list .)
    MIN             reduce using rule 17 (tag_list -> tag # scope tag_list .)
    MAX             reduce using rule 17 (tag_list -> tag # scope tag_list .)
    VARIABLE        reduce using rule 17 (tag_list -> tag # scope tag_list .)
    (               reduce using rule 17 (tag_list -> tag # scope tag_list .)
    NUMBER          reduce using rule 17 (tag_list -> tag # scope tag_list .)
    BOOLEAN         reduce using rule 17 (tag_list -> tag # scope tag_list .)
    STRING          reduce using rule 17 (tag_list -> tag # scope tag_list .)
    WORD            reduce using rule 17 (tag_list -> tag # scope tag_list .)
    FUNCTION        reduce using rule 17 (tag_list -> tag # scope tag_list .)
    %               reduce using rule 17 (tag_list -> tag # scope tag_list .)
    {               reduce using rule 17 (tag_list -> tag # scope tag_list .)
    $end            reduce using rule 17 (tag_list -> tag # scope tag_list .)
    }               reduce using rule 17 (tag_list -> tag # scope tag_list .)
    )               reduce using rule 17 (tag_list -> tag # scope tag_list .)
    ,               reduce using rule 17 (tag_list -> tag # scope tag_list .)
    ]               reduce using rule 17 (tag_list -> tag # scope tag_list .)
    #               reduce using rule 17 (tag_list -> tag # scope tag_list .)


state 111

    (24) param_element_pos -> WORD = . expression , param_element_pos
    (25) param_element_pos -> WORD = . expression ,
    (26) param_element_pos -> WORD = . expression
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    expression                     shift and go to state 116
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23
    scope                          shift and go to state 11

state 112

    (59) table_contents -> STRING : expression , . table_contents
    (61) table_contents -> STRING : expression , .
    (59) table_contents -> . STRING : expression , table_contents
    (60) table_contents -> . NUMBER : expression , table_contents
    (61) table_contents -> . STRING : expression ,
    (62) table_contents -> . NUMBER : expression ,
    (63) table_contents -> . STRING : expression
    (64) table_contents -> . NUMBER : expression

    }               reduce using rule 61 (table_contents -> STRING : expression , .)
    STRING          shift and go to state 83
    NUMBER          shift and go to state 84

    table_contents                 shift and go to state 117

state 113

    (60) table_contents -> NUMBER : expression , . table_contents
    (62) table_contents -> NUMBER : expression , .
    (59) table_contents -> . STRING : expression , table_contents
    (60) table_contents -> . NUMBER : expression , table_contents
    (61) table_contents -> . STRING : expression ,
    (62) table_contents -> . NUMBER : expression ,
    (63) table_contents -> . STRING : expression
    (64) table_contents -> . NUMBER : expression

    }               reduce using rule 62 (table_contents -> NUMBER : expression , .)
    STRING          shift and go to state 83
    NUMBER          shift and go to state 84

    table_contents                 shift and go to state 118

state 114

    (6) elif_branch -> ELSEIF ( . expression ) scope elif_branch
    (7) elif_branch -> ELSEIF ( . expression ) scope else_branch
    (8) elif_branch -> ELSEIF ( . expression ) scope
    (1) expression -> . MACRO = expression
    (2) expression -> . MACRO
    (73) expression -> . comp
    (35) comp -> . NOT comp
    (36) comp -> . arith LT arith
    (37) comp -> . arith LE arith
    (38) comp -> . arith GT arith
    (39) comp -> . arith GE arith
    (40) comp -> . arith EE arith
    (41) comp -> . arith NE arith
    (42) comp -> . comp AND comp
    (43) comp -> . comp OR comp
    (44) comp -> . arith
    (45) arith -> . atom + atom
    (46) arith -> . atom - atom
    (47) arith -> . atom * atom
    (48) arith -> . atom / atom
    (49) arith -> . atom
    (54) arith -> . MIN ( comma_expressions )
    (55) arith -> . MAX ( comma_expressions )
    (3) atom -> . VARIABLE = expression
    (4) atom -> . VARIABLE
    (34) atom -> . function_call
    (50) atom -> . - atom
    (56) atom -> . ( expression )
    (67) atom -> . NUMBER
    (68) atom -> . BOOLEAN
    (69) atom -> . STRING
    (70) atom -> . table
    (71) atom -> . WORD
    (72) atom -> . scope
    (12) function_call -> . FUNCTION parameters scope
    (13) function_call -> . FUNCTION parameters tag_list
    (14) function_call -> . FUNCTION parameters
    (15) function_call -> . FUNCTION
    (65) table -> . % [ comma_expressions ]
    (66) table -> . % { table_contents }
    (19) scope -> . { expressions }

    MACRO           shift and go to state 7
    NOT             shift and go to state 12
    MIN             shift and go to state 16
    MAX             shift and go to state 17
    VARIABLE        shift and go to state 18
    -               shift and go to state 15
    (               shift and go to state 10
    NUMBER          shift and go to state 20
    BOOLEAN         shift and go to state 21
    STRING          shift and go to state 22
    WORD            shift and go to state 24
    FUNCTION        shift and go to state 25
    %               shift and go to state 26
    {               shift and go to state 27

    expression                     shift and go to state 119
    scope                          shift and go to state 11
    comp                           shift and go to state 8
    arith                          shift and go to state 13
    atom                           shift and go to state 14
    function_call                  shift and go to state 19
    table                          shift and go to state 23

state 115

    (5) else_branch -> ELSE scope .

    BREAK           reduce using rule 5 (else_branch -> ELSE scope .)
    RETURN          reduce using rule 5 (else_branch -> ELSE scope .)
    MACRO           reduce using rule 5 (else_branch -> ELSE scope .)
    IF              reduce using rule 5 (else_branch -> ELSE scope .)
    NOT             reduce using rule 5 (else_branch -> ELSE scope .)
    MIN             reduce using rule 5 (else_branch -> ELSE scope .)
    MAX             reduce using rule 5 (else_branch -> ELSE scope .)
    VARIABLE        reduce using rule 5 (else_branch -> ELSE scope .)
    -               reduce using rule 5 (else_branch -> ELSE scope .)
    (               reduce using rule 5 (else_branch -> ELSE scope .)
    NUMBER          reduce using rule 5 (else_branch -> ELSE scope .)
    BOOLEAN         reduce using rule 5 (else_branch -> ELSE scope .)
    STRING          reduce using rule 5 (else_branch -> ELSE scope .)
    WORD            reduce using rule 5 (else_branch -> ELSE scope .)
    FUNCTION        reduce using rule 5 (else_branch -> ELSE scope .)
    %               reduce using rule 5 (else_branch -> ELSE scope .)
    {               reduce using rule 5 (else_branch -> ELSE scope .)
    $end            reduce using rule 5 (else_branch -> ELSE scope .)
    }               reduce using rule 5 (else_branch -> ELSE scope .)


state 116

    (24) param_element_pos -> WORD = expression . , param_element_pos
    (25) param_element_pos -> WORD = expression . ,
    (26) param_element_pos -> WORD = expression .

    ,               shift and go to state 120
    )               reduce using rule 26 (param_element_pos -> WORD = expression .)


state 117

    (59) table_contents -> STRING : expression , table_contents .

    }               reduce using rule 59 (table_contents -> STRING : expression , table_contents .)


state 118

    (60) table_contents -> NUMBER : expression , table_contents .

    }               reduce using rule 60 (table_contents -> NUMBER : expression , table_contents .)


state 119

    (6) elif_branch -> ELSEIF ( expression . ) scope elif_branch
    (7) elif_branch -> ELSEIF ( expression . ) scope else_branch
    (8) elif_branch -> ELSEIF ( expression . ) scope

    )               shift and go to state 121


state 120

    (24) param_element_pos -> WORD = expression , . param_element_pos
    (25) param_element_pos -> WORD = expression , .
    (24) param_element_pos -> . WORD = expression , param_element_pos
    (25) param_element_pos -> . WORD = expression ,
    (26) param_element_pos -> . WORD = expression

    )               reduce using rule 25 (param_element_pos -> WORD = expression , .)
    WORD            shift and go to state 122

    param_element_pos              shift and go to state 123

state 121

    (6) elif_branch -> ELSEIF ( expression ) . scope elif_branch
    (7) elif_branch -> ELSEIF ( expression ) . scope else_branch
    (8) elif_branch -> ELSEIF ( expression ) . scope
    (19) scope -> . { expressions }

    {               shift and go to state 27

    scope                          shift and go to state 124

state 122

    (24) param_element_pos -> WORD . = expression , param_element_pos
    (25) param_element_pos -> WORD . = expression ,
    (26) param_element_pos -> WORD . = expression

    =               shift and go to state 111


state 123

    (24) param_element_pos -> WORD = expression , param_element_pos .

    )               reduce using rule 24 (param_element_pos -> WORD = expression , param_element_pos .)


state 124

    (6) elif_branch -> ELSEIF ( expression ) scope . elif_branch
    (7) elif_branch -> ELSEIF ( expression ) scope . else_branch
    (8) elif_branch -> ELSEIF ( expression ) scope .
    (6) elif_branch -> . ELSEIF ( expression ) scope elif_branch
    (7) elif_branch -> . ELSEIF ( expression ) scope else_branch
    (8) elif_branch -> . ELSEIF ( expression ) scope
    (5) else_branch -> . ELSE scope

    BREAK           reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    RETURN          reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    MACRO           reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    IF              reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    NOT             reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    MIN             reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    MAX             reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    VARIABLE        reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    -               reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    (               reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    NUMBER          reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    BOOLEAN         reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    STRING          reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    WORD            reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    FUNCTION        reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    %               reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    {               reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    $end            reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    }               reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope .)
    ELSEIF          shift and go to state 108
    ELSE            shift and go to state 109

    elif_branch                    shift and go to state 125
    else_branch                    shift and go to state 126

state 125

    (6) elif_branch -> ELSEIF ( expression ) scope elif_branch .

    BREAK           reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    RETURN          reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    MACRO           reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    IF              reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    NOT             reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    MIN             reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    MAX             reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    VARIABLE        reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    -               reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    (               reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    NUMBER          reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    BOOLEAN         reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    STRING          reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    WORD            reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    FUNCTION        reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    %               reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    {               reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    $end            reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    }               reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)


state 126

    (7) elif_branch -> ELSEIF ( expression ) scope else_branch .

    BREAK           reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    RETURN          reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    MACRO           reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    IF              reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    NOT             reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    MIN             reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    MAX             reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    VARIABLE        reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    -               reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    (               reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    NUMBER          reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    BOOLEAN         reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    STRING          reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    WORD            reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    FUNCTION        reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    %               reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    {               reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    $end            reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    }               reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope else_branch .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MACRO in state 6 resolved as shift
WARNING: shift/reduce conflict for NOT in state 6 resolved as shift
WARNING: shift/reduce conflict for MIN in state 6 resolved as shift
WARNING: shift/reduce conflict for MAX in state 6 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 6 resolved as shift
WARNING: shift/reduce conflict for - in state 6 resolved as shift
WARNING: shift/reduce conflict for ( in state 6 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 6 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 6 resolved as shift
WARNING: shift/reduce conflict for STRING in state 6 resolved as shift
WARNING: shift/reduce conflict for WORD in state 6 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 6 resolved as shift
WARNING: shift/reduce conflict for % in state 6 resolved as shift
WARNING: shift/reduce conflict for { in state 6 resolved as shift
WARNING: shift/reduce conflict for AND in state 8 resolved as shift
WARNING: shift/reduce conflict for OR in state 8 resolved as shift
WARNING: shift/reduce conflict for LT in state 13 resolved as shift
WARNING: shift/reduce conflict for LE in state 13 resolved as shift
WARNING: shift/reduce conflict for GT in state 13 resolved as shift
WARNING: shift/reduce conflict for GE in state 13 resolved as shift
WARNING: shift/reduce conflict for EE in state 13 resolved as shift
WARNING: shift/reduce conflict for NE in state 13 resolved as shift
WARNING: shift/reduce conflict for - in state 14 resolved as shift
WARNING: shift/reduce conflict for + in state 14 resolved as shift
WARNING: shift/reduce conflict for * in state 14 resolved as shift
WARNING: shift/reduce conflict for / in state 14 resolved as shift
WARNING: shift/reduce conflict for ( in state 25 resolved as shift
WARNING: shift/reduce conflict for AND in state 35 resolved as shift
WARNING: shift/reduce conflict for OR in state 35 resolved as shift
WARNING: shift/reduce conflict for { in state 50 resolved as shift
