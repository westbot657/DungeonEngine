Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CONTINUE

Grammar

Rule 0     S' -> expressions
Rule 1     expression -> PASS
Rule 2     expression -> MACRO = expression
Rule 3     expression -> MACRO
Rule 4     atom -> VARIABLE = expression
Rule 5     atom -> VARIABLE
Rule 6     else_branch -> ELSE scope
Rule 7     elif_branch -> ELSEIF ( expression ) scope elif_branch
Rule 8     elif_branch -> ELSEIF ( expression ) scope else_branch
Rule 9     elif_branch -> ELSEIF ( expression ) scope
Rule 10    if_condition -> IF ( expression ) scope elif_branch
Rule 11    if_condition -> IF ( expression ) scope else_branch
Rule 12    if_condition -> IF ( expression ) scope
Rule 13    function_call -> FUNCTION parameters scope
Rule 14    function_call -> FUNCTION parameters tag_list
Rule 15    function_call -> FUNCTION parameters
Rule 16    function_call -> FUNCTION
Rule 17    tag -> TAG expression
Rule 18    tag_list -> tag # scope tag_list
Rule 19    tag_list -> tag # scope
Rule 20    scope -> { expressions }
Rule 21    expressions -> statement expressions
Rule 22    expressions -> statement
Rule 23    parameters -> ( param_element )
Rule 24    parameters -> ( )
Rule 25    param_element_pos -> WORD = expression , param_element_pos
Rule 26    param_element_pos -> WORD = expression ,
Rule 27    param_element_pos -> WORD = expression
Rule 28    param_element -> expression , param_element
Rule 29    param_element -> expression , param_element_pos
Rule 30    param_element -> expression ,
Rule 31    param_element -> expression
Rule 32    statement -> BREAK
Rule 33    statement -> expression
Rule 34    statement -> if_condition
Rule 35    atom -> function_call
Rule 36    comp -> NOT comp
Rule 37    comp -> arith LT arith
Rule 38    comp -> arith LE arith
Rule 39    comp -> arith GT arith
Rule 40    comp -> arith GE arith
Rule 41    comp -> arith EE arith
Rule 42    comp -> arith NE arith
Rule 43    comp -> comp AND comp
Rule 44    comp -> comp OR comp
Rule 45    comp -> arith
Rule 46    arith -> atom + atom
Rule 47    arith -> atom - atom
Rule 48    arith -> atom * atom
Rule 49    arith -> atom / atom
Rule 50    arith -> atom
Rule 51    atom -> - atom
Rule 52    comma_expressions -> expression , comma_expressions
Rule 53    comma_expressions -> expression ,
Rule 54    comma_expressions -> expression
Rule 55    arith -> MIN ( comma_expressions )
Rule 56    arith -> MAX ( comma_expressions )
Rule 57    atom -> ( expression )
Rule 58    statement -> RETURN expression
Rule 59    statement -> RETURN
Rule 60    table_contents -> STRING : expression , table_contents
Rule 61    table_contents -> NUMBER : expression , table_contents
Rule 62    table_contents -> STRING : expression ,
Rule 63    table_contents -> NUMBER : expression ,
Rule 64    table_contents -> STRING : expression
Rule 65    table_contents -> NUMBER : expression
Rule 66    table -> % [ comma_expressions ]
Rule 67    table -> % { table_contents }
Rule 68    atom -> NUMBER
Rule 69    atom -> BOOLEAN
Rule 70    atom -> STRING
Rule 71    atom -> table
Rule 72    atom -> WORD
Rule 73    atom -> scope
Rule 74    expression -> comp

Terminals, with rules where they appear

#                    : 18 19
%                    : 66 67
(                    : 7 8 9 10 11 12 23 24 55 56 57
)                    : 7 8 9 10 11 12 23 24 55 56 57
*                    : 48
+                    : 46
,                    : 25 26 28 29 30 52 53 60 61 62 63
-                    : 47 51
/                    : 49
:                    : 60 61 62 63 64 65
=                    : 2 4 25 26 27
AND                  : 43
BOOLEAN              : 69
BREAK                : 32
CONTINUE             : 
EE                   : 41
ELSE                 : 6
ELSEIF               : 7 8 9
FUNCTION             : 13 14 15 16
GE                   : 40
GT                   : 39
IF                   : 10 11 12
LE                   : 38
LT                   : 37
MACRO                : 2 3
MAX                  : 56
MIN                  : 55
NE                   : 42
NOT                  : 36
NUMBER               : 61 63 65 68
OR                   : 44
PASS                 : 1
RETURN               : 58 59
STRING               : 60 62 64 70
TAG                  : 17
VARIABLE             : 4 5
WORD                 : 25 26 27 72
[                    : 66
]                    : 66
error                : 
{                    : 20 67
}                    : 20 67

Nonterminals, with rules where they appear

arith                : 37 37 38 38 39 39 40 40 41 41 42 42 45
atom                 : 46 46 47 47 48 48 49 49 50 51
comma_expressions    : 52 55 56 66
comp                 : 36 43 43 44 44 74
elif_branch          : 7 10
else_branch          : 8 11
expression           : 2 4 7 8 9 10 11 12 17 25 26 27 28 29 30 31 33 52 53 54 57 58 60 61 62 63 64 65
expressions          : 20 21 0
function_call        : 35
if_condition         : 34
param_element        : 23 28
param_element_pos    : 25 29
parameters           : 13 14 15
scope                : 6 7 8 9 10 11 12 13 18 19 73
statement            : 21 22
table                : 71
table_contents       : 60 61 67
tag                  : 18 19
tag_list             : 14 18

Parsing method: LALR

state 0

    (0) S' -> . expressions
    (21) expressions -> . statement expressions
    (22) expressions -> . statement
    (32) statement -> . BREAK
    (33) statement -> . expression
    (34) statement -> . if_condition
    (58) statement -> . RETURN expression
    (59) statement -> . RETURN
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (10) if_condition -> . IF ( expression ) scope elif_branch
    (11) if_condition -> . IF ( expression ) scope else_branch
    (12) if_condition -> . IF ( expression ) scope
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    BREAK           shift and go to state 3
    RETURN          shift and go to state 6
    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    IF              shift and go to state 10
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    expressions                    shift and go to state 1
    statement                      shift and go to state 2
    expression                     shift and go to state 4
    if_condition                   shift and go to state 5
    comp                           shift and go to state 9
    scope                          shift and go to state 12
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24

state 1

    (0) S' -> expressions .



state 2

    (21) expressions -> statement . expressions
    (22) expressions -> statement .
    (21) expressions -> . statement expressions
    (22) expressions -> . statement
    (32) statement -> . BREAK
    (33) statement -> . expression
    (34) statement -> . if_condition
    (58) statement -> . RETURN expression
    (59) statement -> . RETURN
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (10) if_condition -> . IF ( expression ) scope elif_branch
    (11) if_condition -> . IF ( expression ) scope else_branch
    (12) if_condition -> . IF ( expression ) scope
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    $end            reduce using rule 22 (expressions -> statement .)
    }               reduce using rule 22 (expressions -> statement .)
    BREAK           shift and go to state 3
    RETURN          shift and go to state 6
    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    IF              shift and go to state 10
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    statement                      shift and go to state 2
    expressions                    shift and go to state 29
    expression                     shift and go to state 4
    if_condition                   shift and go to state 5
    comp                           shift and go to state 9
    scope                          shift and go to state 12
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24

state 3

    (32) statement -> BREAK .

    BREAK           reduce using rule 32 (statement -> BREAK .)
    RETURN          reduce using rule 32 (statement -> BREAK .)
    PASS            reduce using rule 32 (statement -> BREAK .)
    MACRO           reduce using rule 32 (statement -> BREAK .)
    IF              reduce using rule 32 (statement -> BREAK .)
    NOT             reduce using rule 32 (statement -> BREAK .)
    MIN             reduce using rule 32 (statement -> BREAK .)
    MAX             reduce using rule 32 (statement -> BREAK .)
    VARIABLE        reduce using rule 32 (statement -> BREAK .)
    -               reduce using rule 32 (statement -> BREAK .)
    (               reduce using rule 32 (statement -> BREAK .)
    NUMBER          reduce using rule 32 (statement -> BREAK .)
    BOOLEAN         reduce using rule 32 (statement -> BREAK .)
    STRING          reduce using rule 32 (statement -> BREAK .)
    WORD            reduce using rule 32 (statement -> BREAK .)
    FUNCTION        reduce using rule 32 (statement -> BREAK .)
    %               reduce using rule 32 (statement -> BREAK .)
    {               reduce using rule 32 (statement -> BREAK .)
    $end            reduce using rule 32 (statement -> BREAK .)
    }               reduce using rule 32 (statement -> BREAK .)


state 4

    (33) statement -> expression .

    BREAK           reduce using rule 33 (statement -> expression .)
    RETURN          reduce using rule 33 (statement -> expression .)
    PASS            reduce using rule 33 (statement -> expression .)
    MACRO           reduce using rule 33 (statement -> expression .)
    IF              reduce using rule 33 (statement -> expression .)
    NOT             reduce using rule 33 (statement -> expression .)
    MIN             reduce using rule 33 (statement -> expression .)
    MAX             reduce using rule 33 (statement -> expression .)
    VARIABLE        reduce using rule 33 (statement -> expression .)
    -               reduce using rule 33 (statement -> expression .)
    (               reduce using rule 33 (statement -> expression .)
    NUMBER          reduce using rule 33 (statement -> expression .)
    BOOLEAN         reduce using rule 33 (statement -> expression .)
    STRING          reduce using rule 33 (statement -> expression .)
    WORD            reduce using rule 33 (statement -> expression .)
    FUNCTION        reduce using rule 33 (statement -> expression .)
    %               reduce using rule 33 (statement -> expression .)
    {               reduce using rule 33 (statement -> expression .)
    $end            reduce using rule 33 (statement -> expression .)
    }               reduce using rule 33 (statement -> expression .)


state 5

    (34) statement -> if_condition .

    BREAK           reduce using rule 34 (statement -> if_condition .)
    RETURN          reduce using rule 34 (statement -> if_condition .)
    PASS            reduce using rule 34 (statement -> if_condition .)
    MACRO           reduce using rule 34 (statement -> if_condition .)
    IF              reduce using rule 34 (statement -> if_condition .)
    NOT             reduce using rule 34 (statement -> if_condition .)
    MIN             reduce using rule 34 (statement -> if_condition .)
    MAX             reduce using rule 34 (statement -> if_condition .)
    VARIABLE        reduce using rule 34 (statement -> if_condition .)
    -               reduce using rule 34 (statement -> if_condition .)
    (               reduce using rule 34 (statement -> if_condition .)
    NUMBER          reduce using rule 34 (statement -> if_condition .)
    BOOLEAN         reduce using rule 34 (statement -> if_condition .)
    STRING          reduce using rule 34 (statement -> if_condition .)
    WORD            reduce using rule 34 (statement -> if_condition .)
    FUNCTION        reduce using rule 34 (statement -> if_condition .)
    %               reduce using rule 34 (statement -> if_condition .)
    {               reduce using rule 34 (statement -> if_condition .)
    $end            reduce using rule 34 (statement -> if_condition .)
    }               reduce using rule 34 (statement -> if_condition .)


state 6

    (58) statement -> RETURN . expression
    (59) statement -> RETURN .
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

  ! shift/reduce conflict for PASS resolved as shift
  ! shift/reduce conflict for MACRO resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MIN resolved as shift
  ! shift/reduce conflict for MAX resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for WORD resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for { resolved as shift
    BREAK           reduce using rule 59 (statement -> RETURN .)
    RETURN          reduce using rule 59 (statement -> RETURN .)
    IF              reduce using rule 59 (statement -> RETURN .)
    $end            reduce using rule 59 (statement -> RETURN .)
    }               reduce using rule 59 (statement -> RETURN .)
    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

  ! PASS            [ reduce using rule 59 (statement -> RETURN .) ]
  ! MACRO           [ reduce using rule 59 (statement -> RETURN .) ]
  ! NOT             [ reduce using rule 59 (statement -> RETURN .) ]
  ! MIN             [ reduce using rule 59 (statement -> RETURN .) ]
  ! MAX             [ reduce using rule 59 (statement -> RETURN .) ]
  ! VARIABLE        [ reduce using rule 59 (statement -> RETURN .) ]
  ! -               [ reduce using rule 59 (statement -> RETURN .) ]
  ! (               [ reduce using rule 59 (statement -> RETURN .) ]
  ! NUMBER          [ reduce using rule 59 (statement -> RETURN .) ]
  ! BOOLEAN         [ reduce using rule 59 (statement -> RETURN .) ]
  ! STRING          [ reduce using rule 59 (statement -> RETURN .) ]
  ! WORD            [ reduce using rule 59 (statement -> RETURN .) ]
  ! FUNCTION        [ reduce using rule 59 (statement -> RETURN .) ]
  ! %               [ reduce using rule 59 (statement -> RETURN .) ]
  ! {               [ reduce using rule 59 (statement -> RETURN .) ]

    expression                     shift and go to state 30
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 7

    (1) expression -> PASS .

    BREAK           reduce using rule 1 (expression -> PASS .)
    RETURN          reduce using rule 1 (expression -> PASS .)
    PASS            reduce using rule 1 (expression -> PASS .)
    MACRO           reduce using rule 1 (expression -> PASS .)
    IF              reduce using rule 1 (expression -> PASS .)
    NOT             reduce using rule 1 (expression -> PASS .)
    MIN             reduce using rule 1 (expression -> PASS .)
    MAX             reduce using rule 1 (expression -> PASS .)
    VARIABLE        reduce using rule 1 (expression -> PASS .)
    -               reduce using rule 1 (expression -> PASS .)
    (               reduce using rule 1 (expression -> PASS .)
    NUMBER          reduce using rule 1 (expression -> PASS .)
    BOOLEAN         reduce using rule 1 (expression -> PASS .)
    STRING          reduce using rule 1 (expression -> PASS .)
    WORD            reduce using rule 1 (expression -> PASS .)
    FUNCTION        reduce using rule 1 (expression -> PASS .)
    %               reduce using rule 1 (expression -> PASS .)
    {               reduce using rule 1 (expression -> PASS .)
    $end            reduce using rule 1 (expression -> PASS .)
    }               reduce using rule 1 (expression -> PASS .)
    )               reduce using rule 1 (expression -> PASS .)
    AND             reduce using rule 1 (expression -> PASS .)
    OR              reduce using rule 1 (expression -> PASS .)
    ,               reduce using rule 1 (expression -> PASS .)
    +               reduce using rule 1 (expression -> PASS .)
    *               reduce using rule 1 (expression -> PASS .)
    /               reduce using rule 1 (expression -> PASS .)
    LT              reduce using rule 1 (expression -> PASS .)
    LE              reduce using rule 1 (expression -> PASS .)
    GT              reduce using rule 1 (expression -> PASS .)
    GE              reduce using rule 1 (expression -> PASS .)
    EE              reduce using rule 1 (expression -> PASS .)
    NE              reduce using rule 1 (expression -> PASS .)
    ]               reduce using rule 1 (expression -> PASS .)
    #               reduce using rule 1 (expression -> PASS .)


state 8

    (2) expression -> MACRO . = expression
    (3) expression -> MACRO .

    =               shift and go to state 31
    BREAK           reduce using rule 3 (expression -> MACRO .)
    RETURN          reduce using rule 3 (expression -> MACRO .)
    PASS            reduce using rule 3 (expression -> MACRO .)
    MACRO           reduce using rule 3 (expression -> MACRO .)
    IF              reduce using rule 3 (expression -> MACRO .)
    NOT             reduce using rule 3 (expression -> MACRO .)
    MIN             reduce using rule 3 (expression -> MACRO .)
    MAX             reduce using rule 3 (expression -> MACRO .)
    VARIABLE        reduce using rule 3 (expression -> MACRO .)
    -               reduce using rule 3 (expression -> MACRO .)
    (               reduce using rule 3 (expression -> MACRO .)
    NUMBER          reduce using rule 3 (expression -> MACRO .)
    BOOLEAN         reduce using rule 3 (expression -> MACRO .)
    STRING          reduce using rule 3 (expression -> MACRO .)
    WORD            reduce using rule 3 (expression -> MACRO .)
    FUNCTION        reduce using rule 3 (expression -> MACRO .)
    %               reduce using rule 3 (expression -> MACRO .)
    {               reduce using rule 3 (expression -> MACRO .)
    $end            reduce using rule 3 (expression -> MACRO .)
    }               reduce using rule 3 (expression -> MACRO .)
    )               reduce using rule 3 (expression -> MACRO .)
    AND             reduce using rule 3 (expression -> MACRO .)
    OR              reduce using rule 3 (expression -> MACRO .)
    ,               reduce using rule 3 (expression -> MACRO .)
    +               reduce using rule 3 (expression -> MACRO .)
    *               reduce using rule 3 (expression -> MACRO .)
    /               reduce using rule 3 (expression -> MACRO .)
    LT              reduce using rule 3 (expression -> MACRO .)
    LE              reduce using rule 3 (expression -> MACRO .)
    GT              reduce using rule 3 (expression -> MACRO .)
    GE              reduce using rule 3 (expression -> MACRO .)
    EE              reduce using rule 3 (expression -> MACRO .)
    NE              reduce using rule 3 (expression -> MACRO .)
    ]               reduce using rule 3 (expression -> MACRO .)
    #               reduce using rule 3 (expression -> MACRO .)


state 9

    (74) expression -> comp .
    (43) comp -> comp . AND comp
    (44) comp -> comp . OR comp

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    BREAK           reduce using rule 74 (expression -> comp .)
    RETURN          reduce using rule 74 (expression -> comp .)
    PASS            reduce using rule 74 (expression -> comp .)
    MACRO           reduce using rule 74 (expression -> comp .)
    IF              reduce using rule 74 (expression -> comp .)
    NOT             reduce using rule 74 (expression -> comp .)
    MIN             reduce using rule 74 (expression -> comp .)
    MAX             reduce using rule 74 (expression -> comp .)
    VARIABLE        reduce using rule 74 (expression -> comp .)
    -               reduce using rule 74 (expression -> comp .)
    (               reduce using rule 74 (expression -> comp .)
    NUMBER          reduce using rule 74 (expression -> comp .)
    BOOLEAN         reduce using rule 74 (expression -> comp .)
    STRING          reduce using rule 74 (expression -> comp .)
    WORD            reduce using rule 74 (expression -> comp .)
    FUNCTION        reduce using rule 74 (expression -> comp .)
    %               reduce using rule 74 (expression -> comp .)
    {               reduce using rule 74 (expression -> comp .)
    $end            reduce using rule 74 (expression -> comp .)
    }               reduce using rule 74 (expression -> comp .)
    )               reduce using rule 74 (expression -> comp .)
    ,               reduce using rule 74 (expression -> comp .)
    +               reduce using rule 74 (expression -> comp .)
    *               reduce using rule 74 (expression -> comp .)
    /               reduce using rule 74 (expression -> comp .)
    LT              reduce using rule 74 (expression -> comp .)
    LE              reduce using rule 74 (expression -> comp .)
    GT              reduce using rule 74 (expression -> comp .)
    GE              reduce using rule 74 (expression -> comp .)
    EE              reduce using rule 74 (expression -> comp .)
    NE              reduce using rule 74 (expression -> comp .)
    ]               reduce using rule 74 (expression -> comp .)
    #               reduce using rule 74 (expression -> comp .)
    AND             shift and go to state 32
    OR              shift and go to state 33

  ! AND             [ reduce using rule 74 (expression -> comp .) ]
  ! OR              [ reduce using rule 74 (expression -> comp .) ]


state 10

    (10) if_condition -> IF . ( expression ) scope elif_branch
    (11) if_condition -> IF . ( expression ) scope else_branch
    (12) if_condition -> IF . ( expression ) scope

    (               shift and go to state 34


state 11

    (57) atom -> ( . expression )
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    expression                     shift and go to state 35
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 12

    (73) atom -> scope .

    +               reduce using rule 73 (atom -> scope .)
    -               reduce using rule 73 (atom -> scope .)
    *               reduce using rule 73 (atom -> scope .)
    /               reduce using rule 73 (atom -> scope .)
    LT              reduce using rule 73 (atom -> scope .)
    LE              reduce using rule 73 (atom -> scope .)
    GT              reduce using rule 73 (atom -> scope .)
    GE              reduce using rule 73 (atom -> scope .)
    EE              reduce using rule 73 (atom -> scope .)
    NE              reduce using rule 73 (atom -> scope .)
    AND             reduce using rule 73 (atom -> scope .)
    OR              reduce using rule 73 (atom -> scope .)
    BREAK           reduce using rule 73 (atom -> scope .)
    RETURN          reduce using rule 73 (atom -> scope .)
    PASS            reduce using rule 73 (atom -> scope .)
    MACRO           reduce using rule 73 (atom -> scope .)
    IF              reduce using rule 73 (atom -> scope .)
    NOT             reduce using rule 73 (atom -> scope .)
    MIN             reduce using rule 73 (atom -> scope .)
    MAX             reduce using rule 73 (atom -> scope .)
    VARIABLE        reduce using rule 73 (atom -> scope .)
    (               reduce using rule 73 (atom -> scope .)
    NUMBER          reduce using rule 73 (atom -> scope .)
    BOOLEAN         reduce using rule 73 (atom -> scope .)
    STRING          reduce using rule 73 (atom -> scope .)
    WORD            reduce using rule 73 (atom -> scope .)
    FUNCTION        reduce using rule 73 (atom -> scope .)
    %               reduce using rule 73 (atom -> scope .)
    {               reduce using rule 73 (atom -> scope .)
    $end            reduce using rule 73 (atom -> scope .)
    }               reduce using rule 73 (atom -> scope .)
    )               reduce using rule 73 (atom -> scope .)
    ,               reduce using rule 73 (atom -> scope .)
    ]               reduce using rule 73 (atom -> scope .)
    #               reduce using rule 73 (atom -> scope .)


state 13

    (36) comp -> NOT . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    comp                           shift and go to state 36
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 14

    (37) comp -> arith . LT arith
    (38) comp -> arith . LE arith
    (39) comp -> arith . GT arith
    (40) comp -> arith . GE arith
    (41) comp -> arith . EE arith
    (42) comp -> arith . NE arith
    (45) comp -> arith .

  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    LT              shift and go to state 37
    LE              shift and go to state 38
    GT              shift and go to state 39
    GE              shift and go to state 40
    EE              shift and go to state 41
    NE              shift and go to state 42
    AND             reduce using rule 45 (comp -> arith .)
    OR              reduce using rule 45 (comp -> arith .)
    BREAK           reduce using rule 45 (comp -> arith .)
    RETURN          reduce using rule 45 (comp -> arith .)
    PASS            reduce using rule 45 (comp -> arith .)
    MACRO           reduce using rule 45 (comp -> arith .)
    IF              reduce using rule 45 (comp -> arith .)
    NOT             reduce using rule 45 (comp -> arith .)
    MIN             reduce using rule 45 (comp -> arith .)
    MAX             reduce using rule 45 (comp -> arith .)
    VARIABLE        reduce using rule 45 (comp -> arith .)
    -               reduce using rule 45 (comp -> arith .)
    (               reduce using rule 45 (comp -> arith .)
    NUMBER          reduce using rule 45 (comp -> arith .)
    BOOLEAN         reduce using rule 45 (comp -> arith .)
    STRING          reduce using rule 45 (comp -> arith .)
    WORD            reduce using rule 45 (comp -> arith .)
    FUNCTION        reduce using rule 45 (comp -> arith .)
    %               reduce using rule 45 (comp -> arith .)
    {               reduce using rule 45 (comp -> arith .)
    $end            reduce using rule 45 (comp -> arith .)
    }               reduce using rule 45 (comp -> arith .)
    )               reduce using rule 45 (comp -> arith .)
    ,               reduce using rule 45 (comp -> arith .)
    +               reduce using rule 45 (comp -> arith .)
    *               reduce using rule 45 (comp -> arith .)
    /               reduce using rule 45 (comp -> arith .)
    ]               reduce using rule 45 (comp -> arith .)
    #               reduce using rule 45 (comp -> arith .)

  ! LT              [ reduce using rule 45 (comp -> arith .) ]
  ! LE              [ reduce using rule 45 (comp -> arith .) ]
  ! GT              [ reduce using rule 45 (comp -> arith .) ]
  ! GE              [ reduce using rule 45 (comp -> arith .) ]
  ! EE              [ reduce using rule 45 (comp -> arith .) ]
  ! NE              [ reduce using rule 45 (comp -> arith .) ]


state 15

    (46) arith -> atom . + atom
    (47) arith -> atom . - atom
    (48) arith -> atom . * atom
    (49) arith -> atom . / atom
    (50) arith -> atom .

  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    +               shift and go to state 43
    -               shift and go to state 44
    *               shift and go to state 45
    /               shift and go to state 46
    LT              reduce using rule 50 (arith -> atom .)
    LE              reduce using rule 50 (arith -> atom .)
    GT              reduce using rule 50 (arith -> atom .)
    GE              reduce using rule 50 (arith -> atom .)
    EE              reduce using rule 50 (arith -> atom .)
    NE              reduce using rule 50 (arith -> atom .)
    AND             reduce using rule 50 (arith -> atom .)
    OR              reduce using rule 50 (arith -> atom .)
    BREAK           reduce using rule 50 (arith -> atom .)
    RETURN          reduce using rule 50 (arith -> atom .)
    PASS            reduce using rule 50 (arith -> atom .)
    MACRO           reduce using rule 50 (arith -> atom .)
    IF              reduce using rule 50 (arith -> atom .)
    NOT             reduce using rule 50 (arith -> atom .)
    MIN             reduce using rule 50 (arith -> atom .)
    MAX             reduce using rule 50 (arith -> atom .)
    VARIABLE        reduce using rule 50 (arith -> atom .)
    (               reduce using rule 50 (arith -> atom .)
    NUMBER          reduce using rule 50 (arith -> atom .)
    BOOLEAN         reduce using rule 50 (arith -> atom .)
    STRING          reduce using rule 50 (arith -> atom .)
    WORD            reduce using rule 50 (arith -> atom .)
    FUNCTION        reduce using rule 50 (arith -> atom .)
    %               reduce using rule 50 (arith -> atom .)
    {               reduce using rule 50 (arith -> atom .)
    $end            reduce using rule 50 (arith -> atom .)
    }               reduce using rule 50 (arith -> atom .)
    )               reduce using rule 50 (arith -> atom .)
    ,               reduce using rule 50 (arith -> atom .)
    ]               reduce using rule 50 (arith -> atom .)
    #               reduce using rule 50 (arith -> atom .)

  ! -               [ reduce using rule 50 (arith -> atom .) ]
  ! +               [ reduce using rule 50 (arith -> atom .) ]
  ! *               [ reduce using rule 50 (arith -> atom .) ]
  ! /               [ reduce using rule 50 (arith -> atom .) ]


state 16

    (51) atom -> - . atom
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    atom                           shift and go to state 47
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 17

    (55) arith -> MIN . ( comma_expressions )

    (               shift and go to state 48


state 18

    (56) arith -> MAX . ( comma_expressions )

    (               shift and go to state 49


state 19

    (4) atom -> VARIABLE . = expression
    (5) atom -> VARIABLE .

    =               shift and go to state 50
    +               reduce using rule 5 (atom -> VARIABLE .)
    -               reduce using rule 5 (atom -> VARIABLE .)
    *               reduce using rule 5 (atom -> VARIABLE .)
    /               reduce using rule 5 (atom -> VARIABLE .)
    LT              reduce using rule 5 (atom -> VARIABLE .)
    LE              reduce using rule 5 (atom -> VARIABLE .)
    GT              reduce using rule 5 (atom -> VARIABLE .)
    GE              reduce using rule 5 (atom -> VARIABLE .)
    EE              reduce using rule 5 (atom -> VARIABLE .)
    NE              reduce using rule 5 (atom -> VARIABLE .)
    AND             reduce using rule 5 (atom -> VARIABLE .)
    OR              reduce using rule 5 (atom -> VARIABLE .)
    BREAK           reduce using rule 5 (atom -> VARIABLE .)
    RETURN          reduce using rule 5 (atom -> VARIABLE .)
    PASS            reduce using rule 5 (atom -> VARIABLE .)
    MACRO           reduce using rule 5 (atom -> VARIABLE .)
    IF              reduce using rule 5 (atom -> VARIABLE .)
    NOT             reduce using rule 5 (atom -> VARIABLE .)
    MIN             reduce using rule 5 (atom -> VARIABLE .)
    MAX             reduce using rule 5 (atom -> VARIABLE .)
    VARIABLE        reduce using rule 5 (atom -> VARIABLE .)
    (               reduce using rule 5 (atom -> VARIABLE .)
    NUMBER          reduce using rule 5 (atom -> VARIABLE .)
    BOOLEAN         reduce using rule 5 (atom -> VARIABLE .)
    STRING          reduce using rule 5 (atom -> VARIABLE .)
    WORD            reduce using rule 5 (atom -> VARIABLE .)
    FUNCTION        reduce using rule 5 (atom -> VARIABLE .)
    %               reduce using rule 5 (atom -> VARIABLE .)
    {               reduce using rule 5 (atom -> VARIABLE .)
    $end            reduce using rule 5 (atom -> VARIABLE .)
    }               reduce using rule 5 (atom -> VARIABLE .)
    )               reduce using rule 5 (atom -> VARIABLE .)
    ,               reduce using rule 5 (atom -> VARIABLE .)
    ]               reduce using rule 5 (atom -> VARIABLE .)
    #               reduce using rule 5 (atom -> VARIABLE .)


state 20

    (35) atom -> function_call .

    +               reduce using rule 35 (atom -> function_call .)
    -               reduce using rule 35 (atom -> function_call .)
    *               reduce using rule 35 (atom -> function_call .)
    /               reduce using rule 35 (atom -> function_call .)
    LT              reduce using rule 35 (atom -> function_call .)
    LE              reduce using rule 35 (atom -> function_call .)
    GT              reduce using rule 35 (atom -> function_call .)
    GE              reduce using rule 35 (atom -> function_call .)
    EE              reduce using rule 35 (atom -> function_call .)
    NE              reduce using rule 35 (atom -> function_call .)
    AND             reduce using rule 35 (atom -> function_call .)
    OR              reduce using rule 35 (atom -> function_call .)
    BREAK           reduce using rule 35 (atom -> function_call .)
    RETURN          reduce using rule 35 (atom -> function_call .)
    PASS            reduce using rule 35 (atom -> function_call .)
    MACRO           reduce using rule 35 (atom -> function_call .)
    IF              reduce using rule 35 (atom -> function_call .)
    NOT             reduce using rule 35 (atom -> function_call .)
    MIN             reduce using rule 35 (atom -> function_call .)
    MAX             reduce using rule 35 (atom -> function_call .)
    VARIABLE        reduce using rule 35 (atom -> function_call .)
    (               reduce using rule 35 (atom -> function_call .)
    NUMBER          reduce using rule 35 (atom -> function_call .)
    BOOLEAN         reduce using rule 35 (atom -> function_call .)
    STRING          reduce using rule 35 (atom -> function_call .)
    WORD            reduce using rule 35 (atom -> function_call .)
    FUNCTION        reduce using rule 35 (atom -> function_call .)
    %               reduce using rule 35 (atom -> function_call .)
    {               reduce using rule 35 (atom -> function_call .)
    $end            reduce using rule 35 (atom -> function_call .)
    }               reduce using rule 35 (atom -> function_call .)
    )               reduce using rule 35 (atom -> function_call .)
    ,               reduce using rule 35 (atom -> function_call .)
    ]               reduce using rule 35 (atom -> function_call .)
    #               reduce using rule 35 (atom -> function_call .)


state 21

    (68) atom -> NUMBER .

    +               reduce using rule 68 (atom -> NUMBER .)
    -               reduce using rule 68 (atom -> NUMBER .)
    *               reduce using rule 68 (atom -> NUMBER .)
    /               reduce using rule 68 (atom -> NUMBER .)
    LT              reduce using rule 68 (atom -> NUMBER .)
    LE              reduce using rule 68 (atom -> NUMBER .)
    GT              reduce using rule 68 (atom -> NUMBER .)
    GE              reduce using rule 68 (atom -> NUMBER .)
    EE              reduce using rule 68 (atom -> NUMBER .)
    NE              reduce using rule 68 (atom -> NUMBER .)
    AND             reduce using rule 68 (atom -> NUMBER .)
    OR              reduce using rule 68 (atom -> NUMBER .)
    BREAK           reduce using rule 68 (atom -> NUMBER .)
    RETURN          reduce using rule 68 (atom -> NUMBER .)
    PASS            reduce using rule 68 (atom -> NUMBER .)
    MACRO           reduce using rule 68 (atom -> NUMBER .)
    IF              reduce using rule 68 (atom -> NUMBER .)
    NOT             reduce using rule 68 (atom -> NUMBER .)
    MIN             reduce using rule 68 (atom -> NUMBER .)
    MAX             reduce using rule 68 (atom -> NUMBER .)
    VARIABLE        reduce using rule 68 (atom -> NUMBER .)
    (               reduce using rule 68 (atom -> NUMBER .)
    NUMBER          reduce using rule 68 (atom -> NUMBER .)
    BOOLEAN         reduce using rule 68 (atom -> NUMBER .)
    STRING          reduce using rule 68 (atom -> NUMBER .)
    WORD            reduce using rule 68 (atom -> NUMBER .)
    FUNCTION        reduce using rule 68 (atom -> NUMBER .)
    %               reduce using rule 68 (atom -> NUMBER .)
    {               reduce using rule 68 (atom -> NUMBER .)
    $end            reduce using rule 68 (atom -> NUMBER .)
    }               reduce using rule 68 (atom -> NUMBER .)
    )               reduce using rule 68 (atom -> NUMBER .)
    ,               reduce using rule 68 (atom -> NUMBER .)
    ]               reduce using rule 68 (atom -> NUMBER .)
    #               reduce using rule 68 (atom -> NUMBER .)


state 22

    (69) atom -> BOOLEAN .

    +               reduce using rule 69 (atom -> BOOLEAN .)
    -               reduce using rule 69 (atom -> BOOLEAN .)
    *               reduce using rule 69 (atom -> BOOLEAN .)
    /               reduce using rule 69 (atom -> BOOLEAN .)
    LT              reduce using rule 69 (atom -> BOOLEAN .)
    LE              reduce using rule 69 (atom -> BOOLEAN .)
    GT              reduce using rule 69 (atom -> BOOLEAN .)
    GE              reduce using rule 69 (atom -> BOOLEAN .)
    EE              reduce using rule 69 (atom -> BOOLEAN .)
    NE              reduce using rule 69 (atom -> BOOLEAN .)
    AND             reduce using rule 69 (atom -> BOOLEAN .)
    OR              reduce using rule 69 (atom -> BOOLEAN .)
    BREAK           reduce using rule 69 (atom -> BOOLEAN .)
    RETURN          reduce using rule 69 (atom -> BOOLEAN .)
    PASS            reduce using rule 69 (atom -> BOOLEAN .)
    MACRO           reduce using rule 69 (atom -> BOOLEAN .)
    IF              reduce using rule 69 (atom -> BOOLEAN .)
    NOT             reduce using rule 69 (atom -> BOOLEAN .)
    MIN             reduce using rule 69 (atom -> BOOLEAN .)
    MAX             reduce using rule 69 (atom -> BOOLEAN .)
    VARIABLE        reduce using rule 69 (atom -> BOOLEAN .)
    (               reduce using rule 69 (atom -> BOOLEAN .)
    NUMBER          reduce using rule 69 (atom -> BOOLEAN .)
    BOOLEAN         reduce using rule 69 (atom -> BOOLEAN .)
    STRING          reduce using rule 69 (atom -> BOOLEAN .)
    WORD            reduce using rule 69 (atom -> BOOLEAN .)
    FUNCTION        reduce using rule 69 (atom -> BOOLEAN .)
    %               reduce using rule 69 (atom -> BOOLEAN .)
    {               reduce using rule 69 (atom -> BOOLEAN .)
    $end            reduce using rule 69 (atom -> BOOLEAN .)
    }               reduce using rule 69 (atom -> BOOLEAN .)
    )               reduce using rule 69 (atom -> BOOLEAN .)
    ,               reduce using rule 69 (atom -> BOOLEAN .)
    ]               reduce using rule 69 (atom -> BOOLEAN .)
    #               reduce using rule 69 (atom -> BOOLEAN .)


state 23

    (70) atom -> STRING .

    +               reduce using rule 70 (atom -> STRING .)
    -               reduce using rule 70 (atom -> STRING .)
    *               reduce using rule 70 (atom -> STRING .)
    /               reduce using rule 70 (atom -> STRING .)
    LT              reduce using rule 70 (atom -> STRING .)
    LE              reduce using rule 70 (atom -> STRING .)
    GT              reduce using rule 70 (atom -> STRING .)
    GE              reduce using rule 70 (atom -> STRING .)
    EE              reduce using rule 70 (atom -> STRING .)
    NE              reduce using rule 70 (atom -> STRING .)
    AND             reduce using rule 70 (atom -> STRING .)
    OR              reduce using rule 70 (atom -> STRING .)
    BREAK           reduce using rule 70 (atom -> STRING .)
    RETURN          reduce using rule 70 (atom -> STRING .)
    PASS            reduce using rule 70 (atom -> STRING .)
    MACRO           reduce using rule 70 (atom -> STRING .)
    IF              reduce using rule 70 (atom -> STRING .)
    NOT             reduce using rule 70 (atom -> STRING .)
    MIN             reduce using rule 70 (atom -> STRING .)
    MAX             reduce using rule 70 (atom -> STRING .)
    VARIABLE        reduce using rule 70 (atom -> STRING .)
    (               reduce using rule 70 (atom -> STRING .)
    NUMBER          reduce using rule 70 (atom -> STRING .)
    BOOLEAN         reduce using rule 70 (atom -> STRING .)
    STRING          reduce using rule 70 (atom -> STRING .)
    WORD            reduce using rule 70 (atom -> STRING .)
    FUNCTION        reduce using rule 70 (atom -> STRING .)
    %               reduce using rule 70 (atom -> STRING .)
    {               reduce using rule 70 (atom -> STRING .)
    $end            reduce using rule 70 (atom -> STRING .)
    }               reduce using rule 70 (atom -> STRING .)
    )               reduce using rule 70 (atom -> STRING .)
    ,               reduce using rule 70 (atom -> STRING .)
    ]               reduce using rule 70 (atom -> STRING .)
    #               reduce using rule 70 (atom -> STRING .)


state 24

    (71) atom -> table .

    +               reduce using rule 71 (atom -> table .)
    -               reduce using rule 71 (atom -> table .)
    *               reduce using rule 71 (atom -> table .)
    /               reduce using rule 71 (atom -> table .)
    LT              reduce using rule 71 (atom -> table .)
    LE              reduce using rule 71 (atom -> table .)
    GT              reduce using rule 71 (atom -> table .)
    GE              reduce using rule 71 (atom -> table .)
    EE              reduce using rule 71 (atom -> table .)
    NE              reduce using rule 71 (atom -> table .)
    AND             reduce using rule 71 (atom -> table .)
    OR              reduce using rule 71 (atom -> table .)
    BREAK           reduce using rule 71 (atom -> table .)
    RETURN          reduce using rule 71 (atom -> table .)
    PASS            reduce using rule 71 (atom -> table .)
    MACRO           reduce using rule 71 (atom -> table .)
    IF              reduce using rule 71 (atom -> table .)
    NOT             reduce using rule 71 (atom -> table .)
    MIN             reduce using rule 71 (atom -> table .)
    MAX             reduce using rule 71 (atom -> table .)
    VARIABLE        reduce using rule 71 (atom -> table .)
    (               reduce using rule 71 (atom -> table .)
    NUMBER          reduce using rule 71 (atom -> table .)
    BOOLEAN         reduce using rule 71 (atom -> table .)
    STRING          reduce using rule 71 (atom -> table .)
    WORD            reduce using rule 71 (atom -> table .)
    FUNCTION        reduce using rule 71 (atom -> table .)
    %               reduce using rule 71 (atom -> table .)
    {               reduce using rule 71 (atom -> table .)
    $end            reduce using rule 71 (atom -> table .)
    }               reduce using rule 71 (atom -> table .)
    )               reduce using rule 71 (atom -> table .)
    ,               reduce using rule 71 (atom -> table .)
    ]               reduce using rule 71 (atom -> table .)
    #               reduce using rule 71 (atom -> table .)


state 25

    (72) atom -> WORD .

    +               reduce using rule 72 (atom -> WORD .)
    -               reduce using rule 72 (atom -> WORD .)
    *               reduce using rule 72 (atom -> WORD .)
    /               reduce using rule 72 (atom -> WORD .)
    LT              reduce using rule 72 (atom -> WORD .)
    LE              reduce using rule 72 (atom -> WORD .)
    GT              reduce using rule 72 (atom -> WORD .)
    GE              reduce using rule 72 (atom -> WORD .)
    EE              reduce using rule 72 (atom -> WORD .)
    NE              reduce using rule 72 (atom -> WORD .)
    AND             reduce using rule 72 (atom -> WORD .)
    OR              reduce using rule 72 (atom -> WORD .)
    BREAK           reduce using rule 72 (atom -> WORD .)
    RETURN          reduce using rule 72 (atom -> WORD .)
    PASS            reduce using rule 72 (atom -> WORD .)
    MACRO           reduce using rule 72 (atom -> WORD .)
    IF              reduce using rule 72 (atom -> WORD .)
    NOT             reduce using rule 72 (atom -> WORD .)
    MIN             reduce using rule 72 (atom -> WORD .)
    MAX             reduce using rule 72 (atom -> WORD .)
    VARIABLE        reduce using rule 72 (atom -> WORD .)
    (               reduce using rule 72 (atom -> WORD .)
    NUMBER          reduce using rule 72 (atom -> WORD .)
    BOOLEAN         reduce using rule 72 (atom -> WORD .)
    STRING          reduce using rule 72 (atom -> WORD .)
    WORD            reduce using rule 72 (atom -> WORD .)
    FUNCTION        reduce using rule 72 (atom -> WORD .)
    %               reduce using rule 72 (atom -> WORD .)
    {               reduce using rule 72 (atom -> WORD .)
    $end            reduce using rule 72 (atom -> WORD .)
    }               reduce using rule 72 (atom -> WORD .)
    )               reduce using rule 72 (atom -> WORD .)
    ,               reduce using rule 72 (atom -> WORD .)
    ]               reduce using rule 72 (atom -> WORD .)
    #               reduce using rule 72 (atom -> WORD .)


state 26

    (13) function_call -> FUNCTION . parameters scope
    (14) function_call -> FUNCTION . parameters tag_list
    (15) function_call -> FUNCTION . parameters
    (16) function_call -> FUNCTION .
    (23) parameters -> . ( param_element )
    (24) parameters -> . ( )

  ! shift/reduce conflict for ( resolved as shift
    +               reduce using rule 16 (function_call -> FUNCTION .)
    -               reduce using rule 16 (function_call -> FUNCTION .)
    *               reduce using rule 16 (function_call -> FUNCTION .)
    /               reduce using rule 16 (function_call -> FUNCTION .)
    LT              reduce using rule 16 (function_call -> FUNCTION .)
    LE              reduce using rule 16 (function_call -> FUNCTION .)
    GT              reduce using rule 16 (function_call -> FUNCTION .)
    GE              reduce using rule 16 (function_call -> FUNCTION .)
    EE              reduce using rule 16 (function_call -> FUNCTION .)
    NE              reduce using rule 16 (function_call -> FUNCTION .)
    AND             reduce using rule 16 (function_call -> FUNCTION .)
    OR              reduce using rule 16 (function_call -> FUNCTION .)
    BREAK           reduce using rule 16 (function_call -> FUNCTION .)
    RETURN          reduce using rule 16 (function_call -> FUNCTION .)
    PASS            reduce using rule 16 (function_call -> FUNCTION .)
    MACRO           reduce using rule 16 (function_call -> FUNCTION .)
    IF              reduce using rule 16 (function_call -> FUNCTION .)
    NOT             reduce using rule 16 (function_call -> FUNCTION .)
    MIN             reduce using rule 16 (function_call -> FUNCTION .)
    MAX             reduce using rule 16 (function_call -> FUNCTION .)
    VARIABLE        reduce using rule 16 (function_call -> FUNCTION .)
    NUMBER          reduce using rule 16 (function_call -> FUNCTION .)
    BOOLEAN         reduce using rule 16 (function_call -> FUNCTION .)
    STRING          reduce using rule 16 (function_call -> FUNCTION .)
    WORD            reduce using rule 16 (function_call -> FUNCTION .)
    FUNCTION        reduce using rule 16 (function_call -> FUNCTION .)
    %               reduce using rule 16 (function_call -> FUNCTION .)
    {               reduce using rule 16 (function_call -> FUNCTION .)
    $end            reduce using rule 16 (function_call -> FUNCTION .)
    }               reduce using rule 16 (function_call -> FUNCTION .)
    )               reduce using rule 16 (function_call -> FUNCTION .)
    ,               reduce using rule 16 (function_call -> FUNCTION .)
    ]               reduce using rule 16 (function_call -> FUNCTION .)
    #               reduce using rule 16 (function_call -> FUNCTION .)
    (               shift and go to state 52

  ! (               [ reduce using rule 16 (function_call -> FUNCTION .) ]

    parameters                     shift and go to state 51

state 27

    (66) table -> % . [ comma_expressions ]
    (67) table -> % . { table_contents }

    [               shift and go to state 53
    {               shift and go to state 54


state 28

    (20) scope -> { . expressions }
    (21) expressions -> . statement expressions
    (22) expressions -> . statement
    (32) statement -> . BREAK
    (33) statement -> . expression
    (34) statement -> . if_condition
    (58) statement -> . RETURN expression
    (59) statement -> . RETURN
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (10) if_condition -> . IF ( expression ) scope elif_branch
    (11) if_condition -> . IF ( expression ) scope else_branch
    (12) if_condition -> . IF ( expression ) scope
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    BREAK           shift and go to state 3
    RETURN          shift and go to state 6
    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    IF              shift and go to state 10
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    expressions                    shift and go to state 55
    statement                      shift and go to state 2
    expression                     shift and go to state 4
    if_condition                   shift and go to state 5
    comp                           shift and go to state 9
    scope                          shift and go to state 12
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24

state 29

    (21) expressions -> statement expressions .

    $end            reduce using rule 21 (expressions -> statement expressions .)
    }               reduce using rule 21 (expressions -> statement expressions .)


state 30

    (58) statement -> RETURN expression .

    BREAK           reduce using rule 58 (statement -> RETURN expression .)
    RETURN          reduce using rule 58 (statement -> RETURN expression .)
    PASS            reduce using rule 58 (statement -> RETURN expression .)
    MACRO           reduce using rule 58 (statement -> RETURN expression .)
    IF              reduce using rule 58 (statement -> RETURN expression .)
    NOT             reduce using rule 58 (statement -> RETURN expression .)
    MIN             reduce using rule 58 (statement -> RETURN expression .)
    MAX             reduce using rule 58 (statement -> RETURN expression .)
    VARIABLE        reduce using rule 58 (statement -> RETURN expression .)
    -               reduce using rule 58 (statement -> RETURN expression .)
    (               reduce using rule 58 (statement -> RETURN expression .)
    NUMBER          reduce using rule 58 (statement -> RETURN expression .)
    BOOLEAN         reduce using rule 58 (statement -> RETURN expression .)
    STRING          reduce using rule 58 (statement -> RETURN expression .)
    WORD            reduce using rule 58 (statement -> RETURN expression .)
    FUNCTION        reduce using rule 58 (statement -> RETURN expression .)
    %               reduce using rule 58 (statement -> RETURN expression .)
    {               reduce using rule 58 (statement -> RETURN expression .)
    $end            reduce using rule 58 (statement -> RETURN expression .)
    }               reduce using rule 58 (statement -> RETURN expression .)


state 31

    (2) expression -> MACRO = . expression
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    expression                     shift and go to state 56
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 32

    (43) comp -> comp AND . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    comp                           shift and go to state 57
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 33

    (44) comp -> comp OR . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    comp                           shift and go to state 58
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 34

    (10) if_condition -> IF ( . expression ) scope elif_branch
    (11) if_condition -> IF ( . expression ) scope else_branch
    (12) if_condition -> IF ( . expression ) scope
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    expression                     shift and go to state 59
    scope                          shift and go to state 12
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24

state 35

    (57) atom -> ( expression . )

    )               shift and go to state 60


state 36

    (36) comp -> NOT comp .
    (43) comp -> comp . AND comp
    (44) comp -> comp . OR comp

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    BREAK           reduce using rule 36 (comp -> NOT comp .)
    RETURN          reduce using rule 36 (comp -> NOT comp .)
    PASS            reduce using rule 36 (comp -> NOT comp .)
    MACRO           reduce using rule 36 (comp -> NOT comp .)
    IF              reduce using rule 36 (comp -> NOT comp .)
    NOT             reduce using rule 36 (comp -> NOT comp .)
    MIN             reduce using rule 36 (comp -> NOT comp .)
    MAX             reduce using rule 36 (comp -> NOT comp .)
    VARIABLE        reduce using rule 36 (comp -> NOT comp .)
    -               reduce using rule 36 (comp -> NOT comp .)
    (               reduce using rule 36 (comp -> NOT comp .)
    NUMBER          reduce using rule 36 (comp -> NOT comp .)
    BOOLEAN         reduce using rule 36 (comp -> NOT comp .)
    STRING          reduce using rule 36 (comp -> NOT comp .)
    WORD            reduce using rule 36 (comp -> NOT comp .)
    FUNCTION        reduce using rule 36 (comp -> NOT comp .)
    %               reduce using rule 36 (comp -> NOT comp .)
    {               reduce using rule 36 (comp -> NOT comp .)
    $end            reduce using rule 36 (comp -> NOT comp .)
    }               reduce using rule 36 (comp -> NOT comp .)
    )               reduce using rule 36 (comp -> NOT comp .)
    ,               reduce using rule 36 (comp -> NOT comp .)
    +               reduce using rule 36 (comp -> NOT comp .)
    *               reduce using rule 36 (comp -> NOT comp .)
    /               reduce using rule 36 (comp -> NOT comp .)
    LT              reduce using rule 36 (comp -> NOT comp .)
    LE              reduce using rule 36 (comp -> NOT comp .)
    GT              reduce using rule 36 (comp -> NOT comp .)
    GE              reduce using rule 36 (comp -> NOT comp .)
    EE              reduce using rule 36 (comp -> NOT comp .)
    NE              reduce using rule 36 (comp -> NOT comp .)
    ]               reduce using rule 36 (comp -> NOT comp .)
    #               reduce using rule 36 (comp -> NOT comp .)
    AND             shift and go to state 32
    OR              shift and go to state 33

  ! AND             [ reduce using rule 36 (comp -> NOT comp .) ]
  ! OR              [ reduce using rule 36 (comp -> NOT comp .) ]


state 37

    (37) comp -> arith LT . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    arith                          shift and go to state 61
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 38

    (38) comp -> arith LE . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    arith                          shift and go to state 62
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 39

    (39) comp -> arith GT . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    arith                          shift and go to state 63
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 40

    (40) comp -> arith GE . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    arith                          shift and go to state 64
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 41

    (41) comp -> arith EE . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    arith                          shift and go to state 65
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 42

    (42) comp -> arith NE . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    arith                          shift and go to state 66
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 43

    (46) arith -> atom + . atom
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    atom                           shift and go to state 67
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 44

    (47) arith -> atom - . atom
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    atom                           shift and go to state 68
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 45

    (48) arith -> atom * . atom
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    atom                           shift and go to state 69
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 46

    (49) arith -> atom / . atom
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    atom                           shift and go to state 70
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 47

    (51) atom -> - atom .

    +               reduce using rule 51 (atom -> - atom .)
    -               reduce using rule 51 (atom -> - atom .)
    *               reduce using rule 51 (atom -> - atom .)
    /               reduce using rule 51 (atom -> - atom .)
    LT              reduce using rule 51 (atom -> - atom .)
    LE              reduce using rule 51 (atom -> - atom .)
    GT              reduce using rule 51 (atom -> - atom .)
    GE              reduce using rule 51 (atom -> - atom .)
    EE              reduce using rule 51 (atom -> - atom .)
    NE              reduce using rule 51 (atom -> - atom .)
    AND             reduce using rule 51 (atom -> - atom .)
    OR              reduce using rule 51 (atom -> - atom .)
    BREAK           reduce using rule 51 (atom -> - atom .)
    RETURN          reduce using rule 51 (atom -> - atom .)
    PASS            reduce using rule 51 (atom -> - atom .)
    MACRO           reduce using rule 51 (atom -> - atom .)
    IF              reduce using rule 51 (atom -> - atom .)
    NOT             reduce using rule 51 (atom -> - atom .)
    MIN             reduce using rule 51 (atom -> - atom .)
    MAX             reduce using rule 51 (atom -> - atom .)
    VARIABLE        reduce using rule 51 (atom -> - atom .)
    (               reduce using rule 51 (atom -> - atom .)
    NUMBER          reduce using rule 51 (atom -> - atom .)
    BOOLEAN         reduce using rule 51 (atom -> - atom .)
    STRING          reduce using rule 51 (atom -> - atom .)
    WORD            reduce using rule 51 (atom -> - atom .)
    FUNCTION        reduce using rule 51 (atom -> - atom .)
    %               reduce using rule 51 (atom -> - atom .)
    {               reduce using rule 51 (atom -> - atom .)
    $end            reduce using rule 51 (atom -> - atom .)
    }               reduce using rule 51 (atom -> - atom .)
    )               reduce using rule 51 (atom -> - atom .)
    ,               reduce using rule 51 (atom -> - atom .)
    ]               reduce using rule 51 (atom -> - atom .)
    #               reduce using rule 51 (atom -> - atom .)


state 48

    (55) arith -> MIN ( . comma_expressions )
    (52) comma_expressions -> . expression , comma_expressions
    (53) comma_expressions -> . expression ,
    (54) comma_expressions -> . expression
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    comma_expressions              shift and go to state 71
    expression                     shift and go to state 72
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 49

    (56) arith -> MAX ( . comma_expressions )
    (52) comma_expressions -> . expression , comma_expressions
    (53) comma_expressions -> . expression ,
    (54) comma_expressions -> . expression
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    comma_expressions              shift and go to state 73
    expression                     shift and go to state 72
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 50

    (4) atom -> VARIABLE = . expression
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    expression                     shift and go to state 74
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 51

    (13) function_call -> FUNCTION parameters . scope
    (14) function_call -> FUNCTION parameters . tag_list
    (15) function_call -> FUNCTION parameters .
    (20) scope -> . { expressions }
    (18) tag_list -> . tag # scope tag_list
    (19) tag_list -> . tag # scope
    (17) tag -> . TAG expression

  ! shift/reduce conflict for { resolved as shift
    +               reduce using rule 15 (function_call -> FUNCTION parameters .)
    -               reduce using rule 15 (function_call -> FUNCTION parameters .)
    *               reduce using rule 15 (function_call -> FUNCTION parameters .)
    /               reduce using rule 15 (function_call -> FUNCTION parameters .)
    LT              reduce using rule 15 (function_call -> FUNCTION parameters .)
    LE              reduce using rule 15 (function_call -> FUNCTION parameters .)
    GT              reduce using rule 15 (function_call -> FUNCTION parameters .)
    GE              reduce using rule 15 (function_call -> FUNCTION parameters .)
    EE              reduce using rule 15 (function_call -> FUNCTION parameters .)
    NE              reduce using rule 15 (function_call -> FUNCTION parameters .)
    AND             reduce using rule 15 (function_call -> FUNCTION parameters .)
    OR              reduce using rule 15 (function_call -> FUNCTION parameters .)
    BREAK           reduce using rule 15 (function_call -> FUNCTION parameters .)
    RETURN          reduce using rule 15 (function_call -> FUNCTION parameters .)
    PASS            reduce using rule 15 (function_call -> FUNCTION parameters .)
    MACRO           reduce using rule 15 (function_call -> FUNCTION parameters .)
    IF              reduce using rule 15 (function_call -> FUNCTION parameters .)
    NOT             reduce using rule 15 (function_call -> FUNCTION parameters .)
    MIN             reduce using rule 15 (function_call -> FUNCTION parameters .)
    MAX             reduce using rule 15 (function_call -> FUNCTION parameters .)
    VARIABLE        reduce using rule 15 (function_call -> FUNCTION parameters .)
    (               reduce using rule 15 (function_call -> FUNCTION parameters .)
    NUMBER          reduce using rule 15 (function_call -> FUNCTION parameters .)
    BOOLEAN         reduce using rule 15 (function_call -> FUNCTION parameters .)
    STRING          reduce using rule 15 (function_call -> FUNCTION parameters .)
    WORD            reduce using rule 15 (function_call -> FUNCTION parameters .)
    FUNCTION        reduce using rule 15 (function_call -> FUNCTION parameters .)
    %               reduce using rule 15 (function_call -> FUNCTION parameters .)
    $end            reduce using rule 15 (function_call -> FUNCTION parameters .)
    }               reduce using rule 15 (function_call -> FUNCTION parameters .)
    )               reduce using rule 15 (function_call -> FUNCTION parameters .)
    ,               reduce using rule 15 (function_call -> FUNCTION parameters .)
    ]               reduce using rule 15 (function_call -> FUNCTION parameters .)
    #               reduce using rule 15 (function_call -> FUNCTION parameters .)
    {               shift and go to state 28
    TAG             shift and go to state 78

  ! {               [ reduce using rule 15 (function_call -> FUNCTION parameters .) ]

    scope                          shift and go to state 75
    tag_list                       shift and go to state 76
    tag                            shift and go to state 77

state 52

    (23) parameters -> ( . param_element )
    (24) parameters -> ( . )
    (28) param_element -> . expression , param_element
    (29) param_element -> . expression , param_element_pos
    (30) param_element -> . expression ,
    (31) param_element -> . expression
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    )               shift and go to state 80
    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    param_element                  shift and go to state 79
    expression                     shift and go to state 81
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 53

    (66) table -> % [ . comma_expressions ]
    (52) comma_expressions -> . expression , comma_expressions
    (53) comma_expressions -> . expression ,
    (54) comma_expressions -> . expression
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    comma_expressions              shift and go to state 82
    expression                     shift and go to state 72
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 54

    (67) table -> % { . table_contents }
    (60) table_contents -> . STRING : expression , table_contents
    (61) table_contents -> . NUMBER : expression , table_contents
    (62) table_contents -> . STRING : expression ,
    (63) table_contents -> . NUMBER : expression ,
    (64) table_contents -> . STRING : expression
    (65) table_contents -> . NUMBER : expression

    STRING          shift and go to state 84
    NUMBER          shift and go to state 85

    table_contents                 shift and go to state 83

state 55

    (20) scope -> { expressions . }

    }               shift and go to state 86


state 56

    (2) expression -> MACRO = expression .

    BREAK           reduce using rule 2 (expression -> MACRO = expression .)
    RETURN          reduce using rule 2 (expression -> MACRO = expression .)
    PASS            reduce using rule 2 (expression -> MACRO = expression .)
    MACRO           reduce using rule 2 (expression -> MACRO = expression .)
    IF              reduce using rule 2 (expression -> MACRO = expression .)
    NOT             reduce using rule 2 (expression -> MACRO = expression .)
    MIN             reduce using rule 2 (expression -> MACRO = expression .)
    MAX             reduce using rule 2 (expression -> MACRO = expression .)
    VARIABLE        reduce using rule 2 (expression -> MACRO = expression .)
    -               reduce using rule 2 (expression -> MACRO = expression .)
    (               reduce using rule 2 (expression -> MACRO = expression .)
    NUMBER          reduce using rule 2 (expression -> MACRO = expression .)
    BOOLEAN         reduce using rule 2 (expression -> MACRO = expression .)
    STRING          reduce using rule 2 (expression -> MACRO = expression .)
    WORD            reduce using rule 2 (expression -> MACRO = expression .)
    FUNCTION        reduce using rule 2 (expression -> MACRO = expression .)
    %               reduce using rule 2 (expression -> MACRO = expression .)
    {               reduce using rule 2 (expression -> MACRO = expression .)
    $end            reduce using rule 2 (expression -> MACRO = expression .)
    }               reduce using rule 2 (expression -> MACRO = expression .)
    )               reduce using rule 2 (expression -> MACRO = expression .)
    AND             reduce using rule 2 (expression -> MACRO = expression .)
    OR              reduce using rule 2 (expression -> MACRO = expression .)
    ,               reduce using rule 2 (expression -> MACRO = expression .)
    +               reduce using rule 2 (expression -> MACRO = expression .)
    *               reduce using rule 2 (expression -> MACRO = expression .)
    /               reduce using rule 2 (expression -> MACRO = expression .)
    LT              reduce using rule 2 (expression -> MACRO = expression .)
    LE              reduce using rule 2 (expression -> MACRO = expression .)
    GT              reduce using rule 2 (expression -> MACRO = expression .)
    GE              reduce using rule 2 (expression -> MACRO = expression .)
    EE              reduce using rule 2 (expression -> MACRO = expression .)
    NE              reduce using rule 2 (expression -> MACRO = expression .)
    ]               reduce using rule 2 (expression -> MACRO = expression .)
    #               reduce using rule 2 (expression -> MACRO = expression .)


state 57

    (43) comp -> comp AND comp .
    (43) comp -> comp . AND comp
    (44) comp -> comp . OR comp

    AND             reduce using rule 43 (comp -> comp AND comp .)
    OR              reduce using rule 43 (comp -> comp AND comp .)
    BREAK           reduce using rule 43 (comp -> comp AND comp .)
    RETURN          reduce using rule 43 (comp -> comp AND comp .)
    PASS            reduce using rule 43 (comp -> comp AND comp .)
    MACRO           reduce using rule 43 (comp -> comp AND comp .)
    IF              reduce using rule 43 (comp -> comp AND comp .)
    NOT             reduce using rule 43 (comp -> comp AND comp .)
    MIN             reduce using rule 43 (comp -> comp AND comp .)
    MAX             reduce using rule 43 (comp -> comp AND comp .)
    VARIABLE        reduce using rule 43 (comp -> comp AND comp .)
    -               reduce using rule 43 (comp -> comp AND comp .)
    (               reduce using rule 43 (comp -> comp AND comp .)
    NUMBER          reduce using rule 43 (comp -> comp AND comp .)
    BOOLEAN         reduce using rule 43 (comp -> comp AND comp .)
    STRING          reduce using rule 43 (comp -> comp AND comp .)
    WORD            reduce using rule 43 (comp -> comp AND comp .)
    FUNCTION        reduce using rule 43 (comp -> comp AND comp .)
    %               reduce using rule 43 (comp -> comp AND comp .)
    {               reduce using rule 43 (comp -> comp AND comp .)
    $end            reduce using rule 43 (comp -> comp AND comp .)
    }               reduce using rule 43 (comp -> comp AND comp .)
    )               reduce using rule 43 (comp -> comp AND comp .)
    ,               reduce using rule 43 (comp -> comp AND comp .)
    +               reduce using rule 43 (comp -> comp AND comp .)
    *               reduce using rule 43 (comp -> comp AND comp .)
    /               reduce using rule 43 (comp -> comp AND comp .)
    LT              reduce using rule 43 (comp -> comp AND comp .)
    LE              reduce using rule 43 (comp -> comp AND comp .)
    GT              reduce using rule 43 (comp -> comp AND comp .)
    GE              reduce using rule 43 (comp -> comp AND comp .)
    EE              reduce using rule 43 (comp -> comp AND comp .)
    NE              reduce using rule 43 (comp -> comp AND comp .)
    ]               reduce using rule 43 (comp -> comp AND comp .)
    #               reduce using rule 43 (comp -> comp AND comp .)

  ! AND             [ shift and go to state 32 ]
  ! OR              [ shift and go to state 33 ]


state 58

    (44) comp -> comp OR comp .
    (43) comp -> comp . AND comp
    (44) comp -> comp . OR comp

    AND             reduce using rule 44 (comp -> comp OR comp .)
    OR              reduce using rule 44 (comp -> comp OR comp .)
    BREAK           reduce using rule 44 (comp -> comp OR comp .)
    RETURN          reduce using rule 44 (comp -> comp OR comp .)
    PASS            reduce using rule 44 (comp -> comp OR comp .)
    MACRO           reduce using rule 44 (comp -> comp OR comp .)
    IF              reduce using rule 44 (comp -> comp OR comp .)
    NOT             reduce using rule 44 (comp -> comp OR comp .)
    MIN             reduce using rule 44 (comp -> comp OR comp .)
    MAX             reduce using rule 44 (comp -> comp OR comp .)
    VARIABLE        reduce using rule 44 (comp -> comp OR comp .)
    -               reduce using rule 44 (comp -> comp OR comp .)
    (               reduce using rule 44 (comp -> comp OR comp .)
    NUMBER          reduce using rule 44 (comp -> comp OR comp .)
    BOOLEAN         reduce using rule 44 (comp -> comp OR comp .)
    STRING          reduce using rule 44 (comp -> comp OR comp .)
    WORD            reduce using rule 44 (comp -> comp OR comp .)
    FUNCTION        reduce using rule 44 (comp -> comp OR comp .)
    %               reduce using rule 44 (comp -> comp OR comp .)
    {               reduce using rule 44 (comp -> comp OR comp .)
    $end            reduce using rule 44 (comp -> comp OR comp .)
    }               reduce using rule 44 (comp -> comp OR comp .)
    )               reduce using rule 44 (comp -> comp OR comp .)
    ,               reduce using rule 44 (comp -> comp OR comp .)
    +               reduce using rule 44 (comp -> comp OR comp .)
    *               reduce using rule 44 (comp -> comp OR comp .)
    /               reduce using rule 44 (comp -> comp OR comp .)
    LT              reduce using rule 44 (comp -> comp OR comp .)
    LE              reduce using rule 44 (comp -> comp OR comp .)
    GT              reduce using rule 44 (comp -> comp OR comp .)
    GE              reduce using rule 44 (comp -> comp OR comp .)
    EE              reduce using rule 44 (comp -> comp OR comp .)
    NE              reduce using rule 44 (comp -> comp OR comp .)
    ]               reduce using rule 44 (comp -> comp OR comp .)
    #               reduce using rule 44 (comp -> comp OR comp .)

  ! AND             [ shift and go to state 32 ]
  ! OR              [ shift and go to state 33 ]


state 59

    (10) if_condition -> IF ( expression . ) scope elif_branch
    (11) if_condition -> IF ( expression . ) scope else_branch
    (12) if_condition -> IF ( expression . ) scope

    )               shift and go to state 87


state 60

    (57) atom -> ( expression ) .

    +               reduce using rule 57 (atom -> ( expression ) .)
    -               reduce using rule 57 (atom -> ( expression ) .)
    *               reduce using rule 57 (atom -> ( expression ) .)
    /               reduce using rule 57 (atom -> ( expression ) .)
    LT              reduce using rule 57 (atom -> ( expression ) .)
    LE              reduce using rule 57 (atom -> ( expression ) .)
    GT              reduce using rule 57 (atom -> ( expression ) .)
    GE              reduce using rule 57 (atom -> ( expression ) .)
    EE              reduce using rule 57 (atom -> ( expression ) .)
    NE              reduce using rule 57 (atom -> ( expression ) .)
    AND             reduce using rule 57 (atom -> ( expression ) .)
    OR              reduce using rule 57 (atom -> ( expression ) .)
    BREAK           reduce using rule 57 (atom -> ( expression ) .)
    RETURN          reduce using rule 57 (atom -> ( expression ) .)
    PASS            reduce using rule 57 (atom -> ( expression ) .)
    MACRO           reduce using rule 57 (atom -> ( expression ) .)
    IF              reduce using rule 57 (atom -> ( expression ) .)
    NOT             reduce using rule 57 (atom -> ( expression ) .)
    MIN             reduce using rule 57 (atom -> ( expression ) .)
    MAX             reduce using rule 57 (atom -> ( expression ) .)
    VARIABLE        reduce using rule 57 (atom -> ( expression ) .)
    (               reduce using rule 57 (atom -> ( expression ) .)
    NUMBER          reduce using rule 57 (atom -> ( expression ) .)
    BOOLEAN         reduce using rule 57 (atom -> ( expression ) .)
    STRING          reduce using rule 57 (atom -> ( expression ) .)
    WORD            reduce using rule 57 (atom -> ( expression ) .)
    FUNCTION        reduce using rule 57 (atom -> ( expression ) .)
    %               reduce using rule 57 (atom -> ( expression ) .)
    {               reduce using rule 57 (atom -> ( expression ) .)
    $end            reduce using rule 57 (atom -> ( expression ) .)
    }               reduce using rule 57 (atom -> ( expression ) .)
    )               reduce using rule 57 (atom -> ( expression ) .)
    ,               reduce using rule 57 (atom -> ( expression ) .)
    ]               reduce using rule 57 (atom -> ( expression ) .)
    #               reduce using rule 57 (atom -> ( expression ) .)


state 61

    (37) comp -> arith LT arith .

    AND             reduce using rule 37 (comp -> arith LT arith .)
    OR              reduce using rule 37 (comp -> arith LT arith .)
    BREAK           reduce using rule 37 (comp -> arith LT arith .)
    RETURN          reduce using rule 37 (comp -> arith LT arith .)
    PASS            reduce using rule 37 (comp -> arith LT arith .)
    MACRO           reduce using rule 37 (comp -> arith LT arith .)
    IF              reduce using rule 37 (comp -> arith LT arith .)
    NOT             reduce using rule 37 (comp -> arith LT arith .)
    MIN             reduce using rule 37 (comp -> arith LT arith .)
    MAX             reduce using rule 37 (comp -> arith LT arith .)
    VARIABLE        reduce using rule 37 (comp -> arith LT arith .)
    -               reduce using rule 37 (comp -> arith LT arith .)
    (               reduce using rule 37 (comp -> arith LT arith .)
    NUMBER          reduce using rule 37 (comp -> arith LT arith .)
    BOOLEAN         reduce using rule 37 (comp -> arith LT arith .)
    STRING          reduce using rule 37 (comp -> arith LT arith .)
    WORD            reduce using rule 37 (comp -> arith LT arith .)
    FUNCTION        reduce using rule 37 (comp -> arith LT arith .)
    %               reduce using rule 37 (comp -> arith LT arith .)
    {               reduce using rule 37 (comp -> arith LT arith .)
    $end            reduce using rule 37 (comp -> arith LT arith .)
    }               reduce using rule 37 (comp -> arith LT arith .)
    )               reduce using rule 37 (comp -> arith LT arith .)
    ,               reduce using rule 37 (comp -> arith LT arith .)
    +               reduce using rule 37 (comp -> arith LT arith .)
    *               reduce using rule 37 (comp -> arith LT arith .)
    /               reduce using rule 37 (comp -> arith LT arith .)
    LT              reduce using rule 37 (comp -> arith LT arith .)
    LE              reduce using rule 37 (comp -> arith LT arith .)
    GT              reduce using rule 37 (comp -> arith LT arith .)
    GE              reduce using rule 37 (comp -> arith LT arith .)
    EE              reduce using rule 37 (comp -> arith LT arith .)
    NE              reduce using rule 37 (comp -> arith LT arith .)
    ]               reduce using rule 37 (comp -> arith LT arith .)
    #               reduce using rule 37 (comp -> arith LT arith .)


state 62

    (38) comp -> arith LE arith .

    AND             reduce using rule 38 (comp -> arith LE arith .)
    OR              reduce using rule 38 (comp -> arith LE arith .)
    BREAK           reduce using rule 38 (comp -> arith LE arith .)
    RETURN          reduce using rule 38 (comp -> arith LE arith .)
    PASS            reduce using rule 38 (comp -> arith LE arith .)
    MACRO           reduce using rule 38 (comp -> arith LE arith .)
    IF              reduce using rule 38 (comp -> arith LE arith .)
    NOT             reduce using rule 38 (comp -> arith LE arith .)
    MIN             reduce using rule 38 (comp -> arith LE arith .)
    MAX             reduce using rule 38 (comp -> arith LE arith .)
    VARIABLE        reduce using rule 38 (comp -> arith LE arith .)
    -               reduce using rule 38 (comp -> arith LE arith .)
    (               reduce using rule 38 (comp -> arith LE arith .)
    NUMBER          reduce using rule 38 (comp -> arith LE arith .)
    BOOLEAN         reduce using rule 38 (comp -> arith LE arith .)
    STRING          reduce using rule 38 (comp -> arith LE arith .)
    WORD            reduce using rule 38 (comp -> arith LE arith .)
    FUNCTION        reduce using rule 38 (comp -> arith LE arith .)
    %               reduce using rule 38 (comp -> arith LE arith .)
    {               reduce using rule 38 (comp -> arith LE arith .)
    $end            reduce using rule 38 (comp -> arith LE arith .)
    }               reduce using rule 38 (comp -> arith LE arith .)
    )               reduce using rule 38 (comp -> arith LE arith .)
    ,               reduce using rule 38 (comp -> arith LE arith .)
    +               reduce using rule 38 (comp -> arith LE arith .)
    *               reduce using rule 38 (comp -> arith LE arith .)
    /               reduce using rule 38 (comp -> arith LE arith .)
    LT              reduce using rule 38 (comp -> arith LE arith .)
    LE              reduce using rule 38 (comp -> arith LE arith .)
    GT              reduce using rule 38 (comp -> arith LE arith .)
    GE              reduce using rule 38 (comp -> arith LE arith .)
    EE              reduce using rule 38 (comp -> arith LE arith .)
    NE              reduce using rule 38 (comp -> arith LE arith .)
    ]               reduce using rule 38 (comp -> arith LE arith .)
    #               reduce using rule 38 (comp -> arith LE arith .)


state 63

    (39) comp -> arith GT arith .

    AND             reduce using rule 39 (comp -> arith GT arith .)
    OR              reduce using rule 39 (comp -> arith GT arith .)
    BREAK           reduce using rule 39 (comp -> arith GT arith .)
    RETURN          reduce using rule 39 (comp -> arith GT arith .)
    PASS            reduce using rule 39 (comp -> arith GT arith .)
    MACRO           reduce using rule 39 (comp -> arith GT arith .)
    IF              reduce using rule 39 (comp -> arith GT arith .)
    NOT             reduce using rule 39 (comp -> arith GT arith .)
    MIN             reduce using rule 39 (comp -> arith GT arith .)
    MAX             reduce using rule 39 (comp -> arith GT arith .)
    VARIABLE        reduce using rule 39 (comp -> arith GT arith .)
    -               reduce using rule 39 (comp -> arith GT arith .)
    (               reduce using rule 39 (comp -> arith GT arith .)
    NUMBER          reduce using rule 39 (comp -> arith GT arith .)
    BOOLEAN         reduce using rule 39 (comp -> arith GT arith .)
    STRING          reduce using rule 39 (comp -> arith GT arith .)
    WORD            reduce using rule 39 (comp -> arith GT arith .)
    FUNCTION        reduce using rule 39 (comp -> arith GT arith .)
    %               reduce using rule 39 (comp -> arith GT arith .)
    {               reduce using rule 39 (comp -> arith GT arith .)
    $end            reduce using rule 39 (comp -> arith GT arith .)
    }               reduce using rule 39 (comp -> arith GT arith .)
    )               reduce using rule 39 (comp -> arith GT arith .)
    ,               reduce using rule 39 (comp -> arith GT arith .)
    +               reduce using rule 39 (comp -> arith GT arith .)
    *               reduce using rule 39 (comp -> arith GT arith .)
    /               reduce using rule 39 (comp -> arith GT arith .)
    LT              reduce using rule 39 (comp -> arith GT arith .)
    LE              reduce using rule 39 (comp -> arith GT arith .)
    GT              reduce using rule 39 (comp -> arith GT arith .)
    GE              reduce using rule 39 (comp -> arith GT arith .)
    EE              reduce using rule 39 (comp -> arith GT arith .)
    NE              reduce using rule 39 (comp -> arith GT arith .)
    ]               reduce using rule 39 (comp -> arith GT arith .)
    #               reduce using rule 39 (comp -> arith GT arith .)


state 64

    (40) comp -> arith GE arith .

    AND             reduce using rule 40 (comp -> arith GE arith .)
    OR              reduce using rule 40 (comp -> arith GE arith .)
    BREAK           reduce using rule 40 (comp -> arith GE arith .)
    RETURN          reduce using rule 40 (comp -> arith GE arith .)
    PASS            reduce using rule 40 (comp -> arith GE arith .)
    MACRO           reduce using rule 40 (comp -> arith GE arith .)
    IF              reduce using rule 40 (comp -> arith GE arith .)
    NOT             reduce using rule 40 (comp -> arith GE arith .)
    MIN             reduce using rule 40 (comp -> arith GE arith .)
    MAX             reduce using rule 40 (comp -> arith GE arith .)
    VARIABLE        reduce using rule 40 (comp -> arith GE arith .)
    -               reduce using rule 40 (comp -> arith GE arith .)
    (               reduce using rule 40 (comp -> arith GE arith .)
    NUMBER          reduce using rule 40 (comp -> arith GE arith .)
    BOOLEAN         reduce using rule 40 (comp -> arith GE arith .)
    STRING          reduce using rule 40 (comp -> arith GE arith .)
    WORD            reduce using rule 40 (comp -> arith GE arith .)
    FUNCTION        reduce using rule 40 (comp -> arith GE arith .)
    %               reduce using rule 40 (comp -> arith GE arith .)
    {               reduce using rule 40 (comp -> arith GE arith .)
    $end            reduce using rule 40 (comp -> arith GE arith .)
    }               reduce using rule 40 (comp -> arith GE arith .)
    )               reduce using rule 40 (comp -> arith GE arith .)
    ,               reduce using rule 40 (comp -> arith GE arith .)
    +               reduce using rule 40 (comp -> arith GE arith .)
    *               reduce using rule 40 (comp -> arith GE arith .)
    /               reduce using rule 40 (comp -> arith GE arith .)
    LT              reduce using rule 40 (comp -> arith GE arith .)
    LE              reduce using rule 40 (comp -> arith GE arith .)
    GT              reduce using rule 40 (comp -> arith GE arith .)
    GE              reduce using rule 40 (comp -> arith GE arith .)
    EE              reduce using rule 40 (comp -> arith GE arith .)
    NE              reduce using rule 40 (comp -> arith GE arith .)
    ]               reduce using rule 40 (comp -> arith GE arith .)
    #               reduce using rule 40 (comp -> arith GE arith .)


state 65

    (41) comp -> arith EE arith .

    AND             reduce using rule 41 (comp -> arith EE arith .)
    OR              reduce using rule 41 (comp -> arith EE arith .)
    BREAK           reduce using rule 41 (comp -> arith EE arith .)
    RETURN          reduce using rule 41 (comp -> arith EE arith .)
    PASS            reduce using rule 41 (comp -> arith EE arith .)
    MACRO           reduce using rule 41 (comp -> arith EE arith .)
    IF              reduce using rule 41 (comp -> arith EE arith .)
    NOT             reduce using rule 41 (comp -> arith EE arith .)
    MIN             reduce using rule 41 (comp -> arith EE arith .)
    MAX             reduce using rule 41 (comp -> arith EE arith .)
    VARIABLE        reduce using rule 41 (comp -> arith EE arith .)
    -               reduce using rule 41 (comp -> arith EE arith .)
    (               reduce using rule 41 (comp -> arith EE arith .)
    NUMBER          reduce using rule 41 (comp -> arith EE arith .)
    BOOLEAN         reduce using rule 41 (comp -> arith EE arith .)
    STRING          reduce using rule 41 (comp -> arith EE arith .)
    WORD            reduce using rule 41 (comp -> arith EE arith .)
    FUNCTION        reduce using rule 41 (comp -> arith EE arith .)
    %               reduce using rule 41 (comp -> arith EE arith .)
    {               reduce using rule 41 (comp -> arith EE arith .)
    $end            reduce using rule 41 (comp -> arith EE arith .)
    }               reduce using rule 41 (comp -> arith EE arith .)
    )               reduce using rule 41 (comp -> arith EE arith .)
    ,               reduce using rule 41 (comp -> arith EE arith .)
    +               reduce using rule 41 (comp -> arith EE arith .)
    *               reduce using rule 41 (comp -> arith EE arith .)
    /               reduce using rule 41 (comp -> arith EE arith .)
    LT              reduce using rule 41 (comp -> arith EE arith .)
    LE              reduce using rule 41 (comp -> arith EE arith .)
    GT              reduce using rule 41 (comp -> arith EE arith .)
    GE              reduce using rule 41 (comp -> arith EE arith .)
    EE              reduce using rule 41 (comp -> arith EE arith .)
    NE              reduce using rule 41 (comp -> arith EE arith .)
    ]               reduce using rule 41 (comp -> arith EE arith .)
    #               reduce using rule 41 (comp -> arith EE arith .)


state 66

    (42) comp -> arith NE arith .

    AND             reduce using rule 42 (comp -> arith NE arith .)
    OR              reduce using rule 42 (comp -> arith NE arith .)
    BREAK           reduce using rule 42 (comp -> arith NE arith .)
    RETURN          reduce using rule 42 (comp -> arith NE arith .)
    PASS            reduce using rule 42 (comp -> arith NE arith .)
    MACRO           reduce using rule 42 (comp -> arith NE arith .)
    IF              reduce using rule 42 (comp -> arith NE arith .)
    NOT             reduce using rule 42 (comp -> arith NE arith .)
    MIN             reduce using rule 42 (comp -> arith NE arith .)
    MAX             reduce using rule 42 (comp -> arith NE arith .)
    VARIABLE        reduce using rule 42 (comp -> arith NE arith .)
    -               reduce using rule 42 (comp -> arith NE arith .)
    (               reduce using rule 42 (comp -> arith NE arith .)
    NUMBER          reduce using rule 42 (comp -> arith NE arith .)
    BOOLEAN         reduce using rule 42 (comp -> arith NE arith .)
    STRING          reduce using rule 42 (comp -> arith NE arith .)
    WORD            reduce using rule 42 (comp -> arith NE arith .)
    FUNCTION        reduce using rule 42 (comp -> arith NE arith .)
    %               reduce using rule 42 (comp -> arith NE arith .)
    {               reduce using rule 42 (comp -> arith NE arith .)
    $end            reduce using rule 42 (comp -> arith NE arith .)
    }               reduce using rule 42 (comp -> arith NE arith .)
    )               reduce using rule 42 (comp -> arith NE arith .)
    ,               reduce using rule 42 (comp -> arith NE arith .)
    +               reduce using rule 42 (comp -> arith NE arith .)
    *               reduce using rule 42 (comp -> arith NE arith .)
    /               reduce using rule 42 (comp -> arith NE arith .)
    LT              reduce using rule 42 (comp -> arith NE arith .)
    LE              reduce using rule 42 (comp -> arith NE arith .)
    GT              reduce using rule 42 (comp -> arith NE arith .)
    GE              reduce using rule 42 (comp -> arith NE arith .)
    EE              reduce using rule 42 (comp -> arith NE arith .)
    NE              reduce using rule 42 (comp -> arith NE arith .)
    ]               reduce using rule 42 (comp -> arith NE arith .)
    #               reduce using rule 42 (comp -> arith NE arith .)


state 67

    (46) arith -> atom + atom .

    LT              reduce using rule 46 (arith -> atom + atom .)
    LE              reduce using rule 46 (arith -> atom + atom .)
    GT              reduce using rule 46 (arith -> atom + atom .)
    GE              reduce using rule 46 (arith -> atom + atom .)
    EE              reduce using rule 46 (arith -> atom + atom .)
    NE              reduce using rule 46 (arith -> atom + atom .)
    AND             reduce using rule 46 (arith -> atom + atom .)
    OR              reduce using rule 46 (arith -> atom + atom .)
    BREAK           reduce using rule 46 (arith -> atom + atom .)
    RETURN          reduce using rule 46 (arith -> atom + atom .)
    PASS            reduce using rule 46 (arith -> atom + atom .)
    MACRO           reduce using rule 46 (arith -> atom + atom .)
    IF              reduce using rule 46 (arith -> atom + atom .)
    NOT             reduce using rule 46 (arith -> atom + atom .)
    MIN             reduce using rule 46 (arith -> atom + atom .)
    MAX             reduce using rule 46 (arith -> atom + atom .)
    VARIABLE        reduce using rule 46 (arith -> atom + atom .)
    -               reduce using rule 46 (arith -> atom + atom .)
    (               reduce using rule 46 (arith -> atom + atom .)
    NUMBER          reduce using rule 46 (arith -> atom + atom .)
    BOOLEAN         reduce using rule 46 (arith -> atom + atom .)
    STRING          reduce using rule 46 (arith -> atom + atom .)
    WORD            reduce using rule 46 (arith -> atom + atom .)
    FUNCTION        reduce using rule 46 (arith -> atom + atom .)
    %               reduce using rule 46 (arith -> atom + atom .)
    {               reduce using rule 46 (arith -> atom + atom .)
    $end            reduce using rule 46 (arith -> atom + atom .)
    }               reduce using rule 46 (arith -> atom + atom .)
    )               reduce using rule 46 (arith -> atom + atom .)
    ,               reduce using rule 46 (arith -> atom + atom .)
    +               reduce using rule 46 (arith -> atom + atom .)
    *               reduce using rule 46 (arith -> atom + atom .)
    /               reduce using rule 46 (arith -> atom + atom .)
    ]               reduce using rule 46 (arith -> atom + atom .)
    #               reduce using rule 46 (arith -> atom + atom .)


state 68

    (47) arith -> atom - atom .

    LT              reduce using rule 47 (arith -> atom - atom .)
    LE              reduce using rule 47 (arith -> atom - atom .)
    GT              reduce using rule 47 (arith -> atom - atom .)
    GE              reduce using rule 47 (arith -> atom - atom .)
    EE              reduce using rule 47 (arith -> atom - atom .)
    NE              reduce using rule 47 (arith -> atom - atom .)
    AND             reduce using rule 47 (arith -> atom - atom .)
    OR              reduce using rule 47 (arith -> atom - atom .)
    BREAK           reduce using rule 47 (arith -> atom - atom .)
    RETURN          reduce using rule 47 (arith -> atom - atom .)
    PASS            reduce using rule 47 (arith -> atom - atom .)
    MACRO           reduce using rule 47 (arith -> atom - atom .)
    IF              reduce using rule 47 (arith -> atom - atom .)
    NOT             reduce using rule 47 (arith -> atom - atom .)
    MIN             reduce using rule 47 (arith -> atom - atom .)
    MAX             reduce using rule 47 (arith -> atom - atom .)
    VARIABLE        reduce using rule 47 (arith -> atom - atom .)
    -               reduce using rule 47 (arith -> atom - atom .)
    (               reduce using rule 47 (arith -> atom - atom .)
    NUMBER          reduce using rule 47 (arith -> atom - atom .)
    BOOLEAN         reduce using rule 47 (arith -> atom - atom .)
    STRING          reduce using rule 47 (arith -> atom - atom .)
    WORD            reduce using rule 47 (arith -> atom - atom .)
    FUNCTION        reduce using rule 47 (arith -> atom - atom .)
    %               reduce using rule 47 (arith -> atom - atom .)
    {               reduce using rule 47 (arith -> atom - atom .)
    $end            reduce using rule 47 (arith -> atom - atom .)
    }               reduce using rule 47 (arith -> atom - atom .)
    )               reduce using rule 47 (arith -> atom - atom .)
    ,               reduce using rule 47 (arith -> atom - atom .)
    +               reduce using rule 47 (arith -> atom - atom .)
    *               reduce using rule 47 (arith -> atom - atom .)
    /               reduce using rule 47 (arith -> atom - atom .)
    ]               reduce using rule 47 (arith -> atom - atom .)
    #               reduce using rule 47 (arith -> atom - atom .)


state 69

    (48) arith -> atom * atom .

    LT              reduce using rule 48 (arith -> atom * atom .)
    LE              reduce using rule 48 (arith -> atom * atom .)
    GT              reduce using rule 48 (arith -> atom * atom .)
    GE              reduce using rule 48 (arith -> atom * atom .)
    EE              reduce using rule 48 (arith -> atom * atom .)
    NE              reduce using rule 48 (arith -> atom * atom .)
    AND             reduce using rule 48 (arith -> atom * atom .)
    OR              reduce using rule 48 (arith -> atom * atom .)
    BREAK           reduce using rule 48 (arith -> atom * atom .)
    RETURN          reduce using rule 48 (arith -> atom * atom .)
    PASS            reduce using rule 48 (arith -> atom * atom .)
    MACRO           reduce using rule 48 (arith -> atom * atom .)
    IF              reduce using rule 48 (arith -> atom * atom .)
    NOT             reduce using rule 48 (arith -> atom * atom .)
    MIN             reduce using rule 48 (arith -> atom * atom .)
    MAX             reduce using rule 48 (arith -> atom * atom .)
    VARIABLE        reduce using rule 48 (arith -> atom * atom .)
    -               reduce using rule 48 (arith -> atom * atom .)
    (               reduce using rule 48 (arith -> atom * atom .)
    NUMBER          reduce using rule 48 (arith -> atom * atom .)
    BOOLEAN         reduce using rule 48 (arith -> atom * atom .)
    STRING          reduce using rule 48 (arith -> atom * atom .)
    WORD            reduce using rule 48 (arith -> atom * atom .)
    FUNCTION        reduce using rule 48 (arith -> atom * atom .)
    %               reduce using rule 48 (arith -> atom * atom .)
    {               reduce using rule 48 (arith -> atom * atom .)
    $end            reduce using rule 48 (arith -> atom * atom .)
    }               reduce using rule 48 (arith -> atom * atom .)
    )               reduce using rule 48 (arith -> atom * atom .)
    ,               reduce using rule 48 (arith -> atom * atom .)
    +               reduce using rule 48 (arith -> atom * atom .)
    *               reduce using rule 48 (arith -> atom * atom .)
    /               reduce using rule 48 (arith -> atom * atom .)
    ]               reduce using rule 48 (arith -> atom * atom .)
    #               reduce using rule 48 (arith -> atom * atom .)


state 70

    (49) arith -> atom / atom .

    LT              reduce using rule 49 (arith -> atom / atom .)
    LE              reduce using rule 49 (arith -> atom / atom .)
    GT              reduce using rule 49 (arith -> atom / atom .)
    GE              reduce using rule 49 (arith -> atom / atom .)
    EE              reduce using rule 49 (arith -> atom / atom .)
    NE              reduce using rule 49 (arith -> atom / atom .)
    AND             reduce using rule 49 (arith -> atom / atom .)
    OR              reduce using rule 49 (arith -> atom / atom .)
    BREAK           reduce using rule 49 (arith -> atom / atom .)
    RETURN          reduce using rule 49 (arith -> atom / atom .)
    PASS            reduce using rule 49 (arith -> atom / atom .)
    MACRO           reduce using rule 49 (arith -> atom / atom .)
    IF              reduce using rule 49 (arith -> atom / atom .)
    NOT             reduce using rule 49 (arith -> atom / atom .)
    MIN             reduce using rule 49 (arith -> atom / atom .)
    MAX             reduce using rule 49 (arith -> atom / atom .)
    VARIABLE        reduce using rule 49 (arith -> atom / atom .)
    -               reduce using rule 49 (arith -> atom / atom .)
    (               reduce using rule 49 (arith -> atom / atom .)
    NUMBER          reduce using rule 49 (arith -> atom / atom .)
    BOOLEAN         reduce using rule 49 (arith -> atom / atom .)
    STRING          reduce using rule 49 (arith -> atom / atom .)
    WORD            reduce using rule 49 (arith -> atom / atom .)
    FUNCTION        reduce using rule 49 (arith -> atom / atom .)
    %               reduce using rule 49 (arith -> atom / atom .)
    {               reduce using rule 49 (arith -> atom / atom .)
    $end            reduce using rule 49 (arith -> atom / atom .)
    }               reduce using rule 49 (arith -> atom / atom .)
    )               reduce using rule 49 (arith -> atom / atom .)
    ,               reduce using rule 49 (arith -> atom / atom .)
    +               reduce using rule 49 (arith -> atom / atom .)
    *               reduce using rule 49 (arith -> atom / atom .)
    /               reduce using rule 49 (arith -> atom / atom .)
    ]               reduce using rule 49 (arith -> atom / atom .)
    #               reduce using rule 49 (arith -> atom / atom .)


state 71

    (55) arith -> MIN ( comma_expressions . )

    )               shift and go to state 88


state 72

    (52) comma_expressions -> expression . , comma_expressions
    (53) comma_expressions -> expression . ,
    (54) comma_expressions -> expression .

    ,               shift and go to state 89
    )               reduce using rule 54 (comma_expressions -> expression .)
    ]               reduce using rule 54 (comma_expressions -> expression .)


state 73

    (56) arith -> MAX ( comma_expressions . )

    )               shift and go to state 90


state 74

    (4) atom -> VARIABLE = expression .

    +               reduce using rule 4 (atom -> VARIABLE = expression .)
    -               reduce using rule 4 (atom -> VARIABLE = expression .)
    *               reduce using rule 4 (atom -> VARIABLE = expression .)
    /               reduce using rule 4 (atom -> VARIABLE = expression .)
    LT              reduce using rule 4 (atom -> VARIABLE = expression .)
    LE              reduce using rule 4 (atom -> VARIABLE = expression .)
    GT              reduce using rule 4 (atom -> VARIABLE = expression .)
    GE              reduce using rule 4 (atom -> VARIABLE = expression .)
    EE              reduce using rule 4 (atom -> VARIABLE = expression .)
    NE              reduce using rule 4 (atom -> VARIABLE = expression .)
    AND             reduce using rule 4 (atom -> VARIABLE = expression .)
    OR              reduce using rule 4 (atom -> VARIABLE = expression .)
    BREAK           reduce using rule 4 (atom -> VARIABLE = expression .)
    RETURN          reduce using rule 4 (atom -> VARIABLE = expression .)
    PASS            reduce using rule 4 (atom -> VARIABLE = expression .)
    MACRO           reduce using rule 4 (atom -> VARIABLE = expression .)
    IF              reduce using rule 4 (atom -> VARIABLE = expression .)
    NOT             reduce using rule 4 (atom -> VARIABLE = expression .)
    MIN             reduce using rule 4 (atom -> VARIABLE = expression .)
    MAX             reduce using rule 4 (atom -> VARIABLE = expression .)
    VARIABLE        reduce using rule 4 (atom -> VARIABLE = expression .)
    (               reduce using rule 4 (atom -> VARIABLE = expression .)
    NUMBER          reduce using rule 4 (atom -> VARIABLE = expression .)
    BOOLEAN         reduce using rule 4 (atom -> VARIABLE = expression .)
    STRING          reduce using rule 4 (atom -> VARIABLE = expression .)
    WORD            reduce using rule 4 (atom -> VARIABLE = expression .)
    FUNCTION        reduce using rule 4 (atom -> VARIABLE = expression .)
    %               reduce using rule 4 (atom -> VARIABLE = expression .)
    {               reduce using rule 4 (atom -> VARIABLE = expression .)
    $end            reduce using rule 4 (atom -> VARIABLE = expression .)
    }               reduce using rule 4 (atom -> VARIABLE = expression .)
    )               reduce using rule 4 (atom -> VARIABLE = expression .)
    ,               reduce using rule 4 (atom -> VARIABLE = expression .)
    ]               reduce using rule 4 (atom -> VARIABLE = expression .)
    #               reduce using rule 4 (atom -> VARIABLE = expression .)


state 75

    (13) function_call -> FUNCTION parameters scope .

    +               reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    -               reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    *               reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    /               reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    LT              reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    LE              reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    GT              reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    GE              reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    EE              reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    NE              reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    AND             reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    OR              reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    BREAK           reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    RETURN          reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    PASS            reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    MACRO           reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    IF              reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    NOT             reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    MIN             reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    MAX             reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    VARIABLE        reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    (               reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    NUMBER          reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    BOOLEAN         reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    STRING          reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    WORD            reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    FUNCTION        reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    %               reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    {               reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    $end            reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    }               reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    )               reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    ,               reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    ]               reduce using rule 13 (function_call -> FUNCTION parameters scope .)
    #               reduce using rule 13 (function_call -> FUNCTION parameters scope .)


state 76

    (14) function_call -> FUNCTION parameters tag_list .

    +               reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    -               reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    *               reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    /               reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    LT              reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    LE              reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    GT              reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    GE              reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    EE              reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    NE              reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    AND             reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    OR              reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    BREAK           reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    RETURN          reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    PASS            reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    MACRO           reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    IF              reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    NOT             reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    MIN             reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    MAX             reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    VARIABLE        reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    (               reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    NUMBER          reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    BOOLEAN         reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    STRING          reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    WORD            reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    FUNCTION        reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    %               reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    {               reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    $end            reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    }               reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    )               reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    ,               reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    ]               reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)
    #               reduce using rule 14 (function_call -> FUNCTION parameters tag_list .)


state 77

    (18) tag_list -> tag . # scope tag_list
    (19) tag_list -> tag . # scope

    #               shift and go to state 91


state 78

    (17) tag -> TAG . expression
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    expression                     shift and go to state 92
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 79

    (23) parameters -> ( param_element . )

    )               shift and go to state 93


state 80

    (24) parameters -> ( ) .

    {               reduce using rule 24 (parameters -> ( ) .)
    TAG             reduce using rule 24 (parameters -> ( ) .)
    +               reduce using rule 24 (parameters -> ( ) .)
    -               reduce using rule 24 (parameters -> ( ) .)
    *               reduce using rule 24 (parameters -> ( ) .)
    /               reduce using rule 24 (parameters -> ( ) .)
    LT              reduce using rule 24 (parameters -> ( ) .)
    LE              reduce using rule 24 (parameters -> ( ) .)
    GT              reduce using rule 24 (parameters -> ( ) .)
    GE              reduce using rule 24 (parameters -> ( ) .)
    EE              reduce using rule 24 (parameters -> ( ) .)
    NE              reduce using rule 24 (parameters -> ( ) .)
    AND             reduce using rule 24 (parameters -> ( ) .)
    OR              reduce using rule 24 (parameters -> ( ) .)
    BREAK           reduce using rule 24 (parameters -> ( ) .)
    RETURN          reduce using rule 24 (parameters -> ( ) .)
    PASS            reduce using rule 24 (parameters -> ( ) .)
    MACRO           reduce using rule 24 (parameters -> ( ) .)
    IF              reduce using rule 24 (parameters -> ( ) .)
    NOT             reduce using rule 24 (parameters -> ( ) .)
    MIN             reduce using rule 24 (parameters -> ( ) .)
    MAX             reduce using rule 24 (parameters -> ( ) .)
    VARIABLE        reduce using rule 24 (parameters -> ( ) .)
    (               reduce using rule 24 (parameters -> ( ) .)
    NUMBER          reduce using rule 24 (parameters -> ( ) .)
    BOOLEAN         reduce using rule 24 (parameters -> ( ) .)
    STRING          reduce using rule 24 (parameters -> ( ) .)
    WORD            reduce using rule 24 (parameters -> ( ) .)
    FUNCTION        reduce using rule 24 (parameters -> ( ) .)
    %               reduce using rule 24 (parameters -> ( ) .)
    $end            reduce using rule 24 (parameters -> ( ) .)
    }               reduce using rule 24 (parameters -> ( ) .)
    )               reduce using rule 24 (parameters -> ( ) .)
    ,               reduce using rule 24 (parameters -> ( ) .)
    ]               reduce using rule 24 (parameters -> ( ) .)
    #               reduce using rule 24 (parameters -> ( ) .)


state 81

    (28) param_element -> expression . , param_element
    (29) param_element -> expression . , param_element_pos
    (30) param_element -> expression . ,
    (31) param_element -> expression .

    ,               shift and go to state 94
    )               reduce using rule 31 (param_element -> expression .)


state 82

    (66) table -> % [ comma_expressions . ]

    ]               shift and go to state 95


state 83

    (67) table -> % { table_contents . }

    }               shift and go to state 96


state 84

    (60) table_contents -> STRING . : expression , table_contents
    (62) table_contents -> STRING . : expression ,
    (64) table_contents -> STRING . : expression

    :               shift and go to state 97


state 85

    (61) table_contents -> NUMBER . : expression , table_contents
    (63) table_contents -> NUMBER . : expression ,
    (65) table_contents -> NUMBER . : expression

    :               shift and go to state 98


state 86

    (20) scope -> { expressions } .

    +               reduce using rule 20 (scope -> { expressions } .)
    -               reduce using rule 20 (scope -> { expressions } .)
    *               reduce using rule 20 (scope -> { expressions } .)
    /               reduce using rule 20 (scope -> { expressions } .)
    LT              reduce using rule 20 (scope -> { expressions } .)
    LE              reduce using rule 20 (scope -> { expressions } .)
    GT              reduce using rule 20 (scope -> { expressions } .)
    GE              reduce using rule 20 (scope -> { expressions } .)
    EE              reduce using rule 20 (scope -> { expressions } .)
    NE              reduce using rule 20 (scope -> { expressions } .)
    AND             reduce using rule 20 (scope -> { expressions } .)
    OR              reduce using rule 20 (scope -> { expressions } .)
    BREAK           reduce using rule 20 (scope -> { expressions } .)
    RETURN          reduce using rule 20 (scope -> { expressions } .)
    PASS            reduce using rule 20 (scope -> { expressions } .)
    MACRO           reduce using rule 20 (scope -> { expressions } .)
    IF              reduce using rule 20 (scope -> { expressions } .)
    NOT             reduce using rule 20 (scope -> { expressions } .)
    MIN             reduce using rule 20 (scope -> { expressions } .)
    MAX             reduce using rule 20 (scope -> { expressions } .)
    VARIABLE        reduce using rule 20 (scope -> { expressions } .)
    (               reduce using rule 20 (scope -> { expressions } .)
    NUMBER          reduce using rule 20 (scope -> { expressions } .)
    BOOLEAN         reduce using rule 20 (scope -> { expressions } .)
    STRING          reduce using rule 20 (scope -> { expressions } .)
    WORD            reduce using rule 20 (scope -> { expressions } .)
    FUNCTION        reduce using rule 20 (scope -> { expressions } .)
    %               reduce using rule 20 (scope -> { expressions } .)
    {               reduce using rule 20 (scope -> { expressions } .)
    $end            reduce using rule 20 (scope -> { expressions } .)
    }               reduce using rule 20 (scope -> { expressions } .)
    )               reduce using rule 20 (scope -> { expressions } .)
    ,               reduce using rule 20 (scope -> { expressions } .)
    ]               reduce using rule 20 (scope -> { expressions } .)
    #               reduce using rule 20 (scope -> { expressions } .)
    ELSEIF          reduce using rule 20 (scope -> { expressions } .)
    ELSE            reduce using rule 20 (scope -> { expressions } .)
    TAG             reduce using rule 20 (scope -> { expressions } .)


state 87

    (10) if_condition -> IF ( expression ) . scope elif_branch
    (11) if_condition -> IF ( expression ) . scope else_branch
    (12) if_condition -> IF ( expression ) . scope
    (20) scope -> . { expressions }

    {               shift and go to state 28

    scope                          shift and go to state 99

state 88

    (55) arith -> MIN ( comma_expressions ) .

    LT              reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    LE              reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    GT              reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    GE              reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    EE              reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    NE              reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    AND             reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    OR              reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    BREAK           reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    RETURN          reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    PASS            reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    MACRO           reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    IF              reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    NOT             reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    MIN             reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    MAX             reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    VARIABLE        reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    -               reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    (               reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    NUMBER          reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    BOOLEAN         reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    STRING          reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    WORD            reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    FUNCTION        reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    %               reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    {               reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    $end            reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    }               reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    )               reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    ,               reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    +               reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    *               reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    /               reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    ]               reduce using rule 55 (arith -> MIN ( comma_expressions ) .)
    #               reduce using rule 55 (arith -> MIN ( comma_expressions ) .)


state 89

    (52) comma_expressions -> expression , . comma_expressions
    (53) comma_expressions -> expression , .
    (52) comma_expressions -> . expression , comma_expressions
    (53) comma_expressions -> . expression ,
    (54) comma_expressions -> . expression
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    )               reduce using rule 53 (comma_expressions -> expression , .)
    ]               reduce using rule 53 (comma_expressions -> expression , .)
    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    expression                     shift and go to state 72
    comma_expressions              shift and go to state 100
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 90

    (56) arith -> MAX ( comma_expressions ) .

    LT              reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    LE              reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    GT              reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    GE              reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    EE              reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    NE              reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    AND             reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    OR              reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    BREAK           reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    RETURN          reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    PASS            reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    MACRO           reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    IF              reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    NOT             reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    MIN             reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    MAX             reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    VARIABLE        reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    -               reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    (               reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    NUMBER          reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    BOOLEAN         reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    STRING          reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    WORD            reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    FUNCTION        reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    %               reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    {               reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    $end            reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    }               reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    )               reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    ,               reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    +               reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    *               reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    /               reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    ]               reduce using rule 56 (arith -> MAX ( comma_expressions ) .)
    #               reduce using rule 56 (arith -> MAX ( comma_expressions ) .)


state 91

    (18) tag_list -> tag # . scope tag_list
    (19) tag_list -> tag # . scope
    (20) scope -> . { expressions }

    {               shift and go to state 28

    scope                          shift and go to state 101

state 92

    (17) tag -> TAG expression .

    #               reduce using rule 17 (tag -> TAG expression .)


state 93

    (23) parameters -> ( param_element ) .

    {               reduce using rule 23 (parameters -> ( param_element ) .)
    TAG             reduce using rule 23 (parameters -> ( param_element ) .)
    +               reduce using rule 23 (parameters -> ( param_element ) .)
    -               reduce using rule 23 (parameters -> ( param_element ) .)
    *               reduce using rule 23 (parameters -> ( param_element ) .)
    /               reduce using rule 23 (parameters -> ( param_element ) .)
    LT              reduce using rule 23 (parameters -> ( param_element ) .)
    LE              reduce using rule 23 (parameters -> ( param_element ) .)
    GT              reduce using rule 23 (parameters -> ( param_element ) .)
    GE              reduce using rule 23 (parameters -> ( param_element ) .)
    EE              reduce using rule 23 (parameters -> ( param_element ) .)
    NE              reduce using rule 23 (parameters -> ( param_element ) .)
    AND             reduce using rule 23 (parameters -> ( param_element ) .)
    OR              reduce using rule 23 (parameters -> ( param_element ) .)
    BREAK           reduce using rule 23 (parameters -> ( param_element ) .)
    RETURN          reduce using rule 23 (parameters -> ( param_element ) .)
    PASS            reduce using rule 23 (parameters -> ( param_element ) .)
    MACRO           reduce using rule 23 (parameters -> ( param_element ) .)
    IF              reduce using rule 23 (parameters -> ( param_element ) .)
    NOT             reduce using rule 23 (parameters -> ( param_element ) .)
    MIN             reduce using rule 23 (parameters -> ( param_element ) .)
    MAX             reduce using rule 23 (parameters -> ( param_element ) .)
    VARIABLE        reduce using rule 23 (parameters -> ( param_element ) .)
    (               reduce using rule 23 (parameters -> ( param_element ) .)
    NUMBER          reduce using rule 23 (parameters -> ( param_element ) .)
    BOOLEAN         reduce using rule 23 (parameters -> ( param_element ) .)
    STRING          reduce using rule 23 (parameters -> ( param_element ) .)
    WORD            reduce using rule 23 (parameters -> ( param_element ) .)
    FUNCTION        reduce using rule 23 (parameters -> ( param_element ) .)
    %               reduce using rule 23 (parameters -> ( param_element ) .)
    $end            reduce using rule 23 (parameters -> ( param_element ) .)
    }               reduce using rule 23 (parameters -> ( param_element ) .)
    )               reduce using rule 23 (parameters -> ( param_element ) .)
    ,               reduce using rule 23 (parameters -> ( param_element ) .)
    ]               reduce using rule 23 (parameters -> ( param_element ) .)
    #               reduce using rule 23 (parameters -> ( param_element ) .)


state 94

    (28) param_element -> expression , . param_element
    (29) param_element -> expression , . param_element_pos
    (30) param_element -> expression , .
    (28) param_element -> . expression , param_element
    (29) param_element -> . expression , param_element_pos
    (30) param_element -> . expression ,
    (31) param_element -> . expression
    (25) param_element_pos -> . WORD = expression , param_element_pos
    (26) param_element_pos -> . WORD = expression ,
    (27) param_element_pos -> . WORD = expression
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    )               reduce using rule 30 (param_element -> expression , .)
    WORD            shift and go to state 104
    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    expression                     shift and go to state 81
    param_element                  shift and go to state 102
    param_element_pos              shift and go to state 103
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 95

    (66) table -> % [ comma_expressions ] .

    +               reduce using rule 66 (table -> % [ comma_expressions ] .)
    -               reduce using rule 66 (table -> % [ comma_expressions ] .)
    *               reduce using rule 66 (table -> % [ comma_expressions ] .)
    /               reduce using rule 66 (table -> % [ comma_expressions ] .)
    LT              reduce using rule 66 (table -> % [ comma_expressions ] .)
    LE              reduce using rule 66 (table -> % [ comma_expressions ] .)
    GT              reduce using rule 66 (table -> % [ comma_expressions ] .)
    GE              reduce using rule 66 (table -> % [ comma_expressions ] .)
    EE              reduce using rule 66 (table -> % [ comma_expressions ] .)
    NE              reduce using rule 66 (table -> % [ comma_expressions ] .)
    AND             reduce using rule 66 (table -> % [ comma_expressions ] .)
    OR              reduce using rule 66 (table -> % [ comma_expressions ] .)
    BREAK           reduce using rule 66 (table -> % [ comma_expressions ] .)
    RETURN          reduce using rule 66 (table -> % [ comma_expressions ] .)
    PASS            reduce using rule 66 (table -> % [ comma_expressions ] .)
    MACRO           reduce using rule 66 (table -> % [ comma_expressions ] .)
    IF              reduce using rule 66 (table -> % [ comma_expressions ] .)
    NOT             reduce using rule 66 (table -> % [ comma_expressions ] .)
    MIN             reduce using rule 66 (table -> % [ comma_expressions ] .)
    MAX             reduce using rule 66 (table -> % [ comma_expressions ] .)
    VARIABLE        reduce using rule 66 (table -> % [ comma_expressions ] .)
    (               reduce using rule 66 (table -> % [ comma_expressions ] .)
    NUMBER          reduce using rule 66 (table -> % [ comma_expressions ] .)
    BOOLEAN         reduce using rule 66 (table -> % [ comma_expressions ] .)
    STRING          reduce using rule 66 (table -> % [ comma_expressions ] .)
    WORD            reduce using rule 66 (table -> % [ comma_expressions ] .)
    FUNCTION        reduce using rule 66 (table -> % [ comma_expressions ] .)
    %               reduce using rule 66 (table -> % [ comma_expressions ] .)
    {               reduce using rule 66 (table -> % [ comma_expressions ] .)
    $end            reduce using rule 66 (table -> % [ comma_expressions ] .)
    }               reduce using rule 66 (table -> % [ comma_expressions ] .)
    )               reduce using rule 66 (table -> % [ comma_expressions ] .)
    ,               reduce using rule 66 (table -> % [ comma_expressions ] .)
    ]               reduce using rule 66 (table -> % [ comma_expressions ] .)
    #               reduce using rule 66 (table -> % [ comma_expressions ] .)


state 96

    (67) table -> % { table_contents } .

    +               reduce using rule 67 (table -> % { table_contents } .)
    -               reduce using rule 67 (table -> % { table_contents } .)
    *               reduce using rule 67 (table -> % { table_contents } .)
    /               reduce using rule 67 (table -> % { table_contents } .)
    LT              reduce using rule 67 (table -> % { table_contents } .)
    LE              reduce using rule 67 (table -> % { table_contents } .)
    GT              reduce using rule 67 (table -> % { table_contents } .)
    GE              reduce using rule 67 (table -> % { table_contents } .)
    EE              reduce using rule 67 (table -> % { table_contents } .)
    NE              reduce using rule 67 (table -> % { table_contents } .)
    AND             reduce using rule 67 (table -> % { table_contents } .)
    OR              reduce using rule 67 (table -> % { table_contents } .)
    BREAK           reduce using rule 67 (table -> % { table_contents } .)
    RETURN          reduce using rule 67 (table -> % { table_contents } .)
    PASS            reduce using rule 67 (table -> % { table_contents } .)
    MACRO           reduce using rule 67 (table -> % { table_contents } .)
    IF              reduce using rule 67 (table -> % { table_contents } .)
    NOT             reduce using rule 67 (table -> % { table_contents } .)
    MIN             reduce using rule 67 (table -> % { table_contents } .)
    MAX             reduce using rule 67 (table -> % { table_contents } .)
    VARIABLE        reduce using rule 67 (table -> % { table_contents } .)
    (               reduce using rule 67 (table -> % { table_contents } .)
    NUMBER          reduce using rule 67 (table -> % { table_contents } .)
    BOOLEAN         reduce using rule 67 (table -> % { table_contents } .)
    STRING          reduce using rule 67 (table -> % { table_contents } .)
    WORD            reduce using rule 67 (table -> % { table_contents } .)
    FUNCTION        reduce using rule 67 (table -> % { table_contents } .)
    %               reduce using rule 67 (table -> % { table_contents } .)
    {               reduce using rule 67 (table -> % { table_contents } .)
    $end            reduce using rule 67 (table -> % { table_contents } .)
    }               reduce using rule 67 (table -> % { table_contents } .)
    )               reduce using rule 67 (table -> % { table_contents } .)
    ,               reduce using rule 67 (table -> % { table_contents } .)
    ]               reduce using rule 67 (table -> % { table_contents } .)
    #               reduce using rule 67 (table -> % { table_contents } .)


state 97

    (60) table_contents -> STRING : . expression , table_contents
    (62) table_contents -> STRING : . expression ,
    (64) table_contents -> STRING : . expression
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    expression                     shift and go to state 105
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 98

    (61) table_contents -> NUMBER : . expression , table_contents
    (63) table_contents -> NUMBER : . expression ,
    (65) table_contents -> NUMBER : . expression
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    expression                     shift and go to state 106
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 99

    (10) if_condition -> IF ( expression ) scope . elif_branch
    (11) if_condition -> IF ( expression ) scope . else_branch
    (12) if_condition -> IF ( expression ) scope .
    (7) elif_branch -> . ELSEIF ( expression ) scope elif_branch
    (8) elif_branch -> . ELSEIF ( expression ) scope else_branch
    (9) elif_branch -> . ELSEIF ( expression ) scope
    (6) else_branch -> . ELSE scope

    BREAK           reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    RETURN          reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    PASS            reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    MACRO           reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    IF              reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    NOT             reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    MIN             reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    MAX             reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    VARIABLE        reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    -               reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    (               reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    NUMBER          reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    BOOLEAN         reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    STRING          reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    WORD            reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    FUNCTION        reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    %               reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    {               reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    $end            reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    }               reduce using rule 12 (if_condition -> IF ( expression ) scope .)
    ELSEIF          shift and go to state 109
    ELSE            shift and go to state 110

    elif_branch                    shift and go to state 107
    else_branch                    shift and go to state 108

state 100

    (52) comma_expressions -> expression , comma_expressions .

    )               reduce using rule 52 (comma_expressions -> expression , comma_expressions .)
    ]               reduce using rule 52 (comma_expressions -> expression , comma_expressions .)


state 101

    (18) tag_list -> tag # scope . tag_list
    (19) tag_list -> tag # scope .
    (18) tag_list -> . tag # scope tag_list
    (19) tag_list -> . tag # scope
    (17) tag -> . TAG expression

    +               reduce using rule 19 (tag_list -> tag # scope .)
    -               reduce using rule 19 (tag_list -> tag # scope .)
    *               reduce using rule 19 (tag_list -> tag # scope .)
    /               reduce using rule 19 (tag_list -> tag # scope .)
    LT              reduce using rule 19 (tag_list -> tag # scope .)
    LE              reduce using rule 19 (tag_list -> tag # scope .)
    GT              reduce using rule 19 (tag_list -> tag # scope .)
    GE              reduce using rule 19 (tag_list -> tag # scope .)
    EE              reduce using rule 19 (tag_list -> tag # scope .)
    NE              reduce using rule 19 (tag_list -> tag # scope .)
    AND             reduce using rule 19 (tag_list -> tag # scope .)
    OR              reduce using rule 19 (tag_list -> tag # scope .)
    BREAK           reduce using rule 19 (tag_list -> tag # scope .)
    RETURN          reduce using rule 19 (tag_list -> tag # scope .)
    PASS            reduce using rule 19 (tag_list -> tag # scope .)
    MACRO           reduce using rule 19 (tag_list -> tag # scope .)
    IF              reduce using rule 19 (tag_list -> tag # scope .)
    NOT             reduce using rule 19 (tag_list -> tag # scope .)
    MIN             reduce using rule 19 (tag_list -> tag # scope .)
    MAX             reduce using rule 19 (tag_list -> tag # scope .)
    VARIABLE        reduce using rule 19 (tag_list -> tag # scope .)
    (               reduce using rule 19 (tag_list -> tag # scope .)
    NUMBER          reduce using rule 19 (tag_list -> tag # scope .)
    BOOLEAN         reduce using rule 19 (tag_list -> tag # scope .)
    STRING          reduce using rule 19 (tag_list -> tag # scope .)
    WORD            reduce using rule 19 (tag_list -> tag # scope .)
    FUNCTION        reduce using rule 19 (tag_list -> tag # scope .)
    %               reduce using rule 19 (tag_list -> tag # scope .)
    {               reduce using rule 19 (tag_list -> tag # scope .)
    $end            reduce using rule 19 (tag_list -> tag # scope .)
    }               reduce using rule 19 (tag_list -> tag # scope .)
    )               reduce using rule 19 (tag_list -> tag # scope .)
    ,               reduce using rule 19 (tag_list -> tag # scope .)
    ]               reduce using rule 19 (tag_list -> tag # scope .)
    #               reduce using rule 19 (tag_list -> tag # scope .)
    TAG             shift and go to state 78

    tag                            shift and go to state 77
    tag_list                       shift and go to state 111

state 102

    (28) param_element -> expression , param_element .

    )               reduce using rule 28 (param_element -> expression , param_element .)


state 103

    (29) param_element -> expression , param_element_pos .

    )               reduce using rule 29 (param_element -> expression , param_element_pos .)


state 104

    (25) param_element_pos -> WORD . = expression , param_element_pos
    (26) param_element_pos -> WORD . = expression ,
    (27) param_element_pos -> WORD . = expression
    (72) atom -> WORD .

    =               shift and go to state 112
    +               reduce using rule 72 (atom -> WORD .)
    -               reduce using rule 72 (atom -> WORD .)
    *               reduce using rule 72 (atom -> WORD .)
    /               reduce using rule 72 (atom -> WORD .)
    LT              reduce using rule 72 (atom -> WORD .)
    LE              reduce using rule 72 (atom -> WORD .)
    GT              reduce using rule 72 (atom -> WORD .)
    GE              reduce using rule 72 (atom -> WORD .)
    EE              reduce using rule 72 (atom -> WORD .)
    NE              reduce using rule 72 (atom -> WORD .)
    AND             reduce using rule 72 (atom -> WORD .)
    OR              reduce using rule 72 (atom -> WORD .)
    ,               reduce using rule 72 (atom -> WORD .)
    )               reduce using rule 72 (atom -> WORD .)


state 105

    (60) table_contents -> STRING : expression . , table_contents
    (62) table_contents -> STRING : expression . ,
    (64) table_contents -> STRING : expression .

    ,               shift and go to state 113
    }               reduce using rule 64 (table_contents -> STRING : expression .)


state 106

    (61) table_contents -> NUMBER : expression . , table_contents
    (63) table_contents -> NUMBER : expression . ,
    (65) table_contents -> NUMBER : expression .

    ,               shift and go to state 114
    }               reduce using rule 65 (table_contents -> NUMBER : expression .)


state 107

    (10) if_condition -> IF ( expression ) scope elif_branch .

    BREAK           reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    RETURN          reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    PASS            reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    MACRO           reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    IF              reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    NOT             reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    MIN             reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    MAX             reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    VARIABLE        reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    -               reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    (               reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    NUMBER          reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    BOOLEAN         reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    STRING          reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    WORD            reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    FUNCTION        reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    %               reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    {               reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    $end            reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)
    }               reduce using rule 10 (if_condition -> IF ( expression ) scope elif_branch .)


state 108

    (11) if_condition -> IF ( expression ) scope else_branch .

    BREAK           reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    RETURN          reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    PASS            reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    MACRO           reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    IF              reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    NOT             reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    MIN             reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    MAX             reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    VARIABLE        reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    -               reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    (               reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    NUMBER          reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    BOOLEAN         reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    STRING          reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    WORD            reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    FUNCTION        reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    %               reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    {               reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    $end            reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)
    }               reduce using rule 11 (if_condition -> IF ( expression ) scope else_branch .)


state 109

    (7) elif_branch -> ELSEIF . ( expression ) scope elif_branch
    (8) elif_branch -> ELSEIF . ( expression ) scope else_branch
    (9) elif_branch -> ELSEIF . ( expression ) scope

    (               shift and go to state 115


state 110

    (6) else_branch -> ELSE . scope
    (20) scope -> . { expressions }

    {               shift and go to state 28

    scope                          shift and go to state 116

state 111

    (18) tag_list -> tag # scope tag_list .

    +               reduce using rule 18 (tag_list -> tag # scope tag_list .)
    -               reduce using rule 18 (tag_list -> tag # scope tag_list .)
    *               reduce using rule 18 (tag_list -> tag # scope tag_list .)
    /               reduce using rule 18 (tag_list -> tag # scope tag_list .)
    LT              reduce using rule 18 (tag_list -> tag # scope tag_list .)
    LE              reduce using rule 18 (tag_list -> tag # scope tag_list .)
    GT              reduce using rule 18 (tag_list -> tag # scope tag_list .)
    GE              reduce using rule 18 (tag_list -> tag # scope tag_list .)
    EE              reduce using rule 18 (tag_list -> tag # scope tag_list .)
    NE              reduce using rule 18 (tag_list -> tag # scope tag_list .)
    AND             reduce using rule 18 (tag_list -> tag # scope tag_list .)
    OR              reduce using rule 18 (tag_list -> tag # scope tag_list .)
    BREAK           reduce using rule 18 (tag_list -> tag # scope tag_list .)
    RETURN          reduce using rule 18 (tag_list -> tag # scope tag_list .)
    PASS            reduce using rule 18 (tag_list -> tag # scope tag_list .)
    MACRO           reduce using rule 18 (tag_list -> tag # scope tag_list .)
    IF              reduce using rule 18 (tag_list -> tag # scope tag_list .)
    NOT             reduce using rule 18 (tag_list -> tag # scope tag_list .)
    MIN             reduce using rule 18 (tag_list -> tag # scope tag_list .)
    MAX             reduce using rule 18 (tag_list -> tag # scope tag_list .)
    VARIABLE        reduce using rule 18 (tag_list -> tag # scope tag_list .)
    (               reduce using rule 18 (tag_list -> tag # scope tag_list .)
    NUMBER          reduce using rule 18 (tag_list -> tag # scope tag_list .)
    BOOLEAN         reduce using rule 18 (tag_list -> tag # scope tag_list .)
    STRING          reduce using rule 18 (tag_list -> tag # scope tag_list .)
    WORD            reduce using rule 18 (tag_list -> tag # scope tag_list .)
    FUNCTION        reduce using rule 18 (tag_list -> tag # scope tag_list .)
    %               reduce using rule 18 (tag_list -> tag # scope tag_list .)
    {               reduce using rule 18 (tag_list -> tag # scope tag_list .)
    $end            reduce using rule 18 (tag_list -> tag # scope tag_list .)
    }               reduce using rule 18 (tag_list -> tag # scope tag_list .)
    )               reduce using rule 18 (tag_list -> tag # scope tag_list .)
    ,               reduce using rule 18 (tag_list -> tag # scope tag_list .)
    ]               reduce using rule 18 (tag_list -> tag # scope tag_list .)
    #               reduce using rule 18 (tag_list -> tag # scope tag_list .)


state 112

    (25) param_element_pos -> WORD = . expression , param_element_pos
    (26) param_element_pos -> WORD = . expression ,
    (27) param_element_pos -> WORD = . expression
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    expression                     shift and go to state 117
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24
    scope                          shift and go to state 12

state 113

    (60) table_contents -> STRING : expression , . table_contents
    (62) table_contents -> STRING : expression , .
    (60) table_contents -> . STRING : expression , table_contents
    (61) table_contents -> . NUMBER : expression , table_contents
    (62) table_contents -> . STRING : expression ,
    (63) table_contents -> . NUMBER : expression ,
    (64) table_contents -> . STRING : expression
    (65) table_contents -> . NUMBER : expression

    }               reduce using rule 62 (table_contents -> STRING : expression , .)
    STRING          shift and go to state 84
    NUMBER          shift and go to state 85

    table_contents                 shift and go to state 118

state 114

    (61) table_contents -> NUMBER : expression , . table_contents
    (63) table_contents -> NUMBER : expression , .
    (60) table_contents -> . STRING : expression , table_contents
    (61) table_contents -> . NUMBER : expression , table_contents
    (62) table_contents -> . STRING : expression ,
    (63) table_contents -> . NUMBER : expression ,
    (64) table_contents -> . STRING : expression
    (65) table_contents -> . NUMBER : expression

    }               reduce using rule 63 (table_contents -> NUMBER : expression , .)
    STRING          shift and go to state 84
    NUMBER          shift and go to state 85

    table_contents                 shift and go to state 119

state 115

    (7) elif_branch -> ELSEIF ( . expression ) scope elif_branch
    (8) elif_branch -> ELSEIF ( . expression ) scope else_branch
    (9) elif_branch -> ELSEIF ( . expression ) scope
    (1) expression -> . PASS
    (2) expression -> . MACRO = expression
    (3) expression -> . MACRO
    (74) expression -> . comp
    (36) comp -> . NOT comp
    (37) comp -> . arith LT arith
    (38) comp -> . arith LE arith
    (39) comp -> . arith GT arith
    (40) comp -> . arith GE arith
    (41) comp -> . arith EE arith
    (42) comp -> . arith NE arith
    (43) comp -> . comp AND comp
    (44) comp -> . comp OR comp
    (45) comp -> . arith
    (46) arith -> . atom + atom
    (47) arith -> . atom - atom
    (48) arith -> . atom * atom
    (49) arith -> . atom / atom
    (50) arith -> . atom
    (55) arith -> . MIN ( comma_expressions )
    (56) arith -> . MAX ( comma_expressions )
    (4) atom -> . VARIABLE = expression
    (5) atom -> . VARIABLE
    (35) atom -> . function_call
    (51) atom -> . - atom
    (57) atom -> . ( expression )
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . STRING
    (71) atom -> . table
    (72) atom -> . WORD
    (73) atom -> . scope
    (13) function_call -> . FUNCTION parameters scope
    (14) function_call -> . FUNCTION parameters tag_list
    (15) function_call -> . FUNCTION parameters
    (16) function_call -> . FUNCTION
    (66) table -> . % [ comma_expressions ]
    (67) table -> . % { table_contents }
    (20) scope -> . { expressions }

    PASS            shift and go to state 7
    MACRO           shift and go to state 8
    NOT             shift and go to state 13
    MIN             shift and go to state 17
    MAX             shift and go to state 18
    VARIABLE        shift and go to state 19
    -               shift and go to state 16
    (               shift and go to state 11
    NUMBER          shift and go to state 21
    BOOLEAN         shift and go to state 22
    STRING          shift and go to state 23
    WORD            shift and go to state 25
    FUNCTION        shift and go to state 26
    %               shift and go to state 27
    {               shift and go to state 28

    expression                     shift and go to state 120
    scope                          shift and go to state 12
    comp                           shift and go to state 9
    arith                          shift and go to state 14
    atom                           shift and go to state 15
    function_call                  shift and go to state 20
    table                          shift and go to state 24

state 116

    (6) else_branch -> ELSE scope .

    BREAK           reduce using rule 6 (else_branch -> ELSE scope .)
    RETURN          reduce using rule 6 (else_branch -> ELSE scope .)
    PASS            reduce using rule 6 (else_branch -> ELSE scope .)
    MACRO           reduce using rule 6 (else_branch -> ELSE scope .)
    IF              reduce using rule 6 (else_branch -> ELSE scope .)
    NOT             reduce using rule 6 (else_branch -> ELSE scope .)
    MIN             reduce using rule 6 (else_branch -> ELSE scope .)
    MAX             reduce using rule 6 (else_branch -> ELSE scope .)
    VARIABLE        reduce using rule 6 (else_branch -> ELSE scope .)
    -               reduce using rule 6 (else_branch -> ELSE scope .)
    (               reduce using rule 6 (else_branch -> ELSE scope .)
    NUMBER          reduce using rule 6 (else_branch -> ELSE scope .)
    BOOLEAN         reduce using rule 6 (else_branch -> ELSE scope .)
    STRING          reduce using rule 6 (else_branch -> ELSE scope .)
    WORD            reduce using rule 6 (else_branch -> ELSE scope .)
    FUNCTION        reduce using rule 6 (else_branch -> ELSE scope .)
    %               reduce using rule 6 (else_branch -> ELSE scope .)
    {               reduce using rule 6 (else_branch -> ELSE scope .)
    $end            reduce using rule 6 (else_branch -> ELSE scope .)
    }               reduce using rule 6 (else_branch -> ELSE scope .)


state 117

    (25) param_element_pos -> WORD = expression . , param_element_pos
    (26) param_element_pos -> WORD = expression . ,
    (27) param_element_pos -> WORD = expression .

    ,               shift and go to state 121
    )               reduce using rule 27 (param_element_pos -> WORD = expression .)


state 118

    (60) table_contents -> STRING : expression , table_contents .

    }               reduce using rule 60 (table_contents -> STRING : expression , table_contents .)


state 119

    (61) table_contents -> NUMBER : expression , table_contents .

    }               reduce using rule 61 (table_contents -> NUMBER : expression , table_contents .)


state 120

    (7) elif_branch -> ELSEIF ( expression . ) scope elif_branch
    (8) elif_branch -> ELSEIF ( expression . ) scope else_branch
    (9) elif_branch -> ELSEIF ( expression . ) scope

    )               shift and go to state 122


state 121

    (25) param_element_pos -> WORD = expression , . param_element_pos
    (26) param_element_pos -> WORD = expression , .
    (25) param_element_pos -> . WORD = expression , param_element_pos
    (26) param_element_pos -> . WORD = expression ,
    (27) param_element_pos -> . WORD = expression

    )               reduce using rule 26 (param_element_pos -> WORD = expression , .)
    WORD            shift and go to state 123

    param_element_pos              shift and go to state 124

state 122

    (7) elif_branch -> ELSEIF ( expression ) . scope elif_branch
    (8) elif_branch -> ELSEIF ( expression ) . scope else_branch
    (9) elif_branch -> ELSEIF ( expression ) . scope
    (20) scope -> . { expressions }

    {               shift and go to state 28

    scope                          shift and go to state 125

state 123

    (25) param_element_pos -> WORD . = expression , param_element_pos
    (26) param_element_pos -> WORD . = expression ,
    (27) param_element_pos -> WORD . = expression

    =               shift and go to state 112


state 124

    (25) param_element_pos -> WORD = expression , param_element_pos .

    )               reduce using rule 25 (param_element_pos -> WORD = expression , param_element_pos .)


state 125

    (7) elif_branch -> ELSEIF ( expression ) scope . elif_branch
    (8) elif_branch -> ELSEIF ( expression ) scope . else_branch
    (9) elif_branch -> ELSEIF ( expression ) scope .
    (7) elif_branch -> . ELSEIF ( expression ) scope elif_branch
    (8) elif_branch -> . ELSEIF ( expression ) scope else_branch
    (9) elif_branch -> . ELSEIF ( expression ) scope
    (6) else_branch -> . ELSE scope

    BREAK           reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    RETURN          reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    PASS            reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    MACRO           reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    IF              reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    NOT             reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    MIN             reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    MAX             reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    VARIABLE        reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    -               reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    (               reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    NUMBER          reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    BOOLEAN         reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    STRING          reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    WORD            reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    FUNCTION        reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    %               reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    {               reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    $end            reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    }               reduce using rule 9 (elif_branch -> ELSEIF ( expression ) scope .)
    ELSEIF          shift and go to state 109
    ELSE            shift and go to state 110

    elif_branch                    shift and go to state 126
    else_branch                    shift and go to state 127

state 126

    (7) elif_branch -> ELSEIF ( expression ) scope elif_branch .

    BREAK           reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    RETURN          reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    PASS            reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    MACRO           reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    IF              reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    NOT             reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    MIN             reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    MAX             reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    VARIABLE        reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    -               reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    (               reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    NUMBER          reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    BOOLEAN         reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    STRING          reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    WORD            reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    FUNCTION        reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    %               reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    {               reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    $end            reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    }               reduce using rule 7 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)


state 127

    (8) elif_branch -> ELSEIF ( expression ) scope else_branch .

    BREAK           reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    RETURN          reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    PASS            reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    MACRO           reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    IF              reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    NOT             reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    MIN             reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    MAX             reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    VARIABLE        reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    -               reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    (               reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    NUMBER          reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    BOOLEAN         reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    STRING          reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    WORD            reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    FUNCTION        reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    %               reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    {               reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    $end            reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    }               reduce using rule 8 (elif_branch -> ELSEIF ( expression ) scope else_branch .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PASS in state 6 resolved as shift
WARNING: shift/reduce conflict for MACRO in state 6 resolved as shift
WARNING: shift/reduce conflict for NOT in state 6 resolved as shift
WARNING: shift/reduce conflict for MIN in state 6 resolved as shift
WARNING: shift/reduce conflict for MAX in state 6 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 6 resolved as shift
WARNING: shift/reduce conflict for - in state 6 resolved as shift
WARNING: shift/reduce conflict for ( in state 6 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 6 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 6 resolved as shift
WARNING: shift/reduce conflict for STRING in state 6 resolved as shift
WARNING: shift/reduce conflict for WORD in state 6 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 6 resolved as shift
WARNING: shift/reduce conflict for % in state 6 resolved as shift
WARNING: shift/reduce conflict for { in state 6 resolved as shift
WARNING: shift/reduce conflict for AND in state 9 resolved as shift
WARNING: shift/reduce conflict for OR in state 9 resolved as shift
WARNING: shift/reduce conflict for LT in state 14 resolved as shift
WARNING: shift/reduce conflict for LE in state 14 resolved as shift
WARNING: shift/reduce conflict for GT in state 14 resolved as shift
WARNING: shift/reduce conflict for GE in state 14 resolved as shift
WARNING: shift/reduce conflict for EE in state 14 resolved as shift
WARNING: shift/reduce conflict for NE in state 14 resolved as shift
WARNING: shift/reduce conflict for - in state 15 resolved as shift
WARNING: shift/reduce conflict for + in state 15 resolved as shift
WARNING: shift/reduce conflict for * in state 15 resolved as shift
WARNING: shift/reduce conflict for / in state 15 resolved as shift
WARNING: shift/reduce conflict for ( in state 26 resolved as shift
WARNING: shift/reduce conflict for AND in state 36 resolved as shift
WARNING: shift/reduce conflict for OR in state 36 resolved as shift
WARNING: shift/reduce conflict for { in state 51 resolved as shift
