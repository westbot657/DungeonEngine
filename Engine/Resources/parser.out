Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CONTINUE

Grammar

Rule 0     S' -> expressions
Rule 1     atom -> VARIABLE = expression
Rule 2     atom -> VARIABLE
Rule 3     else_branch -> ELSE scope
Rule 4     elif_branch -> ELSEIF ( expression ) scope elif_branch
Rule 5     elif_branch -> ELSEIF ( expression ) scope else_branch
Rule 6     elif_branch -> ELSEIF ( expression ) scope
Rule 7     if_condition -> IF ( expression ) scope elif_branch
Rule 8     if_condition -> IF ( expression ) scope else_branch
Rule 9     if_condition -> IF ( expression ) scope
Rule 10    function_call -> FUNCTION parameters scope
Rule 11    function_call -> FUNCTION parameters tag_list
Rule 12    function_call -> FUNCTION parameters
Rule 13    function_call -> FUNCTION
Rule 14    tag -> TAG expression
Rule 15    tag_list -> tag # scope tag_list
Rule 16    tag_list -> tag # scope
Rule 17    scope -> { expressions }
Rule 18    expressions -> statement expressions
Rule 19    expressions -> statement
Rule 20    parameters -> ( param_element )
Rule 21    parameters -> ( )
Rule 22    param_element_pos -> WORD = expression , param_element_pos
Rule 23    param_element_pos -> WORD = expression ,
Rule 24    param_element_pos -> WORD = expression
Rule 25    param_element -> expression , param_element
Rule 26    param_element -> expression , param_element_pos
Rule 27    param_element -> expression ,
Rule 28    param_element -> expression
Rule 29    statement -> BREAK
Rule 30    statement -> expression
Rule 31    statement -> if_condition
Rule 32    atom -> function_call
Rule 33    comp -> NOT comp
Rule 34    comp -> arith LT arith
Rule 35    comp -> arith LE arith
Rule 36    comp -> arith GT arith
Rule 37    comp -> arith GE arith
Rule 38    comp -> arith EE arith
Rule 39    comp -> arith NE arith
Rule 40    comp -> comp AND comp
Rule 41    comp -> comp OR comp
Rule 42    comp -> arith
Rule 43    arith -> atom + atom
Rule 44    arith -> atom - atom
Rule 45    arith -> atom * atom
Rule 46    arith -> atom / atom
Rule 47    arith -> atom
Rule 48    atom -> - atom
Rule 49    comma_expressions -> expression , comma_expressions
Rule 50    comma_expressions -> expression ,
Rule 51    comma_expressions -> expression
Rule 52    arith -> MIN ( comma_expressions )
Rule 53    arith -> MAX ( comma_expressions )
Rule 54    atom -> ( expression )
Rule 55    statement -> RETURN expression
Rule 56    statement -> RETURN
Rule 57    table_contents -> STRING : expression , table_contents
Rule 58    table_contents -> NUMBER : expression , table_contents
Rule 59    table_contents -> STRING : expression ,
Rule 60    table_contents -> NUMBER : expression ,
Rule 61    table_contents -> STRING : expression
Rule 62    table_contents -> NUMBER : expression
Rule 63    table -> % [ comma_expressions ]
Rule 64    table -> % { table_contents }
Rule 65    atom -> NUMBER
Rule 66    atom -> BOOLEAN
Rule 67    atom -> STRING
Rule 68    atom -> table
Rule 69    atom -> WORD
Rule 70    atom -> scope
Rule 71    expression -> comp

Terminals, with rules where they appear

#                    : 15 16
%                    : 63 64
(                    : 4 5 6 7 8 9 20 21 52 53 54
)                    : 4 5 6 7 8 9 20 21 52 53 54
*                    : 45
+                    : 43
,                    : 22 23 25 26 27 49 50 57 58 59 60
-                    : 44 48
/                    : 46
:                    : 57 58 59 60 61 62
=                    : 1 22 23 24
AND                  : 40
BOOLEAN              : 66
BREAK                : 29
CONTINUE             : 
EE                   : 38
ELSE                 : 3
ELSEIF               : 4 5 6
FUNCTION             : 10 11 12 13
GE                   : 37
GT                   : 36
IF                   : 7 8 9
LE                   : 35
LT                   : 34
MAX                  : 53
MIN                  : 52
NE                   : 39
NOT                  : 33
NUMBER               : 58 60 62 65
OR                   : 41
RETURN               : 55 56
STRING               : 57 59 61 67
TAG                  : 14
VARIABLE             : 1 2
WORD                 : 22 23 24 69
[                    : 63
]                    : 63
error                : 
{                    : 17 64
}                    : 17 64

Nonterminals, with rules where they appear

arith                : 34 34 35 35 36 36 37 37 38 38 39 39 42
atom                 : 43 43 44 44 45 45 46 46 47 48
comma_expressions    : 49 52 53 63
comp                 : 33 40 40 41 41 71
elif_branch          : 4 7
else_branch          : 5 8
expression           : 1 4 5 6 7 8 9 14 22 23 24 25 26 27 28 30 49 50 51 54 55 57 58 59 60 61 62
expressions          : 17 18 0
function_call        : 32
if_condition         : 31
param_element        : 20 25
param_element_pos    : 22 26
parameters           : 10 11 12
scope                : 3 4 5 6 7 8 9 10 15 16 70
statement            : 18 19
table                : 68
table_contents       : 57 58 64
tag                  : 15 16
tag_list             : 11 15

Parsing method: LALR

state 0

    (0) S' -> . expressions
    (18) expressions -> . statement expressions
    (19) expressions -> . statement
    (29) statement -> . BREAK
    (30) statement -> . expression
    (31) statement -> . if_condition
    (55) statement -> . RETURN expression
    (56) statement -> . RETURN
    (71) expression -> . comp
    (7) if_condition -> . IF ( expression ) scope elif_branch
    (8) if_condition -> . IF ( expression ) scope else_branch
    (9) if_condition -> . IF ( expression ) scope
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    BREAK           shift and go to state 3
    RETURN          shift and go to state 6
    IF              shift and go to state 8
    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    expressions                    shift and go to state 1
    statement                      shift and go to state 2
    expression                     shift and go to state 4
    if_condition                   shift and go to state 5
    comp                           shift and go to state 7
    scope                          shift and go to state 10
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22

state 1

    (0) S' -> expressions .



state 2

    (18) expressions -> statement . expressions
    (19) expressions -> statement .
    (18) expressions -> . statement expressions
    (19) expressions -> . statement
    (29) statement -> . BREAK
    (30) statement -> . expression
    (31) statement -> . if_condition
    (55) statement -> . RETURN expression
    (56) statement -> . RETURN
    (71) expression -> . comp
    (7) if_condition -> . IF ( expression ) scope elif_branch
    (8) if_condition -> . IF ( expression ) scope else_branch
    (9) if_condition -> . IF ( expression ) scope
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    $end            reduce using rule 19 (expressions -> statement .)
    }               reduce using rule 19 (expressions -> statement .)
    BREAK           shift and go to state 3
    RETURN          shift and go to state 6
    IF              shift and go to state 8
    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    statement                      shift and go to state 2
    expressions                    shift and go to state 27
    expression                     shift and go to state 4
    if_condition                   shift and go to state 5
    comp                           shift and go to state 7
    scope                          shift and go to state 10
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22

state 3

    (29) statement -> BREAK .

    BREAK           reduce using rule 29 (statement -> BREAK .)
    RETURN          reduce using rule 29 (statement -> BREAK .)
    IF              reduce using rule 29 (statement -> BREAK .)
    NOT             reduce using rule 29 (statement -> BREAK .)
    MIN             reduce using rule 29 (statement -> BREAK .)
    MAX             reduce using rule 29 (statement -> BREAK .)
    VARIABLE        reduce using rule 29 (statement -> BREAK .)
    -               reduce using rule 29 (statement -> BREAK .)
    (               reduce using rule 29 (statement -> BREAK .)
    NUMBER          reduce using rule 29 (statement -> BREAK .)
    BOOLEAN         reduce using rule 29 (statement -> BREAK .)
    STRING          reduce using rule 29 (statement -> BREAK .)
    WORD            reduce using rule 29 (statement -> BREAK .)
    FUNCTION        reduce using rule 29 (statement -> BREAK .)
    %               reduce using rule 29 (statement -> BREAK .)
    {               reduce using rule 29 (statement -> BREAK .)
    $end            reduce using rule 29 (statement -> BREAK .)
    }               reduce using rule 29 (statement -> BREAK .)


state 4

    (30) statement -> expression .

    BREAK           reduce using rule 30 (statement -> expression .)
    RETURN          reduce using rule 30 (statement -> expression .)
    IF              reduce using rule 30 (statement -> expression .)
    NOT             reduce using rule 30 (statement -> expression .)
    MIN             reduce using rule 30 (statement -> expression .)
    MAX             reduce using rule 30 (statement -> expression .)
    VARIABLE        reduce using rule 30 (statement -> expression .)
    -               reduce using rule 30 (statement -> expression .)
    (               reduce using rule 30 (statement -> expression .)
    NUMBER          reduce using rule 30 (statement -> expression .)
    BOOLEAN         reduce using rule 30 (statement -> expression .)
    STRING          reduce using rule 30 (statement -> expression .)
    WORD            reduce using rule 30 (statement -> expression .)
    FUNCTION        reduce using rule 30 (statement -> expression .)
    %               reduce using rule 30 (statement -> expression .)
    {               reduce using rule 30 (statement -> expression .)
    $end            reduce using rule 30 (statement -> expression .)
    }               reduce using rule 30 (statement -> expression .)


state 5

    (31) statement -> if_condition .

    BREAK           reduce using rule 31 (statement -> if_condition .)
    RETURN          reduce using rule 31 (statement -> if_condition .)
    IF              reduce using rule 31 (statement -> if_condition .)
    NOT             reduce using rule 31 (statement -> if_condition .)
    MIN             reduce using rule 31 (statement -> if_condition .)
    MAX             reduce using rule 31 (statement -> if_condition .)
    VARIABLE        reduce using rule 31 (statement -> if_condition .)
    -               reduce using rule 31 (statement -> if_condition .)
    (               reduce using rule 31 (statement -> if_condition .)
    NUMBER          reduce using rule 31 (statement -> if_condition .)
    BOOLEAN         reduce using rule 31 (statement -> if_condition .)
    STRING          reduce using rule 31 (statement -> if_condition .)
    WORD            reduce using rule 31 (statement -> if_condition .)
    FUNCTION        reduce using rule 31 (statement -> if_condition .)
    %               reduce using rule 31 (statement -> if_condition .)
    {               reduce using rule 31 (statement -> if_condition .)
    $end            reduce using rule 31 (statement -> if_condition .)
    }               reduce using rule 31 (statement -> if_condition .)


state 6

    (55) statement -> RETURN . expression
    (56) statement -> RETURN .
    (71) expression -> . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for MIN resolved as shift
  ! shift/reduce conflict for MAX resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for WORD resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for { resolved as shift
    BREAK           reduce using rule 56 (statement -> RETURN .)
    RETURN          reduce using rule 56 (statement -> RETURN .)
    IF              reduce using rule 56 (statement -> RETURN .)
    $end            reduce using rule 56 (statement -> RETURN .)
    }               reduce using rule 56 (statement -> RETURN .)
    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

  ! NOT             [ reduce using rule 56 (statement -> RETURN .) ]
  ! MIN             [ reduce using rule 56 (statement -> RETURN .) ]
  ! MAX             [ reduce using rule 56 (statement -> RETURN .) ]
  ! VARIABLE        [ reduce using rule 56 (statement -> RETURN .) ]
  ! -               [ reduce using rule 56 (statement -> RETURN .) ]
  ! (               [ reduce using rule 56 (statement -> RETURN .) ]
  ! NUMBER          [ reduce using rule 56 (statement -> RETURN .) ]
  ! BOOLEAN         [ reduce using rule 56 (statement -> RETURN .) ]
  ! STRING          [ reduce using rule 56 (statement -> RETURN .) ]
  ! WORD            [ reduce using rule 56 (statement -> RETURN .) ]
  ! FUNCTION        [ reduce using rule 56 (statement -> RETURN .) ]
  ! %               [ reduce using rule 56 (statement -> RETURN .) ]
  ! {               [ reduce using rule 56 (statement -> RETURN .) ]

    expression                     shift and go to state 28
    comp                           shift and go to state 7
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 7

    (71) expression -> comp .
    (40) comp -> comp . AND comp
    (41) comp -> comp . OR comp

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    BREAK           reduce using rule 71 (expression -> comp .)
    RETURN          reduce using rule 71 (expression -> comp .)
    IF              reduce using rule 71 (expression -> comp .)
    NOT             reduce using rule 71 (expression -> comp .)
    MIN             reduce using rule 71 (expression -> comp .)
    MAX             reduce using rule 71 (expression -> comp .)
    VARIABLE        reduce using rule 71 (expression -> comp .)
    -               reduce using rule 71 (expression -> comp .)
    (               reduce using rule 71 (expression -> comp .)
    NUMBER          reduce using rule 71 (expression -> comp .)
    BOOLEAN         reduce using rule 71 (expression -> comp .)
    STRING          reduce using rule 71 (expression -> comp .)
    WORD            reduce using rule 71 (expression -> comp .)
    FUNCTION        reduce using rule 71 (expression -> comp .)
    %               reduce using rule 71 (expression -> comp .)
    {               reduce using rule 71 (expression -> comp .)
    $end            reduce using rule 71 (expression -> comp .)
    }               reduce using rule 71 (expression -> comp .)
    )               reduce using rule 71 (expression -> comp .)
    ,               reduce using rule 71 (expression -> comp .)
    +               reduce using rule 71 (expression -> comp .)
    *               reduce using rule 71 (expression -> comp .)
    /               reduce using rule 71 (expression -> comp .)
    LT              reduce using rule 71 (expression -> comp .)
    LE              reduce using rule 71 (expression -> comp .)
    GT              reduce using rule 71 (expression -> comp .)
    GE              reduce using rule 71 (expression -> comp .)
    EE              reduce using rule 71 (expression -> comp .)
    NE              reduce using rule 71 (expression -> comp .)
    ]               reduce using rule 71 (expression -> comp .)
    #               reduce using rule 71 (expression -> comp .)
    AND             shift and go to state 29
    OR              shift and go to state 30

  ! AND             [ reduce using rule 71 (expression -> comp .) ]
  ! OR              [ reduce using rule 71 (expression -> comp .) ]


state 8

    (7) if_condition -> IF . ( expression ) scope elif_branch
    (8) if_condition -> IF . ( expression ) scope else_branch
    (9) if_condition -> IF . ( expression ) scope

    (               shift and go to state 31


state 9

    (54) atom -> ( . expression )
    (71) expression -> . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    expression                     shift and go to state 32
    comp                           shift and go to state 7
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 10

    (70) atom -> scope .

    +               reduce using rule 70 (atom -> scope .)
    -               reduce using rule 70 (atom -> scope .)
    *               reduce using rule 70 (atom -> scope .)
    /               reduce using rule 70 (atom -> scope .)
    LT              reduce using rule 70 (atom -> scope .)
    LE              reduce using rule 70 (atom -> scope .)
    GT              reduce using rule 70 (atom -> scope .)
    GE              reduce using rule 70 (atom -> scope .)
    EE              reduce using rule 70 (atom -> scope .)
    NE              reduce using rule 70 (atom -> scope .)
    AND             reduce using rule 70 (atom -> scope .)
    OR              reduce using rule 70 (atom -> scope .)
    BREAK           reduce using rule 70 (atom -> scope .)
    RETURN          reduce using rule 70 (atom -> scope .)
    IF              reduce using rule 70 (atom -> scope .)
    NOT             reduce using rule 70 (atom -> scope .)
    MIN             reduce using rule 70 (atom -> scope .)
    MAX             reduce using rule 70 (atom -> scope .)
    VARIABLE        reduce using rule 70 (atom -> scope .)
    (               reduce using rule 70 (atom -> scope .)
    NUMBER          reduce using rule 70 (atom -> scope .)
    BOOLEAN         reduce using rule 70 (atom -> scope .)
    STRING          reduce using rule 70 (atom -> scope .)
    WORD            reduce using rule 70 (atom -> scope .)
    FUNCTION        reduce using rule 70 (atom -> scope .)
    %               reduce using rule 70 (atom -> scope .)
    {               reduce using rule 70 (atom -> scope .)
    $end            reduce using rule 70 (atom -> scope .)
    }               reduce using rule 70 (atom -> scope .)
    )               reduce using rule 70 (atom -> scope .)
    ,               reduce using rule 70 (atom -> scope .)
    ]               reduce using rule 70 (atom -> scope .)
    #               reduce using rule 70 (atom -> scope .)


state 11

    (33) comp -> NOT . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    comp                           shift and go to state 33
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 12

    (34) comp -> arith . LT arith
    (35) comp -> arith . LE arith
    (36) comp -> arith . GT arith
    (37) comp -> arith . GE arith
    (38) comp -> arith . EE arith
    (39) comp -> arith . NE arith
    (42) comp -> arith .

  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for EE resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    LT              shift and go to state 34
    LE              shift and go to state 35
    GT              shift and go to state 36
    GE              shift and go to state 37
    EE              shift and go to state 38
    NE              shift and go to state 39
    AND             reduce using rule 42 (comp -> arith .)
    OR              reduce using rule 42 (comp -> arith .)
    BREAK           reduce using rule 42 (comp -> arith .)
    RETURN          reduce using rule 42 (comp -> arith .)
    IF              reduce using rule 42 (comp -> arith .)
    NOT             reduce using rule 42 (comp -> arith .)
    MIN             reduce using rule 42 (comp -> arith .)
    MAX             reduce using rule 42 (comp -> arith .)
    VARIABLE        reduce using rule 42 (comp -> arith .)
    -               reduce using rule 42 (comp -> arith .)
    (               reduce using rule 42 (comp -> arith .)
    NUMBER          reduce using rule 42 (comp -> arith .)
    BOOLEAN         reduce using rule 42 (comp -> arith .)
    STRING          reduce using rule 42 (comp -> arith .)
    WORD            reduce using rule 42 (comp -> arith .)
    FUNCTION        reduce using rule 42 (comp -> arith .)
    %               reduce using rule 42 (comp -> arith .)
    {               reduce using rule 42 (comp -> arith .)
    $end            reduce using rule 42 (comp -> arith .)
    }               reduce using rule 42 (comp -> arith .)
    )               reduce using rule 42 (comp -> arith .)
    ,               reduce using rule 42 (comp -> arith .)
    +               reduce using rule 42 (comp -> arith .)
    *               reduce using rule 42 (comp -> arith .)
    /               reduce using rule 42 (comp -> arith .)
    ]               reduce using rule 42 (comp -> arith .)
    #               reduce using rule 42 (comp -> arith .)

  ! LT              [ reduce using rule 42 (comp -> arith .) ]
  ! LE              [ reduce using rule 42 (comp -> arith .) ]
  ! GT              [ reduce using rule 42 (comp -> arith .) ]
  ! GE              [ reduce using rule 42 (comp -> arith .) ]
  ! EE              [ reduce using rule 42 (comp -> arith .) ]
  ! NE              [ reduce using rule 42 (comp -> arith .) ]


state 13

    (43) arith -> atom . + atom
    (44) arith -> atom . - atom
    (45) arith -> atom . * atom
    (46) arith -> atom . / atom
    (47) arith -> atom .

  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
    +               shift and go to state 40
    -               shift and go to state 41
    *               shift and go to state 42
    /               shift and go to state 43
    LT              reduce using rule 47 (arith -> atom .)
    LE              reduce using rule 47 (arith -> atom .)
    GT              reduce using rule 47 (arith -> atom .)
    GE              reduce using rule 47 (arith -> atom .)
    EE              reduce using rule 47 (arith -> atom .)
    NE              reduce using rule 47 (arith -> atom .)
    AND             reduce using rule 47 (arith -> atom .)
    OR              reduce using rule 47 (arith -> atom .)
    BREAK           reduce using rule 47 (arith -> atom .)
    RETURN          reduce using rule 47 (arith -> atom .)
    IF              reduce using rule 47 (arith -> atom .)
    NOT             reduce using rule 47 (arith -> atom .)
    MIN             reduce using rule 47 (arith -> atom .)
    MAX             reduce using rule 47 (arith -> atom .)
    VARIABLE        reduce using rule 47 (arith -> atom .)
    (               reduce using rule 47 (arith -> atom .)
    NUMBER          reduce using rule 47 (arith -> atom .)
    BOOLEAN         reduce using rule 47 (arith -> atom .)
    STRING          reduce using rule 47 (arith -> atom .)
    WORD            reduce using rule 47 (arith -> atom .)
    FUNCTION        reduce using rule 47 (arith -> atom .)
    %               reduce using rule 47 (arith -> atom .)
    {               reduce using rule 47 (arith -> atom .)
    $end            reduce using rule 47 (arith -> atom .)
    }               reduce using rule 47 (arith -> atom .)
    )               reduce using rule 47 (arith -> atom .)
    ,               reduce using rule 47 (arith -> atom .)
    ]               reduce using rule 47 (arith -> atom .)
    #               reduce using rule 47 (arith -> atom .)

  ! -               [ reduce using rule 47 (arith -> atom .) ]
  ! +               [ reduce using rule 47 (arith -> atom .) ]
  ! *               [ reduce using rule 47 (arith -> atom .) ]
  ! /               [ reduce using rule 47 (arith -> atom .) ]


state 14

    (48) atom -> - . atom
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    atom                           shift and go to state 44
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 15

    (52) arith -> MIN . ( comma_expressions )

    (               shift and go to state 45


state 16

    (53) arith -> MAX . ( comma_expressions )

    (               shift and go to state 46


state 17

    (1) atom -> VARIABLE . = expression
    (2) atom -> VARIABLE .

    =               shift and go to state 47
    +               reduce using rule 2 (atom -> VARIABLE .)
    -               reduce using rule 2 (atom -> VARIABLE .)
    *               reduce using rule 2 (atom -> VARIABLE .)
    /               reduce using rule 2 (atom -> VARIABLE .)
    LT              reduce using rule 2 (atom -> VARIABLE .)
    LE              reduce using rule 2 (atom -> VARIABLE .)
    GT              reduce using rule 2 (atom -> VARIABLE .)
    GE              reduce using rule 2 (atom -> VARIABLE .)
    EE              reduce using rule 2 (atom -> VARIABLE .)
    NE              reduce using rule 2 (atom -> VARIABLE .)
    AND             reduce using rule 2 (atom -> VARIABLE .)
    OR              reduce using rule 2 (atom -> VARIABLE .)
    BREAK           reduce using rule 2 (atom -> VARIABLE .)
    RETURN          reduce using rule 2 (atom -> VARIABLE .)
    IF              reduce using rule 2 (atom -> VARIABLE .)
    NOT             reduce using rule 2 (atom -> VARIABLE .)
    MIN             reduce using rule 2 (atom -> VARIABLE .)
    MAX             reduce using rule 2 (atom -> VARIABLE .)
    VARIABLE        reduce using rule 2 (atom -> VARIABLE .)
    (               reduce using rule 2 (atom -> VARIABLE .)
    NUMBER          reduce using rule 2 (atom -> VARIABLE .)
    BOOLEAN         reduce using rule 2 (atom -> VARIABLE .)
    STRING          reduce using rule 2 (atom -> VARIABLE .)
    WORD            reduce using rule 2 (atom -> VARIABLE .)
    FUNCTION        reduce using rule 2 (atom -> VARIABLE .)
    %               reduce using rule 2 (atom -> VARIABLE .)
    {               reduce using rule 2 (atom -> VARIABLE .)
    $end            reduce using rule 2 (atom -> VARIABLE .)
    }               reduce using rule 2 (atom -> VARIABLE .)
    )               reduce using rule 2 (atom -> VARIABLE .)
    ,               reduce using rule 2 (atom -> VARIABLE .)
    ]               reduce using rule 2 (atom -> VARIABLE .)
    #               reduce using rule 2 (atom -> VARIABLE .)


state 18

    (32) atom -> function_call .

    +               reduce using rule 32 (atom -> function_call .)
    -               reduce using rule 32 (atom -> function_call .)
    *               reduce using rule 32 (atom -> function_call .)
    /               reduce using rule 32 (atom -> function_call .)
    LT              reduce using rule 32 (atom -> function_call .)
    LE              reduce using rule 32 (atom -> function_call .)
    GT              reduce using rule 32 (atom -> function_call .)
    GE              reduce using rule 32 (atom -> function_call .)
    EE              reduce using rule 32 (atom -> function_call .)
    NE              reduce using rule 32 (atom -> function_call .)
    AND             reduce using rule 32 (atom -> function_call .)
    OR              reduce using rule 32 (atom -> function_call .)
    BREAK           reduce using rule 32 (atom -> function_call .)
    RETURN          reduce using rule 32 (atom -> function_call .)
    IF              reduce using rule 32 (atom -> function_call .)
    NOT             reduce using rule 32 (atom -> function_call .)
    MIN             reduce using rule 32 (atom -> function_call .)
    MAX             reduce using rule 32 (atom -> function_call .)
    VARIABLE        reduce using rule 32 (atom -> function_call .)
    (               reduce using rule 32 (atom -> function_call .)
    NUMBER          reduce using rule 32 (atom -> function_call .)
    BOOLEAN         reduce using rule 32 (atom -> function_call .)
    STRING          reduce using rule 32 (atom -> function_call .)
    WORD            reduce using rule 32 (atom -> function_call .)
    FUNCTION        reduce using rule 32 (atom -> function_call .)
    %               reduce using rule 32 (atom -> function_call .)
    {               reduce using rule 32 (atom -> function_call .)
    $end            reduce using rule 32 (atom -> function_call .)
    }               reduce using rule 32 (atom -> function_call .)
    )               reduce using rule 32 (atom -> function_call .)
    ,               reduce using rule 32 (atom -> function_call .)
    ]               reduce using rule 32 (atom -> function_call .)
    #               reduce using rule 32 (atom -> function_call .)


state 19

    (65) atom -> NUMBER .

    +               reduce using rule 65 (atom -> NUMBER .)
    -               reduce using rule 65 (atom -> NUMBER .)
    *               reduce using rule 65 (atom -> NUMBER .)
    /               reduce using rule 65 (atom -> NUMBER .)
    LT              reduce using rule 65 (atom -> NUMBER .)
    LE              reduce using rule 65 (atom -> NUMBER .)
    GT              reduce using rule 65 (atom -> NUMBER .)
    GE              reduce using rule 65 (atom -> NUMBER .)
    EE              reduce using rule 65 (atom -> NUMBER .)
    NE              reduce using rule 65 (atom -> NUMBER .)
    AND             reduce using rule 65 (atom -> NUMBER .)
    OR              reduce using rule 65 (atom -> NUMBER .)
    BREAK           reduce using rule 65 (atom -> NUMBER .)
    RETURN          reduce using rule 65 (atom -> NUMBER .)
    IF              reduce using rule 65 (atom -> NUMBER .)
    NOT             reduce using rule 65 (atom -> NUMBER .)
    MIN             reduce using rule 65 (atom -> NUMBER .)
    MAX             reduce using rule 65 (atom -> NUMBER .)
    VARIABLE        reduce using rule 65 (atom -> NUMBER .)
    (               reduce using rule 65 (atom -> NUMBER .)
    NUMBER          reduce using rule 65 (atom -> NUMBER .)
    BOOLEAN         reduce using rule 65 (atom -> NUMBER .)
    STRING          reduce using rule 65 (atom -> NUMBER .)
    WORD            reduce using rule 65 (atom -> NUMBER .)
    FUNCTION        reduce using rule 65 (atom -> NUMBER .)
    %               reduce using rule 65 (atom -> NUMBER .)
    {               reduce using rule 65 (atom -> NUMBER .)
    $end            reduce using rule 65 (atom -> NUMBER .)
    }               reduce using rule 65 (atom -> NUMBER .)
    )               reduce using rule 65 (atom -> NUMBER .)
    ,               reduce using rule 65 (atom -> NUMBER .)
    ]               reduce using rule 65 (atom -> NUMBER .)
    #               reduce using rule 65 (atom -> NUMBER .)


state 20

    (66) atom -> BOOLEAN .

    +               reduce using rule 66 (atom -> BOOLEAN .)
    -               reduce using rule 66 (atom -> BOOLEAN .)
    *               reduce using rule 66 (atom -> BOOLEAN .)
    /               reduce using rule 66 (atom -> BOOLEAN .)
    LT              reduce using rule 66 (atom -> BOOLEAN .)
    LE              reduce using rule 66 (atom -> BOOLEAN .)
    GT              reduce using rule 66 (atom -> BOOLEAN .)
    GE              reduce using rule 66 (atom -> BOOLEAN .)
    EE              reduce using rule 66 (atom -> BOOLEAN .)
    NE              reduce using rule 66 (atom -> BOOLEAN .)
    AND             reduce using rule 66 (atom -> BOOLEAN .)
    OR              reduce using rule 66 (atom -> BOOLEAN .)
    BREAK           reduce using rule 66 (atom -> BOOLEAN .)
    RETURN          reduce using rule 66 (atom -> BOOLEAN .)
    IF              reduce using rule 66 (atom -> BOOLEAN .)
    NOT             reduce using rule 66 (atom -> BOOLEAN .)
    MIN             reduce using rule 66 (atom -> BOOLEAN .)
    MAX             reduce using rule 66 (atom -> BOOLEAN .)
    VARIABLE        reduce using rule 66 (atom -> BOOLEAN .)
    (               reduce using rule 66 (atom -> BOOLEAN .)
    NUMBER          reduce using rule 66 (atom -> BOOLEAN .)
    BOOLEAN         reduce using rule 66 (atom -> BOOLEAN .)
    STRING          reduce using rule 66 (atom -> BOOLEAN .)
    WORD            reduce using rule 66 (atom -> BOOLEAN .)
    FUNCTION        reduce using rule 66 (atom -> BOOLEAN .)
    %               reduce using rule 66 (atom -> BOOLEAN .)
    {               reduce using rule 66 (atom -> BOOLEAN .)
    $end            reduce using rule 66 (atom -> BOOLEAN .)
    }               reduce using rule 66 (atom -> BOOLEAN .)
    )               reduce using rule 66 (atom -> BOOLEAN .)
    ,               reduce using rule 66 (atom -> BOOLEAN .)
    ]               reduce using rule 66 (atom -> BOOLEAN .)
    #               reduce using rule 66 (atom -> BOOLEAN .)


state 21

    (67) atom -> STRING .

    +               reduce using rule 67 (atom -> STRING .)
    -               reduce using rule 67 (atom -> STRING .)
    *               reduce using rule 67 (atom -> STRING .)
    /               reduce using rule 67 (atom -> STRING .)
    LT              reduce using rule 67 (atom -> STRING .)
    LE              reduce using rule 67 (atom -> STRING .)
    GT              reduce using rule 67 (atom -> STRING .)
    GE              reduce using rule 67 (atom -> STRING .)
    EE              reduce using rule 67 (atom -> STRING .)
    NE              reduce using rule 67 (atom -> STRING .)
    AND             reduce using rule 67 (atom -> STRING .)
    OR              reduce using rule 67 (atom -> STRING .)
    BREAK           reduce using rule 67 (atom -> STRING .)
    RETURN          reduce using rule 67 (atom -> STRING .)
    IF              reduce using rule 67 (atom -> STRING .)
    NOT             reduce using rule 67 (atom -> STRING .)
    MIN             reduce using rule 67 (atom -> STRING .)
    MAX             reduce using rule 67 (atom -> STRING .)
    VARIABLE        reduce using rule 67 (atom -> STRING .)
    (               reduce using rule 67 (atom -> STRING .)
    NUMBER          reduce using rule 67 (atom -> STRING .)
    BOOLEAN         reduce using rule 67 (atom -> STRING .)
    STRING          reduce using rule 67 (atom -> STRING .)
    WORD            reduce using rule 67 (atom -> STRING .)
    FUNCTION        reduce using rule 67 (atom -> STRING .)
    %               reduce using rule 67 (atom -> STRING .)
    {               reduce using rule 67 (atom -> STRING .)
    $end            reduce using rule 67 (atom -> STRING .)
    }               reduce using rule 67 (atom -> STRING .)
    )               reduce using rule 67 (atom -> STRING .)
    ,               reduce using rule 67 (atom -> STRING .)
    ]               reduce using rule 67 (atom -> STRING .)
    #               reduce using rule 67 (atom -> STRING .)


state 22

    (68) atom -> table .

    +               reduce using rule 68 (atom -> table .)
    -               reduce using rule 68 (atom -> table .)
    *               reduce using rule 68 (atom -> table .)
    /               reduce using rule 68 (atom -> table .)
    LT              reduce using rule 68 (atom -> table .)
    LE              reduce using rule 68 (atom -> table .)
    GT              reduce using rule 68 (atom -> table .)
    GE              reduce using rule 68 (atom -> table .)
    EE              reduce using rule 68 (atom -> table .)
    NE              reduce using rule 68 (atom -> table .)
    AND             reduce using rule 68 (atom -> table .)
    OR              reduce using rule 68 (atom -> table .)
    BREAK           reduce using rule 68 (atom -> table .)
    RETURN          reduce using rule 68 (atom -> table .)
    IF              reduce using rule 68 (atom -> table .)
    NOT             reduce using rule 68 (atom -> table .)
    MIN             reduce using rule 68 (atom -> table .)
    MAX             reduce using rule 68 (atom -> table .)
    VARIABLE        reduce using rule 68 (atom -> table .)
    (               reduce using rule 68 (atom -> table .)
    NUMBER          reduce using rule 68 (atom -> table .)
    BOOLEAN         reduce using rule 68 (atom -> table .)
    STRING          reduce using rule 68 (atom -> table .)
    WORD            reduce using rule 68 (atom -> table .)
    FUNCTION        reduce using rule 68 (atom -> table .)
    %               reduce using rule 68 (atom -> table .)
    {               reduce using rule 68 (atom -> table .)
    $end            reduce using rule 68 (atom -> table .)
    }               reduce using rule 68 (atom -> table .)
    )               reduce using rule 68 (atom -> table .)
    ,               reduce using rule 68 (atom -> table .)
    ]               reduce using rule 68 (atom -> table .)
    #               reduce using rule 68 (atom -> table .)


state 23

    (69) atom -> WORD .

    +               reduce using rule 69 (atom -> WORD .)
    -               reduce using rule 69 (atom -> WORD .)
    *               reduce using rule 69 (atom -> WORD .)
    /               reduce using rule 69 (atom -> WORD .)
    LT              reduce using rule 69 (atom -> WORD .)
    LE              reduce using rule 69 (atom -> WORD .)
    GT              reduce using rule 69 (atom -> WORD .)
    GE              reduce using rule 69 (atom -> WORD .)
    EE              reduce using rule 69 (atom -> WORD .)
    NE              reduce using rule 69 (atom -> WORD .)
    AND             reduce using rule 69 (atom -> WORD .)
    OR              reduce using rule 69 (atom -> WORD .)
    BREAK           reduce using rule 69 (atom -> WORD .)
    RETURN          reduce using rule 69 (atom -> WORD .)
    IF              reduce using rule 69 (atom -> WORD .)
    NOT             reduce using rule 69 (atom -> WORD .)
    MIN             reduce using rule 69 (atom -> WORD .)
    MAX             reduce using rule 69 (atom -> WORD .)
    VARIABLE        reduce using rule 69 (atom -> WORD .)
    (               reduce using rule 69 (atom -> WORD .)
    NUMBER          reduce using rule 69 (atom -> WORD .)
    BOOLEAN         reduce using rule 69 (atom -> WORD .)
    STRING          reduce using rule 69 (atom -> WORD .)
    WORD            reduce using rule 69 (atom -> WORD .)
    FUNCTION        reduce using rule 69 (atom -> WORD .)
    %               reduce using rule 69 (atom -> WORD .)
    {               reduce using rule 69 (atom -> WORD .)
    $end            reduce using rule 69 (atom -> WORD .)
    }               reduce using rule 69 (atom -> WORD .)
    )               reduce using rule 69 (atom -> WORD .)
    ,               reduce using rule 69 (atom -> WORD .)
    ]               reduce using rule 69 (atom -> WORD .)
    #               reduce using rule 69 (atom -> WORD .)


state 24

    (10) function_call -> FUNCTION . parameters scope
    (11) function_call -> FUNCTION . parameters tag_list
    (12) function_call -> FUNCTION . parameters
    (13) function_call -> FUNCTION .
    (20) parameters -> . ( param_element )
    (21) parameters -> . ( )

  ! shift/reduce conflict for ( resolved as shift
    +               reduce using rule 13 (function_call -> FUNCTION .)
    -               reduce using rule 13 (function_call -> FUNCTION .)
    *               reduce using rule 13 (function_call -> FUNCTION .)
    /               reduce using rule 13 (function_call -> FUNCTION .)
    LT              reduce using rule 13 (function_call -> FUNCTION .)
    LE              reduce using rule 13 (function_call -> FUNCTION .)
    GT              reduce using rule 13 (function_call -> FUNCTION .)
    GE              reduce using rule 13 (function_call -> FUNCTION .)
    EE              reduce using rule 13 (function_call -> FUNCTION .)
    NE              reduce using rule 13 (function_call -> FUNCTION .)
    AND             reduce using rule 13 (function_call -> FUNCTION .)
    OR              reduce using rule 13 (function_call -> FUNCTION .)
    BREAK           reduce using rule 13 (function_call -> FUNCTION .)
    RETURN          reduce using rule 13 (function_call -> FUNCTION .)
    IF              reduce using rule 13 (function_call -> FUNCTION .)
    NOT             reduce using rule 13 (function_call -> FUNCTION .)
    MIN             reduce using rule 13 (function_call -> FUNCTION .)
    MAX             reduce using rule 13 (function_call -> FUNCTION .)
    VARIABLE        reduce using rule 13 (function_call -> FUNCTION .)
    NUMBER          reduce using rule 13 (function_call -> FUNCTION .)
    BOOLEAN         reduce using rule 13 (function_call -> FUNCTION .)
    STRING          reduce using rule 13 (function_call -> FUNCTION .)
    WORD            reduce using rule 13 (function_call -> FUNCTION .)
    FUNCTION        reduce using rule 13 (function_call -> FUNCTION .)
    %               reduce using rule 13 (function_call -> FUNCTION .)
    {               reduce using rule 13 (function_call -> FUNCTION .)
    $end            reduce using rule 13 (function_call -> FUNCTION .)
    }               reduce using rule 13 (function_call -> FUNCTION .)
    )               reduce using rule 13 (function_call -> FUNCTION .)
    ,               reduce using rule 13 (function_call -> FUNCTION .)
    ]               reduce using rule 13 (function_call -> FUNCTION .)
    #               reduce using rule 13 (function_call -> FUNCTION .)
    (               shift and go to state 49

  ! (               [ reduce using rule 13 (function_call -> FUNCTION .) ]

    parameters                     shift and go to state 48

state 25

    (63) table -> % . [ comma_expressions ]
    (64) table -> % . { table_contents }

    [               shift and go to state 50
    {               shift and go to state 51


state 26

    (17) scope -> { . expressions }
    (18) expressions -> . statement expressions
    (19) expressions -> . statement
    (29) statement -> . BREAK
    (30) statement -> . expression
    (31) statement -> . if_condition
    (55) statement -> . RETURN expression
    (56) statement -> . RETURN
    (71) expression -> . comp
    (7) if_condition -> . IF ( expression ) scope elif_branch
    (8) if_condition -> . IF ( expression ) scope else_branch
    (9) if_condition -> . IF ( expression ) scope
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    BREAK           shift and go to state 3
    RETURN          shift and go to state 6
    IF              shift and go to state 8
    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    expressions                    shift and go to state 52
    statement                      shift and go to state 2
    expression                     shift and go to state 4
    if_condition                   shift and go to state 5
    comp                           shift and go to state 7
    scope                          shift and go to state 10
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22

state 27

    (18) expressions -> statement expressions .

    $end            reduce using rule 18 (expressions -> statement expressions .)
    }               reduce using rule 18 (expressions -> statement expressions .)


state 28

    (55) statement -> RETURN expression .

    BREAK           reduce using rule 55 (statement -> RETURN expression .)
    RETURN          reduce using rule 55 (statement -> RETURN expression .)
    IF              reduce using rule 55 (statement -> RETURN expression .)
    NOT             reduce using rule 55 (statement -> RETURN expression .)
    MIN             reduce using rule 55 (statement -> RETURN expression .)
    MAX             reduce using rule 55 (statement -> RETURN expression .)
    VARIABLE        reduce using rule 55 (statement -> RETURN expression .)
    -               reduce using rule 55 (statement -> RETURN expression .)
    (               reduce using rule 55 (statement -> RETURN expression .)
    NUMBER          reduce using rule 55 (statement -> RETURN expression .)
    BOOLEAN         reduce using rule 55 (statement -> RETURN expression .)
    STRING          reduce using rule 55 (statement -> RETURN expression .)
    WORD            reduce using rule 55 (statement -> RETURN expression .)
    FUNCTION        reduce using rule 55 (statement -> RETURN expression .)
    %               reduce using rule 55 (statement -> RETURN expression .)
    {               reduce using rule 55 (statement -> RETURN expression .)
    $end            reduce using rule 55 (statement -> RETURN expression .)
    }               reduce using rule 55 (statement -> RETURN expression .)


state 29

    (40) comp -> comp AND . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    comp                           shift and go to state 53
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 30

    (41) comp -> comp OR . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    comp                           shift and go to state 54
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 31

    (7) if_condition -> IF ( . expression ) scope elif_branch
    (8) if_condition -> IF ( . expression ) scope else_branch
    (9) if_condition -> IF ( . expression ) scope
    (71) expression -> . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    expression                     shift and go to state 55
    scope                          shift and go to state 10
    comp                           shift and go to state 7
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22

state 32

    (54) atom -> ( expression . )

    )               shift and go to state 56


state 33

    (33) comp -> NOT comp .
    (40) comp -> comp . AND comp
    (41) comp -> comp . OR comp

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    BREAK           reduce using rule 33 (comp -> NOT comp .)
    RETURN          reduce using rule 33 (comp -> NOT comp .)
    IF              reduce using rule 33 (comp -> NOT comp .)
    NOT             reduce using rule 33 (comp -> NOT comp .)
    MIN             reduce using rule 33 (comp -> NOT comp .)
    MAX             reduce using rule 33 (comp -> NOT comp .)
    VARIABLE        reduce using rule 33 (comp -> NOT comp .)
    -               reduce using rule 33 (comp -> NOT comp .)
    (               reduce using rule 33 (comp -> NOT comp .)
    NUMBER          reduce using rule 33 (comp -> NOT comp .)
    BOOLEAN         reduce using rule 33 (comp -> NOT comp .)
    STRING          reduce using rule 33 (comp -> NOT comp .)
    WORD            reduce using rule 33 (comp -> NOT comp .)
    FUNCTION        reduce using rule 33 (comp -> NOT comp .)
    %               reduce using rule 33 (comp -> NOT comp .)
    {               reduce using rule 33 (comp -> NOT comp .)
    $end            reduce using rule 33 (comp -> NOT comp .)
    }               reduce using rule 33 (comp -> NOT comp .)
    )               reduce using rule 33 (comp -> NOT comp .)
    ,               reduce using rule 33 (comp -> NOT comp .)
    +               reduce using rule 33 (comp -> NOT comp .)
    *               reduce using rule 33 (comp -> NOT comp .)
    /               reduce using rule 33 (comp -> NOT comp .)
    LT              reduce using rule 33 (comp -> NOT comp .)
    LE              reduce using rule 33 (comp -> NOT comp .)
    GT              reduce using rule 33 (comp -> NOT comp .)
    GE              reduce using rule 33 (comp -> NOT comp .)
    EE              reduce using rule 33 (comp -> NOT comp .)
    NE              reduce using rule 33 (comp -> NOT comp .)
    ]               reduce using rule 33 (comp -> NOT comp .)
    #               reduce using rule 33 (comp -> NOT comp .)
    AND             shift and go to state 29
    OR              shift and go to state 30

  ! AND             [ reduce using rule 33 (comp -> NOT comp .) ]
  ! OR              [ reduce using rule 33 (comp -> NOT comp .) ]


state 34

    (34) comp -> arith LT . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    arith                          shift and go to state 57
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 35

    (35) comp -> arith LE . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    arith                          shift and go to state 58
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 36

    (36) comp -> arith GT . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    arith                          shift and go to state 59
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 37

    (37) comp -> arith GE . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    arith                          shift and go to state 60
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 38

    (38) comp -> arith EE . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    arith                          shift and go to state 61
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 39

    (39) comp -> arith NE . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    arith                          shift and go to state 62
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 40

    (43) arith -> atom + . atom
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    atom                           shift and go to state 63
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 41

    (44) arith -> atom - . atom
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    atom                           shift and go to state 64
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 42

    (45) arith -> atom * . atom
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    atom                           shift and go to state 65
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 43

    (46) arith -> atom / . atom
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    atom                           shift and go to state 66
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 44

    (48) atom -> - atom .

    +               reduce using rule 48 (atom -> - atom .)
    -               reduce using rule 48 (atom -> - atom .)
    *               reduce using rule 48 (atom -> - atom .)
    /               reduce using rule 48 (atom -> - atom .)
    LT              reduce using rule 48 (atom -> - atom .)
    LE              reduce using rule 48 (atom -> - atom .)
    GT              reduce using rule 48 (atom -> - atom .)
    GE              reduce using rule 48 (atom -> - atom .)
    EE              reduce using rule 48 (atom -> - atom .)
    NE              reduce using rule 48 (atom -> - atom .)
    AND             reduce using rule 48 (atom -> - atom .)
    OR              reduce using rule 48 (atom -> - atom .)
    BREAK           reduce using rule 48 (atom -> - atom .)
    RETURN          reduce using rule 48 (atom -> - atom .)
    IF              reduce using rule 48 (atom -> - atom .)
    NOT             reduce using rule 48 (atom -> - atom .)
    MIN             reduce using rule 48 (atom -> - atom .)
    MAX             reduce using rule 48 (atom -> - atom .)
    VARIABLE        reduce using rule 48 (atom -> - atom .)
    (               reduce using rule 48 (atom -> - atom .)
    NUMBER          reduce using rule 48 (atom -> - atom .)
    BOOLEAN         reduce using rule 48 (atom -> - atom .)
    STRING          reduce using rule 48 (atom -> - atom .)
    WORD            reduce using rule 48 (atom -> - atom .)
    FUNCTION        reduce using rule 48 (atom -> - atom .)
    %               reduce using rule 48 (atom -> - atom .)
    {               reduce using rule 48 (atom -> - atom .)
    $end            reduce using rule 48 (atom -> - atom .)
    }               reduce using rule 48 (atom -> - atom .)
    )               reduce using rule 48 (atom -> - atom .)
    ,               reduce using rule 48 (atom -> - atom .)
    ]               reduce using rule 48 (atom -> - atom .)
    #               reduce using rule 48 (atom -> - atom .)


state 45

    (52) arith -> MIN ( . comma_expressions )
    (49) comma_expressions -> . expression , comma_expressions
    (50) comma_expressions -> . expression ,
    (51) comma_expressions -> . expression
    (71) expression -> . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    comma_expressions              shift and go to state 67
    expression                     shift and go to state 68
    comp                           shift and go to state 7
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 46

    (53) arith -> MAX ( . comma_expressions )
    (49) comma_expressions -> . expression , comma_expressions
    (50) comma_expressions -> . expression ,
    (51) comma_expressions -> . expression
    (71) expression -> . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    comma_expressions              shift and go to state 69
    expression                     shift and go to state 68
    comp                           shift and go to state 7
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 47

    (1) atom -> VARIABLE = . expression
    (71) expression -> . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    expression                     shift and go to state 70
    comp                           shift and go to state 7
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 48

    (10) function_call -> FUNCTION parameters . scope
    (11) function_call -> FUNCTION parameters . tag_list
    (12) function_call -> FUNCTION parameters .
    (17) scope -> . { expressions }
    (15) tag_list -> . tag # scope tag_list
    (16) tag_list -> . tag # scope
    (14) tag -> . TAG expression

  ! shift/reduce conflict for { resolved as shift
    +               reduce using rule 12 (function_call -> FUNCTION parameters .)
    -               reduce using rule 12 (function_call -> FUNCTION parameters .)
    *               reduce using rule 12 (function_call -> FUNCTION parameters .)
    /               reduce using rule 12 (function_call -> FUNCTION parameters .)
    LT              reduce using rule 12 (function_call -> FUNCTION parameters .)
    LE              reduce using rule 12 (function_call -> FUNCTION parameters .)
    GT              reduce using rule 12 (function_call -> FUNCTION parameters .)
    GE              reduce using rule 12 (function_call -> FUNCTION parameters .)
    EE              reduce using rule 12 (function_call -> FUNCTION parameters .)
    NE              reduce using rule 12 (function_call -> FUNCTION parameters .)
    AND             reduce using rule 12 (function_call -> FUNCTION parameters .)
    OR              reduce using rule 12 (function_call -> FUNCTION parameters .)
    BREAK           reduce using rule 12 (function_call -> FUNCTION parameters .)
    RETURN          reduce using rule 12 (function_call -> FUNCTION parameters .)
    IF              reduce using rule 12 (function_call -> FUNCTION parameters .)
    NOT             reduce using rule 12 (function_call -> FUNCTION parameters .)
    MIN             reduce using rule 12 (function_call -> FUNCTION parameters .)
    MAX             reduce using rule 12 (function_call -> FUNCTION parameters .)
    VARIABLE        reduce using rule 12 (function_call -> FUNCTION parameters .)
    (               reduce using rule 12 (function_call -> FUNCTION parameters .)
    NUMBER          reduce using rule 12 (function_call -> FUNCTION parameters .)
    BOOLEAN         reduce using rule 12 (function_call -> FUNCTION parameters .)
    STRING          reduce using rule 12 (function_call -> FUNCTION parameters .)
    WORD            reduce using rule 12 (function_call -> FUNCTION parameters .)
    FUNCTION        reduce using rule 12 (function_call -> FUNCTION parameters .)
    %               reduce using rule 12 (function_call -> FUNCTION parameters .)
    $end            reduce using rule 12 (function_call -> FUNCTION parameters .)
    }               reduce using rule 12 (function_call -> FUNCTION parameters .)
    )               reduce using rule 12 (function_call -> FUNCTION parameters .)
    ,               reduce using rule 12 (function_call -> FUNCTION parameters .)
    ]               reduce using rule 12 (function_call -> FUNCTION parameters .)
    #               reduce using rule 12 (function_call -> FUNCTION parameters .)
    {               shift and go to state 26
    TAG             shift and go to state 74

  ! {               [ reduce using rule 12 (function_call -> FUNCTION parameters .) ]

    scope                          shift and go to state 71
    tag_list                       shift and go to state 72
    tag                            shift and go to state 73

state 49

    (20) parameters -> ( . param_element )
    (21) parameters -> ( . )
    (25) param_element -> . expression , param_element
    (26) param_element -> . expression , param_element_pos
    (27) param_element -> . expression ,
    (28) param_element -> . expression
    (71) expression -> . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    )               shift and go to state 76
    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    param_element                  shift and go to state 75
    expression                     shift and go to state 77
    comp                           shift and go to state 7
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 50

    (63) table -> % [ . comma_expressions ]
    (49) comma_expressions -> . expression , comma_expressions
    (50) comma_expressions -> . expression ,
    (51) comma_expressions -> . expression
    (71) expression -> . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    comma_expressions              shift and go to state 78
    expression                     shift and go to state 68
    comp                           shift and go to state 7
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 51

    (64) table -> % { . table_contents }
    (57) table_contents -> . STRING : expression , table_contents
    (58) table_contents -> . NUMBER : expression , table_contents
    (59) table_contents -> . STRING : expression ,
    (60) table_contents -> . NUMBER : expression ,
    (61) table_contents -> . STRING : expression
    (62) table_contents -> . NUMBER : expression

    STRING          shift and go to state 80
    NUMBER          shift and go to state 81

    table_contents                 shift and go to state 79

state 52

    (17) scope -> { expressions . }

    }               shift and go to state 82


state 53

    (40) comp -> comp AND comp .
    (40) comp -> comp . AND comp
    (41) comp -> comp . OR comp

    AND             reduce using rule 40 (comp -> comp AND comp .)
    OR              reduce using rule 40 (comp -> comp AND comp .)
    BREAK           reduce using rule 40 (comp -> comp AND comp .)
    RETURN          reduce using rule 40 (comp -> comp AND comp .)
    IF              reduce using rule 40 (comp -> comp AND comp .)
    NOT             reduce using rule 40 (comp -> comp AND comp .)
    MIN             reduce using rule 40 (comp -> comp AND comp .)
    MAX             reduce using rule 40 (comp -> comp AND comp .)
    VARIABLE        reduce using rule 40 (comp -> comp AND comp .)
    -               reduce using rule 40 (comp -> comp AND comp .)
    (               reduce using rule 40 (comp -> comp AND comp .)
    NUMBER          reduce using rule 40 (comp -> comp AND comp .)
    BOOLEAN         reduce using rule 40 (comp -> comp AND comp .)
    STRING          reduce using rule 40 (comp -> comp AND comp .)
    WORD            reduce using rule 40 (comp -> comp AND comp .)
    FUNCTION        reduce using rule 40 (comp -> comp AND comp .)
    %               reduce using rule 40 (comp -> comp AND comp .)
    {               reduce using rule 40 (comp -> comp AND comp .)
    $end            reduce using rule 40 (comp -> comp AND comp .)
    }               reduce using rule 40 (comp -> comp AND comp .)
    )               reduce using rule 40 (comp -> comp AND comp .)
    ,               reduce using rule 40 (comp -> comp AND comp .)
    +               reduce using rule 40 (comp -> comp AND comp .)
    *               reduce using rule 40 (comp -> comp AND comp .)
    /               reduce using rule 40 (comp -> comp AND comp .)
    LT              reduce using rule 40 (comp -> comp AND comp .)
    LE              reduce using rule 40 (comp -> comp AND comp .)
    GT              reduce using rule 40 (comp -> comp AND comp .)
    GE              reduce using rule 40 (comp -> comp AND comp .)
    EE              reduce using rule 40 (comp -> comp AND comp .)
    NE              reduce using rule 40 (comp -> comp AND comp .)
    ]               reduce using rule 40 (comp -> comp AND comp .)
    #               reduce using rule 40 (comp -> comp AND comp .)

  ! AND             [ shift and go to state 29 ]
  ! OR              [ shift and go to state 30 ]


state 54

    (41) comp -> comp OR comp .
    (40) comp -> comp . AND comp
    (41) comp -> comp . OR comp

    AND             reduce using rule 41 (comp -> comp OR comp .)
    OR              reduce using rule 41 (comp -> comp OR comp .)
    BREAK           reduce using rule 41 (comp -> comp OR comp .)
    RETURN          reduce using rule 41 (comp -> comp OR comp .)
    IF              reduce using rule 41 (comp -> comp OR comp .)
    NOT             reduce using rule 41 (comp -> comp OR comp .)
    MIN             reduce using rule 41 (comp -> comp OR comp .)
    MAX             reduce using rule 41 (comp -> comp OR comp .)
    VARIABLE        reduce using rule 41 (comp -> comp OR comp .)
    -               reduce using rule 41 (comp -> comp OR comp .)
    (               reduce using rule 41 (comp -> comp OR comp .)
    NUMBER          reduce using rule 41 (comp -> comp OR comp .)
    BOOLEAN         reduce using rule 41 (comp -> comp OR comp .)
    STRING          reduce using rule 41 (comp -> comp OR comp .)
    WORD            reduce using rule 41 (comp -> comp OR comp .)
    FUNCTION        reduce using rule 41 (comp -> comp OR comp .)
    %               reduce using rule 41 (comp -> comp OR comp .)
    {               reduce using rule 41 (comp -> comp OR comp .)
    $end            reduce using rule 41 (comp -> comp OR comp .)
    }               reduce using rule 41 (comp -> comp OR comp .)
    )               reduce using rule 41 (comp -> comp OR comp .)
    ,               reduce using rule 41 (comp -> comp OR comp .)
    +               reduce using rule 41 (comp -> comp OR comp .)
    *               reduce using rule 41 (comp -> comp OR comp .)
    /               reduce using rule 41 (comp -> comp OR comp .)
    LT              reduce using rule 41 (comp -> comp OR comp .)
    LE              reduce using rule 41 (comp -> comp OR comp .)
    GT              reduce using rule 41 (comp -> comp OR comp .)
    GE              reduce using rule 41 (comp -> comp OR comp .)
    EE              reduce using rule 41 (comp -> comp OR comp .)
    NE              reduce using rule 41 (comp -> comp OR comp .)
    ]               reduce using rule 41 (comp -> comp OR comp .)
    #               reduce using rule 41 (comp -> comp OR comp .)

  ! AND             [ shift and go to state 29 ]
  ! OR              [ shift and go to state 30 ]


state 55

    (7) if_condition -> IF ( expression . ) scope elif_branch
    (8) if_condition -> IF ( expression . ) scope else_branch
    (9) if_condition -> IF ( expression . ) scope

    )               shift and go to state 83


state 56

    (54) atom -> ( expression ) .

    +               reduce using rule 54 (atom -> ( expression ) .)
    -               reduce using rule 54 (atom -> ( expression ) .)
    *               reduce using rule 54 (atom -> ( expression ) .)
    /               reduce using rule 54 (atom -> ( expression ) .)
    LT              reduce using rule 54 (atom -> ( expression ) .)
    LE              reduce using rule 54 (atom -> ( expression ) .)
    GT              reduce using rule 54 (atom -> ( expression ) .)
    GE              reduce using rule 54 (atom -> ( expression ) .)
    EE              reduce using rule 54 (atom -> ( expression ) .)
    NE              reduce using rule 54 (atom -> ( expression ) .)
    AND             reduce using rule 54 (atom -> ( expression ) .)
    OR              reduce using rule 54 (atom -> ( expression ) .)
    BREAK           reduce using rule 54 (atom -> ( expression ) .)
    RETURN          reduce using rule 54 (atom -> ( expression ) .)
    IF              reduce using rule 54 (atom -> ( expression ) .)
    NOT             reduce using rule 54 (atom -> ( expression ) .)
    MIN             reduce using rule 54 (atom -> ( expression ) .)
    MAX             reduce using rule 54 (atom -> ( expression ) .)
    VARIABLE        reduce using rule 54 (atom -> ( expression ) .)
    (               reduce using rule 54 (atom -> ( expression ) .)
    NUMBER          reduce using rule 54 (atom -> ( expression ) .)
    BOOLEAN         reduce using rule 54 (atom -> ( expression ) .)
    STRING          reduce using rule 54 (atom -> ( expression ) .)
    WORD            reduce using rule 54 (atom -> ( expression ) .)
    FUNCTION        reduce using rule 54 (atom -> ( expression ) .)
    %               reduce using rule 54 (atom -> ( expression ) .)
    {               reduce using rule 54 (atom -> ( expression ) .)
    $end            reduce using rule 54 (atom -> ( expression ) .)
    }               reduce using rule 54 (atom -> ( expression ) .)
    )               reduce using rule 54 (atom -> ( expression ) .)
    ,               reduce using rule 54 (atom -> ( expression ) .)
    ]               reduce using rule 54 (atom -> ( expression ) .)
    #               reduce using rule 54 (atom -> ( expression ) .)


state 57

    (34) comp -> arith LT arith .

    AND             reduce using rule 34 (comp -> arith LT arith .)
    OR              reduce using rule 34 (comp -> arith LT arith .)
    BREAK           reduce using rule 34 (comp -> arith LT arith .)
    RETURN          reduce using rule 34 (comp -> arith LT arith .)
    IF              reduce using rule 34 (comp -> arith LT arith .)
    NOT             reduce using rule 34 (comp -> arith LT arith .)
    MIN             reduce using rule 34 (comp -> arith LT arith .)
    MAX             reduce using rule 34 (comp -> arith LT arith .)
    VARIABLE        reduce using rule 34 (comp -> arith LT arith .)
    -               reduce using rule 34 (comp -> arith LT arith .)
    (               reduce using rule 34 (comp -> arith LT arith .)
    NUMBER          reduce using rule 34 (comp -> arith LT arith .)
    BOOLEAN         reduce using rule 34 (comp -> arith LT arith .)
    STRING          reduce using rule 34 (comp -> arith LT arith .)
    WORD            reduce using rule 34 (comp -> arith LT arith .)
    FUNCTION        reduce using rule 34 (comp -> arith LT arith .)
    %               reduce using rule 34 (comp -> arith LT arith .)
    {               reduce using rule 34 (comp -> arith LT arith .)
    $end            reduce using rule 34 (comp -> arith LT arith .)
    }               reduce using rule 34 (comp -> arith LT arith .)
    )               reduce using rule 34 (comp -> arith LT arith .)
    ,               reduce using rule 34 (comp -> arith LT arith .)
    +               reduce using rule 34 (comp -> arith LT arith .)
    *               reduce using rule 34 (comp -> arith LT arith .)
    /               reduce using rule 34 (comp -> arith LT arith .)
    LT              reduce using rule 34 (comp -> arith LT arith .)
    LE              reduce using rule 34 (comp -> arith LT arith .)
    GT              reduce using rule 34 (comp -> arith LT arith .)
    GE              reduce using rule 34 (comp -> arith LT arith .)
    EE              reduce using rule 34 (comp -> arith LT arith .)
    NE              reduce using rule 34 (comp -> arith LT arith .)
    ]               reduce using rule 34 (comp -> arith LT arith .)
    #               reduce using rule 34 (comp -> arith LT arith .)


state 58

    (35) comp -> arith LE arith .

    AND             reduce using rule 35 (comp -> arith LE arith .)
    OR              reduce using rule 35 (comp -> arith LE arith .)
    BREAK           reduce using rule 35 (comp -> arith LE arith .)
    RETURN          reduce using rule 35 (comp -> arith LE arith .)
    IF              reduce using rule 35 (comp -> arith LE arith .)
    NOT             reduce using rule 35 (comp -> arith LE arith .)
    MIN             reduce using rule 35 (comp -> arith LE arith .)
    MAX             reduce using rule 35 (comp -> arith LE arith .)
    VARIABLE        reduce using rule 35 (comp -> arith LE arith .)
    -               reduce using rule 35 (comp -> arith LE arith .)
    (               reduce using rule 35 (comp -> arith LE arith .)
    NUMBER          reduce using rule 35 (comp -> arith LE arith .)
    BOOLEAN         reduce using rule 35 (comp -> arith LE arith .)
    STRING          reduce using rule 35 (comp -> arith LE arith .)
    WORD            reduce using rule 35 (comp -> arith LE arith .)
    FUNCTION        reduce using rule 35 (comp -> arith LE arith .)
    %               reduce using rule 35 (comp -> arith LE arith .)
    {               reduce using rule 35 (comp -> arith LE arith .)
    $end            reduce using rule 35 (comp -> arith LE arith .)
    }               reduce using rule 35 (comp -> arith LE arith .)
    )               reduce using rule 35 (comp -> arith LE arith .)
    ,               reduce using rule 35 (comp -> arith LE arith .)
    +               reduce using rule 35 (comp -> arith LE arith .)
    *               reduce using rule 35 (comp -> arith LE arith .)
    /               reduce using rule 35 (comp -> arith LE arith .)
    LT              reduce using rule 35 (comp -> arith LE arith .)
    LE              reduce using rule 35 (comp -> arith LE arith .)
    GT              reduce using rule 35 (comp -> arith LE arith .)
    GE              reduce using rule 35 (comp -> arith LE arith .)
    EE              reduce using rule 35 (comp -> arith LE arith .)
    NE              reduce using rule 35 (comp -> arith LE arith .)
    ]               reduce using rule 35 (comp -> arith LE arith .)
    #               reduce using rule 35 (comp -> arith LE arith .)


state 59

    (36) comp -> arith GT arith .

    AND             reduce using rule 36 (comp -> arith GT arith .)
    OR              reduce using rule 36 (comp -> arith GT arith .)
    BREAK           reduce using rule 36 (comp -> arith GT arith .)
    RETURN          reduce using rule 36 (comp -> arith GT arith .)
    IF              reduce using rule 36 (comp -> arith GT arith .)
    NOT             reduce using rule 36 (comp -> arith GT arith .)
    MIN             reduce using rule 36 (comp -> arith GT arith .)
    MAX             reduce using rule 36 (comp -> arith GT arith .)
    VARIABLE        reduce using rule 36 (comp -> arith GT arith .)
    -               reduce using rule 36 (comp -> arith GT arith .)
    (               reduce using rule 36 (comp -> arith GT arith .)
    NUMBER          reduce using rule 36 (comp -> arith GT arith .)
    BOOLEAN         reduce using rule 36 (comp -> arith GT arith .)
    STRING          reduce using rule 36 (comp -> arith GT arith .)
    WORD            reduce using rule 36 (comp -> arith GT arith .)
    FUNCTION        reduce using rule 36 (comp -> arith GT arith .)
    %               reduce using rule 36 (comp -> arith GT arith .)
    {               reduce using rule 36 (comp -> arith GT arith .)
    $end            reduce using rule 36 (comp -> arith GT arith .)
    }               reduce using rule 36 (comp -> arith GT arith .)
    )               reduce using rule 36 (comp -> arith GT arith .)
    ,               reduce using rule 36 (comp -> arith GT arith .)
    +               reduce using rule 36 (comp -> arith GT arith .)
    *               reduce using rule 36 (comp -> arith GT arith .)
    /               reduce using rule 36 (comp -> arith GT arith .)
    LT              reduce using rule 36 (comp -> arith GT arith .)
    LE              reduce using rule 36 (comp -> arith GT arith .)
    GT              reduce using rule 36 (comp -> arith GT arith .)
    GE              reduce using rule 36 (comp -> arith GT arith .)
    EE              reduce using rule 36 (comp -> arith GT arith .)
    NE              reduce using rule 36 (comp -> arith GT arith .)
    ]               reduce using rule 36 (comp -> arith GT arith .)
    #               reduce using rule 36 (comp -> arith GT arith .)


state 60

    (37) comp -> arith GE arith .

    AND             reduce using rule 37 (comp -> arith GE arith .)
    OR              reduce using rule 37 (comp -> arith GE arith .)
    BREAK           reduce using rule 37 (comp -> arith GE arith .)
    RETURN          reduce using rule 37 (comp -> arith GE arith .)
    IF              reduce using rule 37 (comp -> arith GE arith .)
    NOT             reduce using rule 37 (comp -> arith GE arith .)
    MIN             reduce using rule 37 (comp -> arith GE arith .)
    MAX             reduce using rule 37 (comp -> arith GE arith .)
    VARIABLE        reduce using rule 37 (comp -> arith GE arith .)
    -               reduce using rule 37 (comp -> arith GE arith .)
    (               reduce using rule 37 (comp -> arith GE arith .)
    NUMBER          reduce using rule 37 (comp -> arith GE arith .)
    BOOLEAN         reduce using rule 37 (comp -> arith GE arith .)
    STRING          reduce using rule 37 (comp -> arith GE arith .)
    WORD            reduce using rule 37 (comp -> arith GE arith .)
    FUNCTION        reduce using rule 37 (comp -> arith GE arith .)
    %               reduce using rule 37 (comp -> arith GE arith .)
    {               reduce using rule 37 (comp -> arith GE arith .)
    $end            reduce using rule 37 (comp -> arith GE arith .)
    }               reduce using rule 37 (comp -> arith GE arith .)
    )               reduce using rule 37 (comp -> arith GE arith .)
    ,               reduce using rule 37 (comp -> arith GE arith .)
    +               reduce using rule 37 (comp -> arith GE arith .)
    *               reduce using rule 37 (comp -> arith GE arith .)
    /               reduce using rule 37 (comp -> arith GE arith .)
    LT              reduce using rule 37 (comp -> arith GE arith .)
    LE              reduce using rule 37 (comp -> arith GE arith .)
    GT              reduce using rule 37 (comp -> arith GE arith .)
    GE              reduce using rule 37 (comp -> arith GE arith .)
    EE              reduce using rule 37 (comp -> arith GE arith .)
    NE              reduce using rule 37 (comp -> arith GE arith .)
    ]               reduce using rule 37 (comp -> arith GE arith .)
    #               reduce using rule 37 (comp -> arith GE arith .)


state 61

    (38) comp -> arith EE arith .

    AND             reduce using rule 38 (comp -> arith EE arith .)
    OR              reduce using rule 38 (comp -> arith EE arith .)
    BREAK           reduce using rule 38 (comp -> arith EE arith .)
    RETURN          reduce using rule 38 (comp -> arith EE arith .)
    IF              reduce using rule 38 (comp -> arith EE arith .)
    NOT             reduce using rule 38 (comp -> arith EE arith .)
    MIN             reduce using rule 38 (comp -> arith EE arith .)
    MAX             reduce using rule 38 (comp -> arith EE arith .)
    VARIABLE        reduce using rule 38 (comp -> arith EE arith .)
    -               reduce using rule 38 (comp -> arith EE arith .)
    (               reduce using rule 38 (comp -> arith EE arith .)
    NUMBER          reduce using rule 38 (comp -> arith EE arith .)
    BOOLEAN         reduce using rule 38 (comp -> arith EE arith .)
    STRING          reduce using rule 38 (comp -> arith EE arith .)
    WORD            reduce using rule 38 (comp -> arith EE arith .)
    FUNCTION        reduce using rule 38 (comp -> arith EE arith .)
    %               reduce using rule 38 (comp -> arith EE arith .)
    {               reduce using rule 38 (comp -> arith EE arith .)
    $end            reduce using rule 38 (comp -> arith EE arith .)
    }               reduce using rule 38 (comp -> arith EE arith .)
    )               reduce using rule 38 (comp -> arith EE arith .)
    ,               reduce using rule 38 (comp -> arith EE arith .)
    +               reduce using rule 38 (comp -> arith EE arith .)
    *               reduce using rule 38 (comp -> arith EE arith .)
    /               reduce using rule 38 (comp -> arith EE arith .)
    LT              reduce using rule 38 (comp -> arith EE arith .)
    LE              reduce using rule 38 (comp -> arith EE arith .)
    GT              reduce using rule 38 (comp -> arith EE arith .)
    GE              reduce using rule 38 (comp -> arith EE arith .)
    EE              reduce using rule 38 (comp -> arith EE arith .)
    NE              reduce using rule 38 (comp -> arith EE arith .)
    ]               reduce using rule 38 (comp -> arith EE arith .)
    #               reduce using rule 38 (comp -> arith EE arith .)


state 62

    (39) comp -> arith NE arith .

    AND             reduce using rule 39 (comp -> arith NE arith .)
    OR              reduce using rule 39 (comp -> arith NE arith .)
    BREAK           reduce using rule 39 (comp -> arith NE arith .)
    RETURN          reduce using rule 39 (comp -> arith NE arith .)
    IF              reduce using rule 39 (comp -> arith NE arith .)
    NOT             reduce using rule 39 (comp -> arith NE arith .)
    MIN             reduce using rule 39 (comp -> arith NE arith .)
    MAX             reduce using rule 39 (comp -> arith NE arith .)
    VARIABLE        reduce using rule 39 (comp -> arith NE arith .)
    -               reduce using rule 39 (comp -> arith NE arith .)
    (               reduce using rule 39 (comp -> arith NE arith .)
    NUMBER          reduce using rule 39 (comp -> arith NE arith .)
    BOOLEAN         reduce using rule 39 (comp -> arith NE arith .)
    STRING          reduce using rule 39 (comp -> arith NE arith .)
    WORD            reduce using rule 39 (comp -> arith NE arith .)
    FUNCTION        reduce using rule 39 (comp -> arith NE arith .)
    %               reduce using rule 39 (comp -> arith NE arith .)
    {               reduce using rule 39 (comp -> arith NE arith .)
    $end            reduce using rule 39 (comp -> arith NE arith .)
    }               reduce using rule 39 (comp -> arith NE arith .)
    )               reduce using rule 39 (comp -> arith NE arith .)
    ,               reduce using rule 39 (comp -> arith NE arith .)
    +               reduce using rule 39 (comp -> arith NE arith .)
    *               reduce using rule 39 (comp -> arith NE arith .)
    /               reduce using rule 39 (comp -> arith NE arith .)
    LT              reduce using rule 39 (comp -> arith NE arith .)
    LE              reduce using rule 39 (comp -> arith NE arith .)
    GT              reduce using rule 39 (comp -> arith NE arith .)
    GE              reduce using rule 39 (comp -> arith NE arith .)
    EE              reduce using rule 39 (comp -> arith NE arith .)
    NE              reduce using rule 39 (comp -> arith NE arith .)
    ]               reduce using rule 39 (comp -> arith NE arith .)
    #               reduce using rule 39 (comp -> arith NE arith .)


state 63

    (43) arith -> atom + atom .

    LT              reduce using rule 43 (arith -> atom + atom .)
    LE              reduce using rule 43 (arith -> atom + atom .)
    GT              reduce using rule 43 (arith -> atom + atom .)
    GE              reduce using rule 43 (arith -> atom + atom .)
    EE              reduce using rule 43 (arith -> atom + atom .)
    NE              reduce using rule 43 (arith -> atom + atom .)
    AND             reduce using rule 43 (arith -> atom + atom .)
    OR              reduce using rule 43 (arith -> atom + atom .)
    BREAK           reduce using rule 43 (arith -> atom + atom .)
    RETURN          reduce using rule 43 (arith -> atom + atom .)
    IF              reduce using rule 43 (arith -> atom + atom .)
    NOT             reduce using rule 43 (arith -> atom + atom .)
    MIN             reduce using rule 43 (arith -> atom + atom .)
    MAX             reduce using rule 43 (arith -> atom + atom .)
    VARIABLE        reduce using rule 43 (arith -> atom + atom .)
    -               reduce using rule 43 (arith -> atom + atom .)
    (               reduce using rule 43 (arith -> atom + atom .)
    NUMBER          reduce using rule 43 (arith -> atom + atom .)
    BOOLEAN         reduce using rule 43 (arith -> atom + atom .)
    STRING          reduce using rule 43 (arith -> atom + atom .)
    WORD            reduce using rule 43 (arith -> atom + atom .)
    FUNCTION        reduce using rule 43 (arith -> atom + atom .)
    %               reduce using rule 43 (arith -> atom + atom .)
    {               reduce using rule 43 (arith -> atom + atom .)
    $end            reduce using rule 43 (arith -> atom + atom .)
    }               reduce using rule 43 (arith -> atom + atom .)
    )               reduce using rule 43 (arith -> atom + atom .)
    ,               reduce using rule 43 (arith -> atom + atom .)
    +               reduce using rule 43 (arith -> atom + atom .)
    *               reduce using rule 43 (arith -> atom + atom .)
    /               reduce using rule 43 (arith -> atom + atom .)
    ]               reduce using rule 43 (arith -> atom + atom .)
    #               reduce using rule 43 (arith -> atom + atom .)


state 64

    (44) arith -> atom - atom .

    LT              reduce using rule 44 (arith -> atom - atom .)
    LE              reduce using rule 44 (arith -> atom - atom .)
    GT              reduce using rule 44 (arith -> atom - atom .)
    GE              reduce using rule 44 (arith -> atom - atom .)
    EE              reduce using rule 44 (arith -> atom - atom .)
    NE              reduce using rule 44 (arith -> atom - atom .)
    AND             reduce using rule 44 (arith -> atom - atom .)
    OR              reduce using rule 44 (arith -> atom - atom .)
    BREAK           reduce using rule 44 (arith -> atom - atom .)
    RETURN          reduce using rule 44 (arith -> atom - atom .)
    IF              reduce using rule 44 (arith -> atom - atom .)
    NOT             reduce using rule 44 (arith -> atom - atom .)
    MIN             reduce using rule 44 (arith -> atom - atom .)
    MAX             reduce using rule 44 (arith -> atom - atom .)
    VARIABLE        reduce using rule 44 (arith -> atom - atom .)
    -               reduce using rule 44 (arith -> atom - atom .)
    (               reduce using rule 44 (arith -> atom - atom .)
    NUMBER          reduce using rule 44 (arith -> atom - atom .)
    BOOLEAN         reduce using rule 44 (arith -> atom - atom .)
    STRING          reduce using rule 44 (arith -> atom - atom .)
    WORD            reduce using rule 44 (arith -> atom - atom .)
    FUNCTION        reduce using rule 44 (arith -> atom - atom .)
    %               reduce using rule 44 (arith -> atom - atom .)
    {               reduce using rule 44 (arith -> atom - atom .)
    $end            reduce using rule 44 (arith -> atom - atom .)
    }               reduce using rule 44 (arith -> atom - atom .)
    )               reduce using rule 44 (arith -> atom - atom .)
    ,               reduce using rule 44 (arith -> atom - atom .)
    +               reduce using rule 44 (arith -> atom - atom .)
    *               reduce using rule 44 (arith -> atom - atom .)
    /               reduce using rule 44 (arith -> atom - atom .)
    ]               reduce using rule 44 (arith -> atom - atom .)
    #               reduce using rule 44 (arith -> atom - atom .)


state 65

    (45) arith -> atom * atom .

    LT              reduce using rule 45 (arith -> atom * atom .)
    LE              reduce using rule 45 (arith -> atom * atom .)
    GT              reduce using rule 45 (arith -> atom * atom .)
    GE              reduce using rule 45 (arith -> atom * atom .)
    EE              reduce using rule 45 (arith -> atom * atom .)
    NE              reduce using rule 45 (arith -> atom * atom .)
    AND             reduce using rule 45 (arith -> atom * atom .)
    OR              reduce using rule 45 (arith -> atom * atom .)
    BREAK           reduce using rule 45 (arith -> atom * atom .)
    RETURN          reduce using rule 45 (arith -> atom * atom .)
    IF              reduce using rule 45 (arith -> atom * atom .)
    NOT             reduce using rule 45 (arith -> atom * atom .)
    MIN             reduce using rule 45 (arith -> atom * atom .)
    MAX             reduce using rule 45 (arith -> atom * atom .)
    VARIABLE        reduce using rule 45 (arith -> atom * atom .)
    -               reduce using rule 45 (arith -> atom * atom .)
    (               reduce using rule 45 (arith -> atom * atom .)
    NUMBER          reduce using rule 45 (arith -> atom * atom .)
    BOOLEAN         reduce using rule 45 (arith -> atom * atom .)
    STRING          reduce using rule 45 (arith -> atom * atom .)
    WORD            reduce using rule 45 (arith -> atom * atom .)
    FUNCTION        reduce using rule 45 (arith -> atom * atom .)
    %               reduce using rule 45 (arith -> atom * atom .)
    {               reduce using rule 45 (arith -> atom * atom .)
    $end            reduce using rule 45 (arith -> atom * atom .)
    }               reduce using rule 45 (arith -> atom * atom .)
    )               reduce using rule 45 (arith -> atom * atom .)
    ,               reduce using rule 45 (arith -> atom * atom .)
    +               reduce using rule 45 (arith -> atom * atom .)
    *               reduce using rule 45 (arith -> atom * atom .)
    /               reduce using rule 45 (arith -> atom * atom .)
    ]               reduce using rule 45 (arith -> atom * atom .)
    #               reduce using rule 45 (arith -> atom * atom .)


state 66

    (46) arith -> atom / atom .

    LT              reduce using rule 46 (arith -> atom / atom .)
    LE              reduce using rule 46 (arith -> atom / atom .)
    GT              reduce using rule 46 (arith -> atom / atom .)
    GE              reduce using rule 46 (arith -> atom / atom .)
    EE              reduce using rule 46 (arith -> atom / atom .)
    NE              reduce using rule 46 (arith -> atom / atom .)
    AND             reduce using rule 46 (arith -> atom / atom .)
    OR              reduce using rule 46 (arith -> atom / atom .)
    BREAK           reduce using rule 46 (arith -> atom / atom .)
    RETURN          reduce using rule 46 (arith -> atom / atom .)
    IF              reduce using rule 46 (arith -> atom / atom .)
    NOT             reduce using rule 46 (arith -> atom / atom .)
    MIN             reduce using rule 46 (arith -> atom / atom .)
    MAX             reduce using rule 46 (arith -> atom / atom .)
    VARIABLE        reduce using rule 46 (arith -> atom / atom .)
    -               reduce using rule 46 (arith -> atom / atom .)
    (               reduce using rule 46 (arith -> atom / atom .)
    NUMBER          reduce using rule 46 (arith -> atom / atom .)
    BOOLEAN         reduce using rule 46 (arith -> atom / atom .)
    STRING          reduce using rule 46 (arith -> atom / atom .)
    WORD            reduce using rule 46 (arith -> atom / atom .)
    FUNCTION        reduce using rule 46 (arith -> atom / atom .)
    %               reduce using rule 46 (arith -> atom / atom .)
    {               reduce using rule 46 (arith -> atom / atom .)
    $end            reduce using rule 46 (arith -> atom / atom .)
    }               reduce using rule 46 (arith -> atom / atom .)
    )               reduce using rule 46 (arith -> atom / atom .)
    ,               reduce using rule 46 (arith -> atom / atom .)
    +               reduce using rule 46 (arith -> atom / atom .)
    *               reduce using rule 46 (arith -> atom / atom .)
    /               reduce using rule 46 (arith -> atom / atom .)
    ]               reduce using rule 46 (arith -> atom / atom .)
    #               reduce using rule 46 (arith -> atom / atom .)


state 67

    (52) arith -> MIN ( comma_expressions . )

    )               shift and go to state 84


state 68

    (49) comma_expressions -> expression . , comma_expressions
    (50) comma_expressions -> expression . ,
    (51) comma_expressions -> expression .

    ,               shift and go to state 85
    )               reduce using rule 51 (comma_expressions -> expression .)
    ]               reduce using rule 51 (comma_expressions -> expression .)


state 69

    (53) arith -> MAX ( comma_expressions . )

    )               shift and go to state 86


state 70

    (1) atom -> VARIABLE = expression .

    +               reduce using rule 1 (atom -> VARIABLE = expression .)
    -               reduce using rule 1 (atom -> VARIABLE = expression .)
    *               reduce using rule 1 (atom -> VARIABLE = expression .)
    /               reduce using rule 1 (atom -> VARIABLE = expression .)
    LT              reduce using rule 1 (atom -> VARIABLE = expression .)
    LE              reduce using rule 1 (atom -> VARIABLE = expression .)
    GT              reduce using rule 1 (atom -> VARIABLE = expression .)
    GE              reduce using rule 1 (atom -> VARIABLE = expression .)
    EE              reduce using rule 1 (atom -> VARIABLE = expression .)
    NE              reduce using rule 1 (atom -> VARIABLE = expression .)
    AND             reduce using rule 1 (atom -> VARIABLE = expression .)
    OR              reduce using rule 1 (atom -> VARIABLE = expression .)
    BREAK           reduce using rule 1 (atom -> VARIABLE = expression .)
    RETURN          reduce using rule 1 (atom -> VARIABLE = expression .)
    IF              reduce using rule 1 (atom -> VARIABLE = expression .)
    NOT             reduce using rule 1 (atom -> VARIABLE = expression .)
    MIN             reduce using rule 1 (atom -> VARIABLE = expression .)
    MAX             reduce using rule 1 (atom -> VARIABLE = expression .)
    VARIABLE        reduce using rule 1 (atom -> VARIABLE = expression .)
    (               reduce using rule 1 (atom -> VARIABLE = expression .)
    NUMBER          reduce using rule 1 (atom -> VARIABLE = expression .)
    BOOLEAN         reduce using rule 1 (atom -> VARIABLE = expression .)
    STRING          reduce using rule 1 (atom -> VARIABLE = expression .)
    WORD            reduce using rule 1 (atom -> VARIABLE = expression .)
    FUNCTION        reduce using rule 1 (atom -> VARIABLE = expression .)
    %               reduce using rule 1 (atom -> VARIABLE = expression .)
    {               reduce using rule 1 (atom -> VARIABLE = expression .)
    $end            reduce using rule 1 (atom -> VARIABLE = expression .)
    }               reduce using rule 1 (atom -> VARIABLE = expression .)
    )               reduce using rule 1 (atom -> VARIABLE = expression .)
    ,               reduce using rule 1 (atom -> VARIABLE = expression .)
    ]               reduce using rule 1 (atom -> VARIABLE = expression .)
    #               reduce using rule 1 (atom -> VARIABLE = expression .)


state 71

    (10) function_call -> FUNCTION parameters scope .

    +               reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    -               reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    *               reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    /               reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    LT              reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    LE              reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    GT              reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    GE              reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    EE              reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    NE              reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    AND             reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    OR              reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    BREAK           reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    RETURN          reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    IF              reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    NOT             reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    MIN             reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    MAX             reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    VARIABLE        reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    (               reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    NUMBER          reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    BOOLEAN         reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    STRING          reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    WORD            reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    FUNCTION        reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    %               reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    {               reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    $end            reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    }               reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    )               reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    ,               reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    ]               reduce using rule 10 (function_call -> FUNCTION parameters scope .)
    #               reduce using rule 10 (function_call -> FUNCTION parameters scope .)


state 72

    (11) function_call -> FUNCTION parameters tag_list .

    +               reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    -               reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    *               reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    /               reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    LT              reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    LE              reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    GT              reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    GE              reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    EE              reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    NE              reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    AND             reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    OR              reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    BREAK           reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    RETURN          reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    IF              reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    NOT             reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    MIN             reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    MAX             reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    VARIABLE        reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    (               reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    NUMBER          reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    BOOLEAN         reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    STRING          reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    WORD            reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    FUNCTION        reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    %               reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    {               reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    $end            reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    }               reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    )               reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    ,               reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    ]               reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)
    #               reduce using rule 11 (function_call -> FUNCTION parameters tag_list .)


state 73

    (15) tag_list -> tag . # scope tag_list
    (16) tag_list -> tag . # scope

    #               shift and go to state 87


state 74

    (14) tag -> TAG . expression
    (71) expression -> . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    expression                     shift and go to state 88
    comp                           shift and go to state 7
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 75

    (20) parameters -> ( param_element . )

    )               shift and go to state 89


state 76

    (21) parameters -> ( ) .

    {               reduce using rule 21 (parameters -> ( ) .)
    TAG             reduce using rule 21 (parameters -> ( ) .)
    +               reduce using rule 21 (parameters -> ( ) .)
    -               reduce using rule 21 (parameters -> ( ) .)
    *               reduce using rule 21 (parameters -> ( ) .)
    /               reduce using rule 21 (parameters -> ( ) .)
    LT              reduce using rule 21 (parameters -> ( ) .)
    LE              reduce using rule 21 (parameters -> ( ) .)
    GT              reduce using rule 21 (parameters -> ( ) .)
    GE              reduce using rule 21 (parameters -> ( ) .)
    EE              reduce using rule 21 (parameters -> ( ) .)
    NE              reduce using rule 21 (parameters -> ( ) .)
    AND             reduce using rule 21 (parameters -> ( ) .)
    OR              reduce using rule 21 (parameters -> ( ) .)
    BREAK           reduce using rule 21 (parameters -> ( ) .)
    RETURN          reduce using rule 21 (parameters -> ( ) .)
    IF              reduce using rule 21 (parameters -> ( ) .)
    NOT             reduce using rule 21 (parameters -> ( ) .)
    MIN             reduce using rule 21 (parameters -> ( ) .)
    MAX             reduce using rule 21 (parameters -> ( ) .)
    VARIABLE        reduce using rule 21 (parameters -> ( ) .)
    (               reduce using rule 21 (parameters -> ( ) .)
    NUMBER          reduce using rule 21 (parameters -> ( ) .)
    BOOLEAN         reduce using rule 21 (parameters -> ( ) .)
    STRING          reduce using rule 21 (parameters -> ( ) .)
    WORD            reduce using rule 21 (parameters -> ( ) .)
    FUNCTION        reduce using rule 21 (parameters -> ( ) .)
    %               reduce using rule 21 (parameters -> ( ) .)
    $end            reduce using rule 21 (parameters -> ( ) .)
    }               reduce using rule 21 (parameters -> ( ) .)
    )               reduce using rule 21 (parameters -> ( ) .)
    ,               reduce using rule 21 (parameters -> ( ) .)
    ]               reduce using rule 21 (parameters -> ( ) .)
    #               reduce using rule 21 (parameters -> ( ) .)


state 77

    (25) param_element -> expression . , param_element
    (26) param_element -> expression . , param_element_pos
    (27) param_element -> expression . ,
    (28) param_element -> expression .

    ,               shift and go to state 90
    )               reduce using rule 28 (param_element -> expression .)


state 78

    (63) table -> % [ comma_expressions . ]

    ]               shift and go to state 91


state 79

    (64) table -> % { table_contents . }

    }               shift and go to state 92


state 80

    (57) table_contents -> STRING . : expression , table_contents
    (59) table_contents -> STRING . : expression ,
    (61) table_contents -> STRING . : expression

    :               shift and go to state 93


state 81

    (58) table_contents -> NUMBER . : expression , table_contents
    (60) table_contents -> NUMBER . : expression ,
    (62) table_contents -> NUMBER . : expression

    :               shift and go to state 94


state 82

    (17) scope -> { expressions } .

    +               reduce using rule 17 (scope -> { expressions } .)
    -               reduce using rule 17 (scope -> { expressions } .)
    *               reduce using rule 17 (scope -> { expressions } .)
    /               reduce using rule 17 (scope -> { expressions } .)
    LT              reduce using rule 17 (scope -> { expressions } .)
    LE              reduce using rule 17 (scope -> { expressions } .)
    GT              reduce using rule 17 (scope -> { expressions } .)
    GE              reduce using rule 17 (scope -> { expressions } .)
    EE              reduce using rule 17 (scope -> { expressions } .)
    NE              reduce using rule 17 (scope -> { expressions } .)
    AND             reduce using rule 17 (scope -> { expressions } .)
    OR              reduce using rule 17 (scope -> { expressions } .)
    BREAK           reduce using rule 17 (scope -> { expressions } .)
    RETURN          reduce using rule 17 (scope -> { expressions } .)
    IF              reduce using rule 17 (scope -> { expressions } .)
    NOT             reduce using rule 17 (scope -> { expressions } .)
    MIN             reduce using rule 17 (scope -> { expressions } .)
    MAX             reduce using rule 17 (scope -> { expressions } .)
    VARIABLE        reduce using rule 17 (scope -> { expressions } .)
    (               reduce using rule 17 (scope -> { expressions } .)
    NUMBER          reduce using rule 17 (scope -> { expressions } .)
    BOOLEAN         reduce using rule 17 (scope -> { expressions } .)
    STRING          reduce using rule 17 (scope -> { expressions } .)
    WORD            reduce using rule 17 (scope -> { expressions } .)
    FUNCTION        reduce using rule 17 (scope -> { expressions } .)
    %               reduce using rule 17 (scope -> { expressions } .)
    {               reduce using rule 17 (scope -> { expressions } .)
    $end            reduce using rule 17 (scope -> { expressions } .)
    }               reduce using rule 17 (scope -> { expressions } .)
    )               reduce using rule 17 (scope -> { expressions } .)
    ,               reduce using rule 17 (scope -> { expressions } .)
    ]               reduce using rule 17 (scope -> { expressions } .)
    #               reduce using rule 17 (scope -> { expressions } .)
    ELSEIF          reduce using rule 17 (scope -> { expressions } .)
    ELSE            reduce using rule 17 (scope -> { expressions } .)
    TAG             reduce using rule 17 (scope -> { expressions } .)


state 83

    (7) if_condition -> IF ( expression ) . scope elif_branch
    (8) if_condition -> IF ( expression ) . scope else_branch
    (9) if_condition -> IF ( expression ) . scope
    (17) scope -> . { expressions }

    {               shift and go to state 26

    scope                          shift and go to state 95

state 84

    (52) arith -> MIN ( comma_expressions ) .

    LT              reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    LE              reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    GT              reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    GE              reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    EE              reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    NE              reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    AND             reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    OR              reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    BREAK           reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    RETURN          reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    IF              reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    NOT             reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    MIN             reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    MAX             reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    VARIABLE        reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    -               reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    (               reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    NUMBER          reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    BOOLEAN         reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    STRING          reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    WORD            reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    FUNCTION        reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    %               reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    {               reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    $end            reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    }               reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    )               reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    ,               reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    +               reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    *               reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    /               reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    ]               reduce using rule 52 (arith -> MIN ( comma_expressions ) .)
    #               reduce using rule 52 (arith -> MIN ( comma_expressions ) .)


state 85

    (49) comma_expressions -> expression , . comma_expressions
    (50) comma_expressions -> expression , .
    (49) comma_expressions -> . expression , comma_expressions
    (50) comma_expressions -> . expression ,
    (51) comma_expressions -> . expression
    (71) expression -> . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    )               reduce using rule 50 (comma_expressions -> expression , .)
    ]               reduce using rule 50 (comma_expressions -> expression , .)
    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    expression                     shift and go to state 68
    comma_expressions              shift and go to state 96
    comp                           shift and go to state 7
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 86

    (53) arith -> MAX ( comma_expressions ) .

    LT              reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    LE              reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    GT              reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    GE              reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    EE              reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    NE              reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    AND             reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    OR              reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    BREAK           reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    RETURN          reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    IF              reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    NOT             reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    MIN             reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    MAX             reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    VARIABLE        reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    -               reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    (               reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    NUMBER          reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    BOOLEAN         reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    STRING          reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    WORD            reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    FUNCTION        reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    %               reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    {               reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    $end            reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    }               reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    )               reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    ,               reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    +               reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    *               reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    /               reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    ]               reduce using rule 53 (arith -> MAX ( comma_expressions ) .)
    #               reduce using rule 53 (arith -> MAX ( comma_expressions ) .)


state 87

    (15) tag_list -> tag # . scope tag_list
    (16) tag_list -> tag # . scope
    (17) scope -> . { expressions }

    {               shift and go to state 26

    scope                          shift and go to state 97

state 88

    (14) tag -> TAG expression .

    #               reduce using rule 14 (tag -> TAG expression .)


state 89

    (20) parameters -> ( param_element ) .

    {               reduce using rule 20 (parameters -> ( param_element ) .)
    TAG             reduce using rule 20 (parameters -> ( param_element ) .)
    +               reduce using rule 20 (parameters -> ( param_element ) .)
    -               reduce using rule 20 (parameters -> ( param_element ) .)
    *               reduce using rule 20 (parameters -> ( param_element ) .)
    /               reduce using rule 20 (parameters -> ( param_element ) .)
    LT              reduce using rule 20 (parameters -> ( param_element ) .)
    LE              reduce using rule 20 (parameters -> ( param_element ) .)
    GT              reduce using rule 20 (parameters -> ( param_element ) .)
    GE              reduce using rule 20 (parameters -> ( param_element ) .)
    EE              reduce using rule 20 (parameters -> ( param_element ) .)
    NE              reduce using rule 20 (parameters -> ( param_element ) .)
    AND             reduce using rule 20 (parameters -> ( param_element ) .)
    OR              reduce using rule 20 (parameters -> ( param_element ) .)
    BREAK           reduce using rule 20 (parameters -> ( param_element ) .)
    RETURN          reduce using rule 20 (parameters -> ( param_element ) .)
    IF              reduce using rule 20 (parameters -> ( param_element ) .)
    NOT             reduce using rule 20 (parameters -> ( param_element ) .)
    MIN             reduce using rule 20 (parameters -> ( param_element ) .)
    MAX             reduce using rule 20 (parameters -> ( param_element ) .)
    VARIABLE        reduce using rule 20 (parameters -> ( param_element ) .)
    (               reduce using rule 20 (parameters -> ( param_element ) .)
    NUMBER          reduce using rule 20 (parameters -> ( param_element ) .)
    BOOLEAN         reduce using rule 20 (parameters -> ( param_element ) .)
    STRING          reduce using rule 20 (parameters -> ( param_element ) .)
    WORD            reduce using rule 20 (parameters -> ( param_element ) .)
    FUNCTION        reduce using rule 20 (parameters -> ( param_element ) .)
    %               reduce using rule 20 (parameters -> ( param_element ) .)
    $end            reduce using rule 20 (parameters -> ( param_element ) .)
    }               reduce using rule 20 (parameters -> ( param_element ) .)
    )               reduce using rule 20 (parameters -> ( param_element ) .)
    ,               reduce using rule 20 (parameters -> ( param_element ) .)
    ]               reduce using rule 20 (parameters -> ( param_element ) .)
    #               reduce using rule 20 (parameters -> ( param_element ) .)


state 90

    (25) param_element -> expression , . param_element
    (26) param_element -> expression , . param_element_pos
    (27) param_element -> expression , .
    (25) param_element -> . expression , param_element
    (26) param_element -> . expression , param_element_pos
    (27) param_element -> . expression ,
    (28) param_element -> . expression
    (22) param_element_pos -> . WORD = expression , param_element_pos
    (23) param_element_pos -> . WORD = expression ,
    (24) param_element_pos -> . WORD = expression
    (71) expression -> . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    )               reduce using rule 27 (param_element -> expression , .)
    WORD            shift and go to state 100
    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    expression                     shift and go to state 77
    param_element                  shift and go to state 98
    param_element_pos              shift and go to state 99
    comp                           shift and go to state 7
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 91

    (63) table -> % [ comma_expressions ] .

    +               reduce using rule 63 (table -> % [ comma_expressions ] .)
    -               reduce using rule 63 (table -> % [ comma_expressions ] .)
    *               reduce using rule 63 (table -> % [ comma_expressions ] .)
    /               reduce using rule 63 (table -> % [ comma_expressions ] .)
    LT              reduce using rule 63 (table -> % [ comma_expressions ] .)
    LE              reduce using rule 63 (table -> % [ comma_expressions ] .)
    GT              reduce using rule 63 (table -> % [ comma_expressions ] .)
    GE              reduce using rule 63 (table -> % [ comma_expressions ] .)
    EE              reduce using rule 63 (table -> % [ comma_expressions ] .)
    NE              reduce using rule 63 (table -> % [ comma_expressions ] .)
    AND             reduce using rule 63 (table -> % [ comma_expressions ] .)
    OR              reduce using rule 63 (table -> % [ comma_expressions ] .)
    BREAK           reduce using rule 63 (table -> % [ comma_expressions ] .)
    RETURN          reduce using rule 63 (table -> % [ comma_expressions ] .)
    IF              reduce using rule 63 (table -> % [ comma_expressions ] .)
    NOT             reduce using rule 63 (table -> % [ comma_expressions ] .)
    MIN             reduce using rule 63 (table -> % [ comma_expressions ] .)
    MAX             reduce using rule 63 (table -> % [ comma_expressions ] .)
    VARIABLE        reduce using rule 63 (table -> % [ comma_expressions ] .)
    (               reduce using rule 63 (table -> % [ comma_expressions ] .)
    NUMBER          reduce using rule 63 (table -> % [ comma_expressions ] .)
    BOOLEAN         reduce using rule 63 (table -> % [ comma_expressions ] .)
    STRING          reduce using rule 63 (table -> % [ comma_expressions ] .)
    WORD            reduce using rule 63 (table -> % [ comma_expressions ] .)
    FUNCTION        reduce using rule 63 (table -> % [ comma_expressions ] .)
    %               reduce using rule 63 (table -> % [ comma_expressions ] .)
    {               reduce using rule 63 (table -> % [ comma_expressions ] .)
    $end            reduce using rule 63 (table -> % [ comma_expressions ] .)
    }               reduce using rule 63 (table -> % [ comma_expressions ] .)
    )               reduce using rule 63 (table -> % [ comma_expressions ] .)
    ,               reduce using rule 63 (table -> % [ comma_expressions ] .)
    ]               reduce using rule 63 (table -> % [ comma_expressions ] .)
    #               reduce using rule 63 (table -> % [ comma_expressions ] .)


state 92

    (64) table -> % { table_contents } .

    +               reduce using rule 64 (table -> % { table_contents } .)
    -               reduce using rule 64 (table -> % { table_contents } .)
    *               reduce using rule 64 (table -> % { table_contents } .)
    /               reduce using rule 64 (table -> % { table_contents } .)
    LT              reduce using rule 64 (table -> % { table_contents } .)
    LE              reduce using rule 64 (table -> % { table_contents } .)
    GT              reduce using rule 64 (table -> % { table_contents } .)
    GE              reduce using rule 64 (table -> % { table_contents } .)
    EE              reduce using rule 64 (table -> % { table_contents } .)
    NE              reduce using rule 64 (table -> % { table_contents } .)
    AND             reduce using rule 64 (table -> % { table_contents } .)
    OR              reduce using rule 64 (table -> % { table_contents } .)
    BREAK           reduce using rule 64 (table -> % { table_contents } .)
    RETURN          reduce using rule 64 (table -> % { table_contents } .)
    IF              reduce using rule 64 (table -> % { table_contents } .)
    NOT             reduce using rule 64 (table -> % { table_contents } .)
    MIN             reduce using rule 64 (table -> % { table_contents } .)
    MAX             reduce using rule 64 (table -> % { table_contents } .)
    VARIABLE        reduce using rule 64 (table -> % { table_contents } .)
    (               reduce using rule 64 (table -> % { table_contents } .)
    NUMBER          reduce using rule 64 (table -> % { table_contents } .)
    BOOLEAN         reduce using rule 64 (table -> % { table_contents } .)
    STRING          reduce using rule 64 (table -> % { table_contents } .)
    WORD            reduce using rule 64 (table -> % { table_contents } .)
    FUNCTION        reduce using rule 64 (table -> % { table_contents } .)
    %               reduce using rule 64 (table -> % { table_contents } .)
    {               reduce using rule 64 (table -> % { table_contents } .)
    $end            reduce using rule 64 (table -> % { table_contents } .)
    }               reduce using rule 64 (table -> % { table_contents } .)
    )               reduce using rule 64 (table -> % { table_contents } .)
    ,               reduce using rule 64 (table -> % { table_contents } .)
    ]               reduce using rule 64 (table -> % { table_contents } .)
    #               reduce using rule 64 (table -> % { table_contents } .)


state 93

    (57) table_contents -> STRING : . expression , table_contents
    (59) table_contents -> STRING : . expression ,
    (61) table_contents -> STRING : . expression
    (71) expression -> . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    expression                     shift and go to state 101
    comp                           shift and go to state 7
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 94

    (58) table_contents -> NUMBER : . expression , table_contents
    (60) table_contents -> NUMBER : . expression ,
    (62) table_contents -> NUMBER : . expression
    (71) expression -> . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    expression                     shift and go to state 102
    comp                           shift and go to state 7
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 95

    (7) if_condition -> IF ( expression ) scope . elif_branch
    (8) if_condition -> IF ( expression ) scope . else_branch
    (9) if_condition -> IF ( expression ) scope .
    (4) elif_branch -> . ELSEIF ( expression ) scope elif_branch
    (5) elif_branch -> . ELSEIF ( expression ) scope else_branch
    (6) elif_branch -> . ELSEIF ( expression ) scope
    (3) else_branch -> . ELSE scope

    BREAK           reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    RETURN          reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    IF              reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    NOT             reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    MIN             reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    MAX             reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    VARIABLE        reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    -               reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    (               reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    NUMBER          reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    BOOLEAN         reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    STRING          reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    WORD            reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    FUNCTION        reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    %               reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    {               reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    $end            reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    }               reduce using rule 9 (if_condition -> IF ( expression ) scope .)
    ELSEIF          shift and go to state 105
    ELSE            shift and go to state 106

    elif_branch                    shift and go to state 103
    else_branch                    shift and go to state 104

state 96

    (49) comma_expressions -> expression , comma_expressions .

    )               reduce using rule 49 (comma_expressions -> expression , comma_expressions .)
    ]               reduce using rule 49 (comma_expressions -> expression , comma_expressions .)


state 97

    (15) tag_list -> tag # scope . tag_list
    (16) tag_list -> tag # scope .
    (15) tag_list -> . tag # scope tag_list
    (16) tag_list -> . tag # scope
    (14) tag -> . TAG expression

    +               reduce using rule 16 (tag_list -> tag # scope .)
    -               reduce using rule 16 (tag_list -> tag # scope .)
    *               reduce using rule 16 (tag_list -> tag # scope .)
    /               reduce using rule 16 (tag_list -> tag # scope .)
    LT              reduce using rule 16 (tag_list -> tag # scope .)
    LE              reduce using rule 16 (tag_list -> tag # scope .)
    GT              reduce using rule 16 (tag_list -> tag # scope .)
    GE              reduce using rule 16 (tag_list -> tag # scope .)
    EE              reduce using rule 16 (tag_list -> tag # scope .)
    NE              reduce using rule 16 (tag_list -> tag # scope .)
    AND             reduce using rule 16 (tag_list -> tag # scope .)
    OR              reduce using rule 16 (tag_list -> tag # scope .)
    BREAK           reduce using rule 16 (tag_list -> tag # scope .)
    RETURN          reduce using rule 16 (tag_list -> tag # scope .)
    IF              reduce using rule 16 (tag_list -> tag # scope .)
    NOT             reduce using rule 16 (tag_list -> tag # scope .)
    MIN             reduce using rule 16 (tag_list -> tag # scope .)
    MAX             reduce using rule 16 (tag_list -> tag # scope .)
    VARIABLE        reduce using rule 16 (tag_list -> tag # scope .)
    (               reduce using rule 16 (tag_list -> tag # scope .)
    NUMBER          reduce using rule 16 (tag_list -> tag # scope .)
    BOOLEAN         reduce using rule 16 (tag_list -> tag # scope .)
    STRING          reduce using rule 16 (tag_list -> tag # scope .)
    WORD            reduce using rule 16 (tag_list -> tag # scope .)
    FUNCTION        reduce using rule 16 (tag_list -> tag # scope .)
    %               reduce using rule 16 (tag_list -> tag # scope .)
    {               reduce using rule 16 (tag_list -> tag # scope .)
    $end            reduce using rule 16 (tag_list -> tag # scope .)
    }               reduce using rule 16 (tag_list -> tag # scope .)
    )               reduce using rule 16 (tag_list -> tag # scope .)
    ,               reduce using rule 16 (tag_list -> tag # scope .)
    ]               reduce using rule 16 (tag_list -> tag # scope .)
    #               reduce using rule 16 (tag_list -> tag # scope .)
    TAG             shift and go to state 74

    tag                            shift and go to state 73
    tag_list                       shift and go to state 107

state 98

    (25) param_element -> expression , param_element .

    )               reduce using rule 25 (param_element -> expression , param_element .)


state 99

    (26) param_element -> expression , param_element_pos .

    )               reduce using rule 26 (param_element -> expression , param_element_pos .)


state 100

    (22) param_element_pos -> WORD . = expression , param_element_pos
    (23) param_element_pos -> WORD . = expression ,
    (24) param_element_pos -> WORD . = expression
    (69) atom -> WORD .

    =               shift and go to state 108
    +               reduce using rule 69 (atom -> WORD .)
    -               reduce using rule 69 (atom -> WORD .)
    *               reduce using rule 69 (atom -> WORD .)
    /               reduce using rule 69 (atom -> WORD .)
    LT              reduce using rule 69 (atom -> WORD .)
    LE              reduce using rule 69 (atom -> WORD .)
    GT              reduce using rule 69 (atom -> WORD .)
    GE              reduce using rule 69 (atom -> WORD .)
    EE              reduce using rule 69 (atom -> WORD .)
    NE              reduce using rule 69 (atom -> WORD .)
    AND             reduce using rule 69 (atom -> WORD .)
    OR              reduce using rule 69 (atom -> WORD .)
    ,               reduce using rule 69 (atom -> WORD .)
    )               reduce using rule 69 (atom -> WORD .)


state 101

    (57) table_contents -> STRING : expression . , table_contents
    (59) table_contents -> STRING : expression . ,
    (61) table_contents -> STRING : expression .

    ,               shift and go to state 109
    }               reduce using rule 61 (table_contents -> STRING : expression .)


state 102

    (58) table_contents -> NUMBER : expression . , table_contents
    (60) table_contents -> NUMBER : expression . ,
    (62) table_contents -> NUMBER : expression .

    ,               shift and go to state 110
    }               reduce using rule 62 (table_contents -> NUMBER : expression .)


state 103

    (7) if_condition -> IF ( expression ) scope elif_branch .

    BREAK           reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    RETURN          reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    IF              reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    NOT             reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    MIN             reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    MAX             reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    VARIABLE        reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    -               reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    (               reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    NUMBER          reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    BOOLEAN         reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    STRING          reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    WORD            reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    FUNCTION        reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    %               reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    {               reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    $end            reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)
    }               reduce using rule 7 (if_condition -> IF ( expression ) scope elif_branch .)


state 104

    (8) if_condition -> IF ( expression ) scope else_branch .

    BREAK           reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    RETURN          reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    IF              reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    NOT             reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    MIN             reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    MAX             reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    VARIABLE        reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    -               reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    (               reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    NUMBER          reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    BOOLEAN         reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    STRING          reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    WORD            reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    FUNCTION        reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    %               reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    {               reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    $end            reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)
    }               reduce using rule 8 (if_condition -> IF ( expression ) scope else_branch .)


state 105

    (4) elif_branch -> ELSEIF . ( expression ) scope elif_branch
    (5) elif_branch -> ELSEIF . ( expression ) scope else_branch
    (6) elif_branch -> ELSEIF . ( expression ) scope

    (               shift and go to state 111


state 106

    (3) else_branch -> ELSE . scope
    (17) scope -> . { expressions }

    {               shift and go to state 26

    scope                          shift and go to state 112

state 107

    (15) tag_list -> tag # scope tag_list .

    +               reduce using rule 15 (tag_list -> tag # scope tag_list .)
    -               reduce using rule 15 (tag_list -> tag # scope tag_list .)
    *               reduce using rule 15 (tag_list -> tag # scope tag_list .)
    /               reduce using rule 15 (tag_list -> tag # scope tag_list .)
    LT              reduce using rule 15 (tag_list -> tag # scope tag_list .)
    LE              reduce using rule 15 (tag_list -> tag # scope tag_list .)
    GT              reduce using rule 15 (tag_list -> tag # scope tag_list .)
    GE              reduce using rule 15 (tag_list -> tag # scope tag_list .)
    EE              reduce using rule 15 (tag_list -> tag # scope tag_list .)
    NE              reduce using rule 15 (tag_list -> tag # scope tag_list .)
    AND             reduce using rule 15 (tag_list -> tag # scope tag_list .)
    OR              reduce using rule 15 (tag_list -> tag # scope tag_list .)
    BREAK           reduce using rule 15 (tag_list -> tag # scope tag_list .)
    RETURN          reduce using rule 15 (tag_list -> tag # scope tag_list .)
    IF              reduce using rule 15 (tag_list -> tag # scope tag_list .)
    NOT             reduce using rule 15 (tag_list -> tag # scope tag_list .)
    MIN             reduce using rule 15 (tag_list -> tag # scope tag_list .)
    MAX             reduce using rule 15 (tag_list -> tag # scope tag_list .)
    VARIABLE        reduce using rule 15 (tag_list -> tag # scope tag_list .)
    (               reduce using rule 15 (tag_list -> tag # scope tag_list .)
    NUMBER          reduce using rule 15 (tag_list -> tag # scope tag_list .)
    BOOLEAN         reduce using rule 15 (tag_list -> tag # scope tag_list .)
    STRING          reduce using rule 15 (tag_list -> tag # scope tag_list .)
    WORD            reduce using rule 15 (tag_list -> tag # scope tag_list .)
    FUNCTION        reduce using rule 15 (tag_list -> tag # scope tag_list .)
    %               reduce using rule 15 (tag_list -> tag # scope tag_list .)
    {               reduce using rule 15 (tag_list -> tag # scope tag_list .)
    $end            reduce using rule 15 (tag_list -> tag # scope tag_list .)
    }               reduce using rule 15 (tag_list -> tag # scope tag_list .)
    )               reduce using rule 15 (tag_list -> tag # scope tag_list .)
    ,               reduce using rule 15 (tag_list -> tag # scope tag_list .)
    ]               reduce using rule 15 (tag_list -> tag # scope tag_list .)
    #               reduce using rule 15 (tag_list -> tag # scope tag_list .)


state 108

    (22) param_element_pos -> WORD = . expression , param_element_pos
    (23) param_element_pos -> WORD = . expression ,
    (24) param_element_pos -> WORD = . expression
    (71) expression -> . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    expression                     shift and go to state 113
    comp                           shift and go to state 7
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22
    scope                          shift and go to state 10

state 109

    (57) table_contents -> STRING : expression , . table_contents
    (59) table_contents -> STRING : expression , .
    (57) table_contents -> . STRING : expression , table_contents
    (58) table_contents -> . NUMBER : expression , table_contents
    (59) table_contents -> . STRING : expression ,
    (60) table_contents -> . NUMBER : expression ,
    (61) table_contents -> . STRING : expression
    (62) table_contents -> . NUMBER : expression

    }               reduce using rule 59 (table_contents -> STRING : expression , .)
    STRING          shift and go to state 80
    NUMBER          shift and go to state 81

    table_contents                 shift and go to state 114

state 110

    (58) table_contents -> NUMBER : expression , . table_contents
    (60) table_contents -> NUMBER : expression , .
    (57) table_contents -> . STRING : expression , table_contents
    (58) table_contents -> . NUMBER : expression , table_contents
    (59) table_contents -> . STRING : expression ,
    (60) table_contents -> . NUMBER : expression ,
    (61) table_contents -> . STRING : expression
    (62) table_contents -> . NUMBER : expression

    }               reduce using rule 60 (table_contents -> NUMBER : expression , .)
    STRING          shift and go to state 80
    NUMBER          shift and go to state 81

    table_contents                 shift and go to state 115

state 111

    (4) elif_branch -> ELSEIF ( . expression ) scope elif_branch
    (5) elif_branch -> ELSEIF ( . expression ) scope else_branch
    (6) elif_branch -> ELSEIF ( . expression ) scope
    (71) expression -> . comp
    (33) comp -> . NOT comp
    (34) comp -> . arith LT arith
    (35) comp -> . arith LE arith
    (36) comp -> . arith GT arith
    (37) comp -> . arith GE arith
    (38) comp -> . arith EE arith
    (39) comp -> . arith NE arith
    (40) comp -> . comp AND comp
    (41) comp -> . comp OR comp
    (42) comp -> . arith
    (43) arith -> . atom + atom
    (44) arith -> . atom - atom
    (45) arith -> . atom * atom
    (46) arith -> . atom / atom
    (47) arith -> . atom
    (52) arith -> . MIN ( comma_expressions )
    (53) arith -> . MAX ( comma_expressions )
    (1) atom -> . VARIABLE = expression
    (2) atom -> . VARIABLE
    (32) atom -> . function_call
    (48) atom -> . - atom
    (54) atom -> . ( expression )
    (65) atom -> . NUMBER
    (66) atom -> . BOOLEAN
    (67) atom -> . STRING
    (68) atom -> . table
    (69) atom -> . WORD
    (70) atom -> . scope
    (10) function_call -> . FUNCTION parameters scope
    (11) function_call -> . FUNCTION parameters tag_list
    (12) function_call -> . FUNCTION parameters
    (13) function_call -> . FUNCTION
    (63) table -> . % [ comma_expressions ]
    (64) table -> . % { table_contents }
    (17) scope -> . { expressions }

    NOT             shift and go to state 11
    MIN             shift and go to state 15
    MAX             shift and go to state 16
    VARIABLE        shift and go to state 17
    -               shift and go to state 14
    (               shift and go to state 9
    NUMBER          shift and go to state 19
    BOOLEAN         shift and go to state 20
    STRING          shift and go to state 21
    WORD            shift and go to state 23
    FUNCTION        shift and go to state 24
    %               shift and go to state 25
    {               shift and go to state 26

    expression                     shift and go to state 116
    scope                          shift and go to state 10
    comp                           shift and go to state 7
    arith                          shift and go to state 12
    atom                           shift and go to state 13
    function_call                  shift and go to state 18
    table                          shift and go to state 22

state 112

    (3) else_branch -> ELSE scope .

    BREAK           reduce using rule 3 (else_branch -> ELSE scope .)
    RETURN          reduce using rule 3 (else_branch -> ELSE scope .)
    IF              reduce using rule 3 (else_branch -> ELSE scope .)
    NOT             reduce using rule 3 (else_branch -> ELSE scope .)
    MIN             reduce using rule 3 (else_branch -> ELSE scope .)
    MAX             reduce using rule 3 (else_branch -> ELSE scope .)
    VARIABLE        reduce using rule 3 (else_branch -> ELSE scope .)
    -               reduce using rule 3 (else_branch -> ELSE scope .)
    (               reduce using rule 3 (else_branch -> ELSE scope .)
    NUMBER          reduce using rule 3 (else_branch -> ELSE scope .)
    BOOLEAN         reduce using rule 3 (else_branch -> ELSE scope .)
    STRING          reduce using rule 3 (else_branch -> ELSE scope .)
    WORD            reduce using rule 3 (else_branch -> ELSE scope .)
    FUNCTION        reduce using rule 3 (else_branch -> ELSE scope .)
    %               reduce using rule 3 (else_branch -> ELSE scope .)
    {               reduce using rule 3 (else_branch -> ELSE scope .)
    $end            reduce using rule 3 (else_branch -> ELSE scope .)
    }               reduce using rule 3 (else_branch -> ELSE scope .)


state 113

    (22) param_element_pos -> WORD = expression . , param_element_pos
    (23) param_element_pos -> WORD = expression . ,
    (24) param_element_pos -> WORD = expression .

    ,               shift and go to state 117
    )               reduce using rule 24 (param_element_pos -> WORD = expression .)


state 114

    (57) table_contents -> STRING : expression , table_contents .

    }               reduce using rule 57 (table_contents -> STRING : expression , table_contents .)


state 115

    (58) table_contents -> NUMBER : expression , table_contents .

    }               reduce using rule 58 (table_contents -> NUMBER : expression , table_contents .)


state 116

    (4) elif_branch -> ELSEIF ( expression . ) scope elif_branch
    (5) elif_branch -> ELSEIF ( expression . ) scope else_branch
    (6) elif_branch -> ELSEIF ( expression . ) scope

    )               shift and go to state 118


state 117

    (22) param_element_pos -> WORD = expression , . param_element_pos
    (23) param_element_pos -> WORD = expression , .
    (22) param_element_pos -> . WORD = expression , param_element_pos
    (23) param_element_pos -> . WORD = expression ,
    (24) param_element_pos -> . WORD = expression

    )               reduce using rule 23 (param_element_pos -> WORD = expression , .)
    WORD            shift and go to state 119

    param_element_pos              shift and go to state 120

state 118

    (4) elif_branch -> ELSEIF ( expression ) . scope elif_branch
    (5) elif_branch -> ELSEIF ( expression ) . scope else_branch
    (6) elif_branch -> ELSEIF ( expression ) . scope
    (17) scope -> . { expressions }

    {               shift and go to state 26

    scope                          shift and go to state 121

state 119

    (22) param_element_pos -> WORD . = expression , param_element_pos
    (23) param_element_pos -> WORD . = expression ,
    (24) param_element_pos -> WORD . = expression

    =               shift and go to state 108


state 120

    (22) param_element_pos -> WORD = expression , param_element_pos .

    )               reduce using rule 22 (param_element_pos -> WORD = expression , param_element_pos .)


state 121

    (4) elif_branch -> ELSEIF ( expression ) scope . elif_branch
    (5) elif_branch -> ELSEIF ( expression ) scope . else_branch
    (6) elif_branch -> ELSEIF ( expression ) scope .
    (4) elif_branch -> . ELSEIF ( expression ) scope elif_branch
    (5) elif_branch -> . ELSEIF ( expression ) scope else_branch
    (6) elif_branch -> . ELSEIF ( expression ) scope
    (3) else_branch -> . ELSE scope

    BREAK           reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    RETURN          reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    IF              reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    NOT             reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    MIN             reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    MAX             reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    VARIABLE        reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    -               reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    (               reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    NUMBER          reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    BOOLEAN         reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    STRING          reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    WORD            reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    FUNCTION        reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    %               reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    {               reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    $end            reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    }               reduce using rule 6 (elif_branch -> ELSEIF ( expression ) scope .)
    ELSEIF          shift and go to state 105
    ELSE            shift and go to state 106

    elif_branch                    shift and go to state 122
    else_branch                    shift and go to state 123

state 122

    (4) elif_branch -> ELSEIF ( expression ) scope elif_branch .

    BREAK           reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    RETURN          reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    IF              reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    NOT             reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    MIN             reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    MAX             reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    VARIABLE        reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    -               reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    (               reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    NUMBER          reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    BOOLEAN         reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    STRING          reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    WORD            reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    FUNCTION        reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    %               reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    {               reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    $end            reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)
    }               reduce using rule 4 (elif_branch -> ELSEIF ( expression ) scope elif_branch .)


state 123

    (5) elif_branch -> ELSEIF ( expression ) scope else_branch .

    BREAK           reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    RETURN          reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    IF              reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    NOT             reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    MIN             reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    MAX             reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    VARIABLE        reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    -               reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    (               reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    NUMBER          reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    BOOLEAN         reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    STRING          reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    WORD            reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    FUNCTION        reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    %               reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    {               reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    $end            reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)
    }               reduce using rule 5 (elif_branch -> ELSEIF ( expression ) scope else_branch .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NOT in state 6 resolved as shift
WARNING: shift/reduce conflict for MIN in state 6 resolved as shift
WARNING: shift/reduce conflict for MAX in state 6 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 6 resolved as shift
WARNING: shift/reduce conflict for - in state 6 resolved as shift
WARNING: shift/reduce conflict for ( in state 6 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 6 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 6 resolved as shift
WARNING: shift/reduce conflict for STRING in state 6 resolved as shift
WARNING: shift/reduce conflict for WORD in state 6 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 6 resolved as shift
WARNING: shift/reduce conflict for % in state 6 resolved as shift
WARNING: shift/reduce conflict for { in state 6 resolved as shift
WARNING: shift/reduce conflict for AND in state 7 resolved as shift
WARNING: shift/reduce conflict for OR in state 7 resolved as shift
WARNING: shift/reduce conflict for LT in state 12 resolved as shift
WARNING: shift/reduce conflict for LE in state 12 resolved as shift
WARNING: shift/reduce conflict for GT in state 12 resolved as shift
WARNING: shift/reduce conflict for GE in state 12 resolved as shift
WARNING: shift/reduce conflict for EE in state 12 resolved as shift
WARNING: shift/reduce conflict for NE in state 12 resolved as shift
WARNING: shift/reduce conflict for - in state 13 resolved as shift
WARNING: shift/reduce conflict for + in state 13 resolved as shift
WARNING: shift/reduce conflict for * in state 13 resolved as shift
WARNING: shift/reduce conflict for / in state 13 resolved as shift
WARNING: shift/reduce conflict for ( in state 24 resolved as shift
WARNING: shift/reduce conflict for AND in state 33 resolved as shift
WARNING: shift/reduce conflict for OR in state 33 resolved as shift
WARNING: shift/reduce conflict for { in state 48 resolved as shift
